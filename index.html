<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Modular Arithmetic & Number Theory Research Suite - 12 Canvas Explorer | By Wessen Getachew</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;600&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-deep: #0a0e27;
            --bg-mid: #141b3d;
            --bg-light: #1e2a4a;
            --gold: #ffd700;
            --gold-dim: #b8960f;
            --cyan: #00ffff;
            --cyan-dim: #008b8b;
            --geodesic: #1abc9c;
            --cusp: #e67e22;
            --prime: #3498db;
            --text: #e8f1f5;
            --text-dim: #8899aa;
            --border: rgba(255, 215, 0, 0.3);
            
            /* 12 Canvas Colors */
            --c1-gold: #ffd700;
            --c2-teal: #1abc9c;
            --c3-blue: #3498db;
            --c4-orange: #e67e22;
            --c5-purple: #9b59b6;
            --c6-pink: #e91e63;
            --c7-green: #2ecc71;
            --c8-yellow: #f1c40f;
            --c9-red: #e74c3c;
            --c10-indigo: #6366f1;
            --c11-lime: #27ae60;
            --c12-magenta: #9c27b0;
        }

        body {
            font-family: 'Libre Baskerville', serif;
            background: radial-gradient(ellipse at center, var(--bg-mid) 0%, var(--bg-deep) 100%);
            color: var(--text);
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        body::after {
            content: 'PSL(2,‚Ñ§)';
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-family: 'Fira Code', monospace;
            font-size: 6em;
            color: rgba(255, 215, 0, 0.03);
            font-weight: 700;
            z-index: 0;
            pointer-events: none;
        }

        .starfield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            animation: twinkle 4s ease-in-out infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.5); }
        }

        .main-container {
            max-width: 2400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            padding: 40px 20px 30px;
            position: relative;
            margin-bottom: 30px;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--gold), transparent);
        }

        header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--cyan), transparent);
        }

        h1 {
            font-size: 2.8em;
            font-weight: 700;
            margin-bottom: 15px;
            position: relative;
            display: inline-block;
        }

        h1::before {
            content: '‚ü®';
            color: var(--gold);
            margin-right: 15px;
            font-size: 1.2em;
        }

        h1::after {
            content: '‚ü©';
            color: var(--gold);
            margin-left: 15px;
            font-size: 1.2em;
        }

        .title-main {
            background: linear-gradient(135deg, var(--gold) 0%, var(--cyan) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
        }

        .subtitle {
            font-size: 1em;
            color: var(--text-dim);
            font-style: italic;
            letter-spacing: 2px;
            font-family: 'Fira Code', monospace;
        }

        .viz-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .viz-grid.four-panel {
            grid-template-columns: repeat(2, 1fr);
        }

        .canvas-panel {
            background: linear-gradient(135deg, var(--bg-light) 0%, var(--bg-mid) 100%);
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .canvas-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(0deg, transparent 24%, rgba(255, 255, 255, 0.02) 25%, rgba(255, 255, 255, 0.02) 26%, transparent 27%, transparent 74%, rgba(255, 255, 255, 0.02) 75%, rgba(255, 255, 255, 0.02) 76%, transparent 77%, transparent),
                linear-gradient(90deg, transparent 24%, rgba(255, 255, 255, 0.02) 25%, rgba(255, 255, 255, 0.02) 26%, transparent 27%, transparent 74%, rgba(255, 255, 255, 0.02) 75%, rgba(255, 255, 255, 0.02) 76%, transparent 77%, transparent);
            background-size: 50px 50px;
            pointer-events: none;
        }

        .panel-header {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.1), rgba(0, 255, 255, 0.1));
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title {
            font-size: 1.3em;
            font-weight: 700;
            font-family: 'Fira Code', monospace;
            color: var(--gold);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .panel-subtitle {
            font-size: 0.85em;
            color: var(--text-dim);
            font-family: 'Fira Code', monospace;
            font-style: italic;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            background: radial-gradient(ellipse at center, rgba(26, 26, 46, 0.5), rgba(10, 14, 39, 0.9));
        }

        .controls-section {
            background: linear-gradient(135deg, var(--bg-light) 0%, var(--bg-mid) 100%);
            border: 1px solid var(--border);
            margin-bottom: 30px;
            position: relative;
        }

        .controls-header {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.15), rgba(0, 255, 255, 0.15));
            padding: 20px;
            border-bottom: 1px solid var(--border);
            font-family: 'Fira Code', monospace;
            font-size: 1.2em;
            font-weight: 600;
            color: var(--gold);
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .controls-header::before {
            content: '‚öô ';
            margin-right: 10px;
        }

        .controls-body {
            padding: 30px;
        }

        .control-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 4px;
            transition: all 0.3s;
        }

        .control-item:hover {
            border-color: var(--gold);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-family: 'Fira Code', monospace;
            font-size: 0.85em;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-value {
            color: var(--cyan);
            font-weight: 600;
            font-size: 1.1em;
            font-family: 'Fira Code', monospace;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            color: var(--cyan);
            font-family: 'Fira Code', monospace;
            font-size: 1em;
            transition: all 0.3s;
        }

        input[type="number"]:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--cyan);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: linear-gradient(90deg, var(--gold-dim), var(--cyan-dim));
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--gold);
            border: 2px solid var(--bg-deep);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--gold);
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            width: 22px;
            height: 22px;
            box-shadow: 0 0 20px var(--gold);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--gold);
            border: 2px solid var(--bg-deep);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--gold);
        }

        .section-header {
            font-family: 'Fira Code', monospace;
            color: var(--gold);
            font-size: 1.1em;
            margin: 25px 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Canvas-specific color coding */
        .canvas-disk {
            color: #ffd700 !important;
            border-bottom-color: rgba(255, 215, 0, 0.5) !important;
        }
        
        .canvas-cayley {
            color: #1abc9c !important;
            border-bottom-color: rgba(26, 188, 156, 0.5) !important;
        }
        
        .canvas-nested {
            color: #3498db !important;
            border-bottom-color: rgba(52, 152, 219, 0.5) !important;
        }
        
        .canvas-reduction {
            color: #e67e22 !important;
            border-bottom-color: rgba(230, 126, 34, 0.5) !important;
        }
        
        .canvas-fullplane {
            color: #9b59b6 !important;
            border-bottom-color: rgba(155, 89, 182, 0.5) !important;
        }
        
        .canvas-primitive {
            color: #e91e63 !important;
            border-bottom-color: rgba(233, 30, 99, 0.5) !important;
        }
        
        .canvas-global {
            color: #00ffff !important;
            border-bottom-color: rgba(0, 255, 255, 0.5) !important;
        }

        .toggle-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle-item:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--cyan);
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            transition: all 0.3s;
            border: 1px solid var(--text-dim);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--text-dim);
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }

        input[type="checkbox"] {
            display: none;
        }

        input[type="checkbox"]:checked + .toggle-item .toggle-switch {
            background: var(--gold);
            border-color: var(--gold);
        }

        input[type="checkbox"]:checked + .toggle-item .toggle-switch::after {
            left: 28px;
            background: white;
            box-shadow: 0 0 10px var(--gold);
        }

        .toggle-label {
            font-family: 'Fira Code', monospace;
            font-size: 0.9em;
            color: var(--text);
            flex: 1;
        }

        .action-bar {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 25px;
            padding-top: 25px;
            border-top: 1px solid rgba(255, 215, 0, 0.2);
        }

        .btn {
            padding: 12px 30px;
            font-family: 'Fira Code', monospace;
            font-size: 0.9em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.5s, height 0.5s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn span {
            position: relative;
            z-index: 1;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--gold-dim), var(--gold));
            color: var(--bg-deep);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }

        .btn-primary:hover {
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.5);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--cyan-dim), var(--cyan));
            color: var(--bg-deep);
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            box-shadow: 0 6px 25px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .btn-accent {
            background: linear-gradient(135deg, #e67e22, #e74c3c);
            color: white;
            box-shadow: 0 4px 15px rgba(230, 126, 34, 0.3);
        }

        .farey-point-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .farey-point-item {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .farey-point-item input {
            flex: 1;
        }

        .remove-btn {
            padding: 5px 10px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            font-size: 0.8em;
        }

        .remove-btn:hover {
            background: #c0392b;
        }

        .add-btn {
            padding: 8px 20px;
            background: var(--geodesic);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .add-btn:hover {
            background: #16a085;
        }

        select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            color: var(--cyan);
            font-family: 'Fira Code', monospace;
            font-size: 0.9em;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: var(--cyan);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .help-text {
            font-size: 0.8em;
            color: var(--text-dim);
            font-style: italic;
            margin-top: 5px;
        }

        .control-item:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.95);
            color: var(--gold);
            font-size: 0.85em;
            border: 1px solid var(--gold);
            border-radius: 4px;
            white-space: normal;
            width: max-content;
            max-width: 300px;
            z-index: 1000;
            pointer-events: none;
            margin-bottom: 5px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .toggle-item:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.95);
            color: var(--cyan);
            font-size: 0.85em;
            border: 1px solid var(--cyan);
            border-radius: 4px;
            white-space: normal;
            width: max-content;
            max-width: 300px;
            z-index: 1000;
            pointer-events: none;
            margin-bottom: 5px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .control-item, .toggle-item {
            position: relative;
        }

        /* Interactive inspection styles */
        .property-panel {
            position: fixed;
            background: linear-gradient(135deg, rgba(10, 14, 39, 0.98), rgba(20, 30, 60, 0.98));
            border: 2px solid var(--gold);
            border-radius: 12px;
            padding: 20px;
            min-width: 320px;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            z-index: 10000;
            font-family: 'Fira Code', monospace;
            display: none;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .property-panel.visible {
            display: block;
        }

        .property-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--gold);
        }

        .property-panel-title {
            font-size: 1.2em;
            color: var(--gold);
            font-weight: bold;
        }

        .property-panel-close {
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.5em;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.3s;
        }

        .property-panel-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--gold);
        }

        .property-item {
            margin: 12px 0;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid var(--cyan);
            border-radius: 4px;
        }

        .property-label {
            font-size: 0.85em;
            color: var(--text-dim);
            margin-bottom: 4px;
        }

        .property-value {
            font-size: 1em;
            color: var(--cyan);
            font-weight: 600;
        }

        .property-highlight {
            background: rgba(255, 215, 0, 0.1);
            border-left-color: var(--gold);
        }

        .property-highlight .property-value {
            color: var(--gold);
        }

        .tooltip {
            position: fixed;
            background: rgba(10, 14, 39, 0.95);
            border: 1px solid var(--cyan);
            border-radius: 6px;
            padding: 8px 12px;
            font-family: 'Fira Code', monospace;
            font-size: 0.85em;
            color: var(--text);
            pointer-events: none;
            z-index: 9999;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
            white-space: nowrap;
        }

        .tooltip.visible {
            display: block;
        }

        .tooltip-label {
            color: var(--gold);
            font-weight: bold;
            margin-bottom: 2px;
        }

        .tooltip-value {
            color: var(--cyan);
        }

        canvas {
            cursor: default;
        }

        canvas.interactive {
            cursor: pointer;
        }

        @media (max-width: 2000px) {
            .viz-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 1400px) {
            .viz-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 1200px) {
            .viz-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }
            .control-row {
                grid-template-columns: 1fr;
            }
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-deep);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-symbol {
            font-size: 4em;
            color: var(--gold);
            font-family: 'Fira Code', monospace;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        .loading-text {
            margin-top: 20px;
            font-family: 'Fira Code', monospace;
            color: var(--text-dim);
            letter-spacing: 2px;
        }

        .export-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .export-dialog-content {
            background: linear-gradient(135deg, var(--bg-light) 0%, var(--bg-mid) 100%);
            border: 2px solid var(--gold);
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        }

        .export-dialog-header {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.2), rgba(0, 255, 255, 0.2));
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .export-dialog-header h3 {
            font-family: 'Fira Code', monospace;
            color: var(--gold);
            font-size: 1.4em;
            margin: 0;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.5em;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.3s;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--gold);
        }

        .export-dialog-body {
            padding: 30px;
        }

        .export-section {
            margin-bottom: 25px;
        }

        .export-section h4 {
            font-family: 'Fira Code', monospace;
            color: var(--cyan);
            font-size: 1.1em;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .export-radio-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .export-radio {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Fira Code', monospace;
        }

        .export-radio:hover {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.05);
        }

        .export-radio input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .export-radio input[type="radio"]:checked + span {
            color: var(--gold);
            font-weight: 600;
        }

        .export-checkbox {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Fira Code', monospace;
        }

        .export-checkbox:hover {
            border-color: var(--cyan);
            background: rgba(0, 255, 255, 0.05);
        }

        .export-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--cyan);
            position: relative;
        }

        .export-checkbox input[type="checkbox"]:checked + span {
            color: var(--cyan);
            font-weight: 600;
        }

        .export-checkbox input[type="checkbox"]:not(:checked) + span {
            color: var(--text-dim);
            opacity: 0.7;
        }

        .legend-container {
            position: absolute;
            background: rgba(10, 14, 39, 0.95);
            border: 2px solid var(--gold);
            border-radius: 8px;
            padding: 20px;
            font-family: 'Fira Code', monospace;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        }

        .legend-title {
            font-size: 1.2em;
            color: var(--gold);
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 2px solid var(--gold);
            padding-bottom: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .legend-symbol {
            width: 30px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .legend-text {
            color: var(--text);
        }

        /* Research Page Header */
        .research-header {
            background: linear-gradient(135deg, var(--bg-deep) 0%, var(--bg-mid) 100%);
            border-bottom: 3px solid var(--gold);
            padding: 30px 40px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 100;
        }

        .research-title {
            font-family: 'Libre Baskerville', serif;
            font-size: 2.5em;
            color: var(--gold);
            margin: 0 0 10px 0;
            font-weight: 700;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
        }

        .research-subtitle {
            font-family: 'Fira Code', monospace;
            font-size: 1.1em;
            color: var(--cyan);
            margin: 0 0 15px 0;
            font-weight: 300;
            letter-spacing: 1px;
        }

        .research-author {
            font-family: 'Libre Baskerville', serif;
            font-size: 1em;
            color: var(--text);
            margin: 0;
            font-style: italic;
        }

        .research-author strong {
            color: var(--gold);
            font-weight: 700;
        }

        .research-meta {
            display: flex;
            gap: 30px;
            margin-top: 15px;
            font-family: 'Fira Code', monospace;
            font-size: 0.85em;
            color: var(--text-dim);
            flex-wrap: wrap;
        }

        .research-meta-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .research-meta-label {
            color: var(--cyan);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <!-- Research Page Header -->
    <div class="research-header">
        <h1 class="research-title">Interactive Modular Arithmetic & Number Theory Research Suite</h1>
        <h2 class="research-subtitle">Comprehensive 12-Canvas Visualization Tool for Advanced Mathematical Exploration</h2>
        <p class="research-author">Research & Development by <strong>Wessen Getachew</strong> ¬∑ Twitter <a href="https://twitter.com/7dview" target="_blank" rel="noopener" style="color: #00ffff; text-decoration: none;">@7dview</a></p>
        <div class="research-meta">
            <div class="research-meta-item">
                <span class="research-meta-label">Features:</span>
                <span>12 Interactive Canvases | Unlimited Parameters | 2K Export | Statistical Analysis | CSV Data</span>
            </div>
            <div class="research-meta-item">
                <span class="research-meta-label">Topics:</span>
                <span>Farey Sequences | Cayley Transforms | Prime Distribution | Primitive Roots | Coprime Density | Dirichlet Characters</span>
            </div>
            <div class="research-meta-item" style="margin-top: 10px;">
                <span class="research-meta-label">More Tools:</span>
                <span style="display: flex; gap: 12px; flex-wrap: wrap; margin-top: 5px;">
                    <a href="https://wessengetachew.github.io/Transform/" target="_blank" style="color: #00ffff; text-decoration: none; padding: 4px 8px; background: rgba(0,255,255,0.1); border-radius: 4px; font-size: 0.9em; transition: all 0.3s;" onmouseover="this.style.background='rgba(0,255,255,0.2)'" onmouseout="this.style.background='rgba(0,255,255,0.1)'">Transform Explorer</a>
                    <a href="https://wessengetachew.github.io/Composite/" target="_blank" style="color: #00ffff; text-decoration: none; padding: 4px 8px; background: rgba(0,255,255,0.1); border-radius: 4px; font-size: 0.9em; transition: all 0.3s;" onmouseover="this.style.background='rgba(0,255,255,0.2)'" onmouseout="this.style.background='rgba(0,255,255,0.1)'">Composite Analysis</a>
                    <a href="https://wessengetachew.github.io/Gemini/" target="_blank" style="color: #00ffff; text-decoration: none; padding: 4px 8px; background: rgba(0,255,255,0.1); border-radius: 4px; font-size: 0.9em; transition: all 0.3s;" onmouseover="this.style.background='rgba(0,255,255,0.2)'" onmouseout="this.style.background='rgba(0,255,255,0.1)'">Gemini Explorer</a>
                    <a href="https://wessengetachew.github.io/Goldbach/" target="_blank" style="color: #00ffff; text-decoration: none; padding: 4px 8px; background: rgba(0,255,255,0.1); border-radius: 4px; font-size: 0.9em; transition: all 0.3s;" onmouseover="this.style.background='rgba(0,255,255,0.2)'" onmouseout="this.style.background='rgba(0,255,255,0.1)'">Goldbach Conjecture</a>
                    <a href="https://wessengetachew.github.io/Primes/" target="_blank" style="color: #00ffff; text-decoration: none; padding: 4px 8px; background: rgba(0,255,255,0.1); border-radius: 4px; font-size: 0.9em; transition: all 0.3s;" onmouseover="this.style.background='rgba(0,255,255,0.2)'" onmouseout="this.style.background='rgba(0,255,255,0.1)'">Prime Explorer</a>
                    <a href="https://wessengetachew.github.io/Farey/" target="_blank" style="color: #00ffff; text-decoration: none; padding: 4px 8px; background: rgba(0,255,255,0.1); border-radius: 4px; font-size: 0.9em; transition: all 0.3s;" onmouseover="this.style.background='rgba(0,255,255,0.2)'" onmouseout="this.style.background='rgba(0,255,255,0.1)'">Farey Sequences</a>
                    <a href="https://wessengetachew.github.io/2pir/" target="_blank" style="color: #00ffff; text-decoration: none; padding: 4px 8px; background: rgba(0,255,255,0.1); border-radius: 4px; font-size: 0.9em; transition: all 0.3s;" onmouseover="this.style.background='rgba(0,255,255,0.2)'" onmouseout="this.style.background='rgba(0,255,255,0.1)'">2œÄr Analysis</a>
                </span>
            </div>
        </div>
    </div>

    <div class="loading" id="loading">
        <div class="loading-symbol">Œ∂(s)</div>
        <div class="loading-text">Initializing Unlimited Explorer...</div>
    </div>

    <div class="starfield" id="starfield"></div>

    <!-- Interactive Inspection UI -->
    <div id="tooltip" class="tooltip"></div>
    <div id="propertyPanel" class="property-panel">
        <div class="property-panel-header">
            <div class="property-panel-title" id="propertyPanelTitle">Point Properties</div>
            <button class="property-panel-close" onclick="closePropertyPanel()">‚úï</button>
        </div>
        <div id="propertyPanelContent"></div>
    </div>

    <div class="main-container">

        <!-- Introduction Panel -->
        <div class="controls-section" style="margin-bottom: 20px;">
            <div class="controls-header" style="cursor: pointer; user-select: none;" onclick="toggleIntro()">
                <span id="introToggle">&#9654;</span> Mathematical Introduction
            </div>
            <div class="controls-body" id="introPanel" style="display: none;">
                <div style="line-height: 1.8; font-size: 0.95em;">
                    
                    <div style="background: rgba(52, 152, 219, 0.15); padding: 20px; border-left: 4px solid #3498db; margin-bottom: 20px; border-radius: 4px;">
                        <h3 style="color: #3498db; margin-bottom: 15px;">Transform Types Available</h3>
                        
                        <p style="margin-bottom: 10px;"><strong>Standard Cayley:</strong> w = i(1+z)/(1-z)</p>
                        <p style="margin-left: 20px; margin-bottom: 15px; color: rgba(255,255,255,0.85);">
                            The canonical conformal bijection mapping the Poincar√© disk model |z| &lt; 1 to the upper half-plane Im(w) &gt; 0. This is the standard form used in hyperbolic geometry and modular forms theory.
                            <br><strong>Key mappings:</strong> z=0 ‚Üí w=i, z=1 ‚Üí w=‚àû, z=-1 ‚Üí w=0, unit circle ‚Üí real axis.
                        </p>
                        
                        <p style="margin-bottom: 10px;"><strong>Inverse Cayley:</strong> w = i(1-z)/(1+z)</p>
                        <p style="margin-left: 20px; margin-bottom: 15px; color: rgba(255,255,255,0.85);">
                            An alternative conformal map also taking disk to upper half-plane, but with reversed orientation along the real axis. Still preserves the hyperbolic metric but maps z=0 ‚Üí w=i, z=1 ‚Üí w=0, z=-1 ‚Üí w=‚àû.
                        </p>
                        
                        <p style="margin-bottom: 10px;"><strong>FTT Transform:</strong> w = (z-i)/(z+i)</p>
                        <p style="margin-left: 20px; margin-bottom: 15px; color: rgba(255,255,255,0.85);">
                            This is the <em>inverse</em> of the standard Cayley transform. It maps the upper half-plane <em>back to</em> the unit disk. Specifically: upper half-plane Im(z) &gt; 0 ‚Üí unit disk interior |w| &lt; 1, real axis Im(z) = 0 ‚Üí unit circle |w| = 1.
                        </p>
                        
                        <p style="margin-bottom: 10px;"><strong>Smith Chart:</strong> w = (z-1)/(z+1)</p>
                        <p style="margin-left: 20px; margin-bottom: 15px; color: rgba(255,255,255,0.85);">
                            A disk-to-disk transformation (|z| &lt; 1 ‚Üí |w| &lt; 1) widely used in RF/microwave engineering for impedance visualization. Maps the right half-plane to the unit disk, with the real axis mapping to the unit circle. Different fixed points than Cayley transforms.
                        </p>
                        
                        <p style="margin-bottom: 10px;"><strong>M√∂bius (General):</strong> w = (az+b)/(cz+d) where ad-bc ‚â† 0</p>
                        <p style="margin-left: 20px; margin-bottom: 15px; color: rgba(255,255,255,0.85);">
                            The most general linear fractional transformation. These form a group under composition and represent all conformal automorphisms of the Riemann sphere. The constraint ad-bc ‚â† 0 ensures invertibility. All other transforms above are special cases with specific (a,b,c,d) values.
                        </p>
                        
                        <p style="margin-top: 20px;"><strong>Key Properties (Standard Cayley):</strong></p>
                        <ul style="margin-left: 25px; margin-bottom: 10px;">
                            <li><strong>Conformal:</strong> Preserves angles locally at every point</li>
                            <li><strong>Bijective:</strong> One-to-one correspondence between disk and upper half-plane</li>
                            <li><strong>Isometry:</strong> Maps hyperbolic geodesics to hyperbolic geodesics</li>
                            <li><strong>Boundary behavior:</strong> Unit circle |z|=1 maps to real axis Im(w)=0</li>
                            <li><strong>Interior/exterior:</strong> |z| &lt; 1 ‚Üí Im(w) &gt; 0, |z| &gt; 1 ‚Üí Im(w) &lt; 0</li>
                            <li><strong>Inverse formula:</strong> z = (w-i)/(w+i) or equivalently z = (i-w)/(i+w)</li>
                        </ul>
                        
                        <p style="margin-top: 15px;"><strong>Relationships:</strong></p>
                        <ul style="margin-left: 25px;">
                            <li>Standard Cayley and FTT are functional inverses: Cayley(FTT(z)) = z</li>
                            <li>All transforms preserve circles and lines (map them to circles or lines)</li>
                            <li>Composition of M√∂bius transformations is a M√∂bius transformation</li>
                            <li>The set of all M√∂bius transformations forms the group PSL(2,‚ÑÇ) ‚âÖ Aut(‚ÑÇÃÇ)</li>
                        </ul>
                    </div>
                    
                    <h3 style="color: var(--gold); margin-bottom: 15px;">Mathematical Overview</h3>
                    
                    <p style="margin-bottom: 15px;">This visualization tool explores the profound connections between <strong>number theory</strong>, <strong>hyperbolic geometry</strong>, and <strong>complex analysis</strong> through conformal mappings and modular arithmetic. Four complementary perspectives reveal how rational numbers, prime distributions, and hyperbolic structures interrelate through the lens of the modular group PSL(2,‚Ñ§).</p>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0;">
                        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-left: 3px solid var(--gold);">
                            <h4 style="color: var(--gold); margin-bottom: 8px;">Unit Disk Model (ùîª)</h4>
                            <p style="font-size: 0.9em;">The Poincar√© disk model of hyperbolic geometry: {z ‚àà ‚ÑÇ : |z| &lt; 1}. Points from the <strong>Farey sequence</strong> F_n‚Äîthe set of all reduced fractions p/q with 0 ‚â§ p ‚â§ q ‚â§ n ordered by value‚Äîare mapped to angles 2œÄp/q on the unit circle ‚àÇùîª. The Farey triangle connecting these boundary points has the mediant property: for adjacent fractions p/q and r/s in F_n, we have |ps - qr| = 1 (the determinant condition). Prime numbers are positioned at angles 2œÄp/m where p is prime and m is the modulus, revealing <strong>Dirichlet's theorem</strong>: primes are equidistributed among residue classes coprime to m, each with asymptotic density 1/œÜ(m).</p>
                        </div>
                        
                        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-left: 3px solid var(--cyan);">
                            <h4 style="color: var(--cyan); margin-bottom: 8px;">Upper Half-Plane via Cayley (‚Ñç)</h4>
                            <p style="font-size: 0.9em;">The <strong>Cayley transform</strong> w = i(1+z)/(1-z) provides a conformal equivalence between ùîª and the upper half-plane ‚Ñç = {w ‚àà ‚ÑÇ : Im(w) &gt; 0}. This is one of the fundamental isometries of hyperbolic geometry, preserving the hyperbolic metric ds¬≤ = |dz|¬≤/(1-|z|¬≤) on ùîª and ds¬≤ = |dw|¬≤/Im(w)¬≤ on ‚Ñç. <strong>Geodesics</strong> in ‚Ñç appear as semicircles orthogonal to the real axis (or vertical lines). The <strong>modular group</strong> PSL(2,‚Ñ§) = SL(2,‚Ñ§)/{¬±I} acts on ‚Ñç via M√∂bius transformations z ‚Üí (az+b)/(cz+d) where a,b,c,d ‚àà ‚Ñ§ and ad-bc = 1. This group is generated by S(z) = -1/z and T(z) = z+1, and its quotient ‚Ñç/PSL(2,‚Ñ§) is the modular curve, fundamental to the theory of modular forms and elliptic curves.</p>
                        </div>
                        
                        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-left: 3px solid var(--prime);">
                            <h4 style="color: var(--prime); margin-bottom: 8px;">Full Complex Plane (‚ÑÇ)</h4>
                            <p style="font-size: 0.9em;">The fourth panel extends the Cayley transform to visualize the entire Riemann sphere ‚ÑÇÃÇ = ‚ÑÇ ‚à™ {‚àû}. Since the transform is defined everywhere except at z = -1, we see the complete partition:
                            <br>‚Ä¢ <strong>Interior |z| &lt; 1</strong> ‚Üí Upper half-plane Im(w) &gt; 0
                            <br>‚Ä¢ <strong>Unit circle |z| = 1</strong> ‚Üí Real axis Im(w) = 0 
                            <br>‚Ä¢ <strong>Exterior |z| &gt; 1</strong> ‚Üí Lower half-plane Im(w) &lt; 0
                            <br>The point z = 1 maps to ‚àû, z = -1 is the pole (undefined), and z = ¬±i map to the real axis at w = -1 and w = 1 respectively. This complete picture shows how M√∂bius transformations act as conformal automorphisms of ‚ÑÇÃÇ, forming the group PSL(2,‚ÑÇ).</p>
                        </div>
                        
                        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-left: 3px solid var(--geodesic);">
                            <h4 style="color: var(--geodesic); margin-bottom: 8px;">Nested Rings Structure (‚äö)</h4>
                            <p style="font-size: 0.9em;">Concentric rings represent the structure of (‚Ñ§/m‚Ñ§)√ó for moduli m from min to max. Each ring m displays all residue classes k ‚àà {0,1,...,m-1} at angles 2œÄk/m. Points are colored by gcd(k,m), revealing the multiplicative structure. <strong>Gold points</strong> (gcd = 1) form the group of units (‚Ñ§/m‚Ñ§)√ó, whose order is given by <strong>Euler's totient</strong> œÜ(m). The Chinese Remainder Theorem states that if gcd(m‚ÇÅ,m‚ÇÇ) = 1, then ‚Ñ§/(m‚ÇÅm‚ÇÇ)‚Ñ§ ‚âÖ ‚Ñ§/m‚ÇÅ‚Ñ§ √ó ‚Ñ§/m‚ÇÇ‚Ñ§, visible in the coprime point patterns. Connection modes visualize lifts and transitions: in a modular sequence M‚Çô = M‚ÇÄ¬∑b‚Åø, a residue r at level n lifts to {r, r+M‚Çô, r+2M‚Çô, ..., r+(b-1)M‚Çô} at level n+1. If gcd(r,M‚ÇÄ) = gcd(r,b) = 1, then coprimality is preserved: gcd(r,M‚Çô‚Çä‚ÇÅ) = 1.</p>
                        </div>
                    </div>
                    
                    <h3 style="color: var(--gold); margin: 25px 0 15px;">Core Mathematical Concepts</h3>
                    
                    <ul style="list-style: none; padding: 0;">
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">Farey Sequence F_n:</strong> The ordered set {p/q : 0 ‚â§ p ‚â§ q ‚â§ n, gcd(p,q) = 1} of all irreducible fractions with denominator at most n. The sequence has exactly 1 + Œ£_{k=1}^n œÜ(k) elements. <strong>Mediant property:</strong> If p/q and r/s are adjacent in F_n, then |ps - qr| = 1, and their mediant (p+r)/(q+s) first appears in F_{q+s}. The Farey sequence provides a natural parameterization of ‚Ñö ‚à© [0,1] and of rational points on the unit circle.
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">Cayley Transform:</strong> The map w = i(1+z)/(1-z) is a biholomorphic (holomorphic bijection with holomorphic inverse) equivalence ùîª ‚Üí ‚Ñç. It's an isometry of hyperbolic spaces: the Poincar√© disk metric ds¬≤ = 4|dz|¬≤/(1-|z|¬≤)¬≤ corresponds to the upper half-plane metric ds¬≤ = |dw|¬≤/Im(w)¬≤. The inverse is z = (w-i)/(w+i). Under this map, straight lines in ùîª through the origin become vertical lines in ‚Ñç, and circles in ùîª orthogonal to ‚àÇùîª become semicircles in ‚Ñç orthogonal to ‚Ñù‚Äîthese are the geodesics of hyperbolic geometry.
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">Modular Group PSL(2,‚Ñ§):</strong> The quotient SL(2,‚Ñ§)/{¬±I} where SL(2,‚Ñ§) = {[[a,b],[c,d]] : a,b,c,d ‚àà ‚Ñ§, ad-bc = 1}. Acts on ‚Ñç by fractional linear transformations Œ≥¬∑z = (az+b)/(cz+d). Generated by S: z ‚Ü¶ -1/z (order 2) and T: z ‚Ü¶ z+1 (infinite order), with the single relation (ST)¬≥ = I. The fundamental domain is ùíü = {z ‚àà ‚Ñç : |z| ‚â• 1, |Re(z)| ‚â§ 1/2}, and ‚Ñç/PSL(2,‚Ñ§) ‚âÖ ‚ÑÇ, with the quotient map being the j-invariant. This group is central to the theory of <strong>modular forms</strong>: functions f : ‚Ñç ‚Üí ‚ÑÇ satisfying f((az+b)/(cz+d)) = (cz+d)^k f(z) for all [[a,b],[c,d]] ‚àà SL(2,‚Ñ§).
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">Hyperbolic Geodesics:</strong> In the upper half-plane model ‚Ñç, geodesics (paths of shortest hyperbolic distance) are semicircles perpendicular to ‚Ñù, together with vertical rays. The hyperbolic distance between z‚ÇÅ, z‚ÇÇ ‚àà ‚Ñç is d(z‚ÇÅ,z‚ÇÇ) = arccosh(1 + |z‚ÇÅ-z‚ÇÇ|¬≤/(2¬∑Im(z‚ÇÅ)¬∑Im(z‚ÇÇ))). PSL(2,‚Ñ§) acts by isometries, preserving this distance. In the disk model, geodesics are arcs of circles orthogonal to ‚àÇùîª (and diameters).
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">Dirichlet's Theorem on Primes in Arithmetic Progressions:</strong> If gcd(a,m) = 1, the arithmetic progression {a + km : k ‚â• 0} contains infinitely many primes, with density 1/œÜ(m) among all primes. More precisely, œÄ(x; m, a) ~ x/(œÜ(m) log x) as x ‚Üí ‚àû, where œÄ(x; m, a) counts primes p ‚â§ x with p ‚â° a (mod m). This equidistribution is visible in the visualization: primes distribute uniformly among the œÜ(m) residue classes coprime to m.
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">Euler's Totient Function:</strong> œÜ(n) = |{k : 1 ‚â§ k ‚â§ n, gcd(k,n) = 1}| counts integers up to n coprime to n. This is multiplicative: if gcd(m,n) = 1, then œÜ(mn) = œÜ(m)œÜ(n). For prime power p^k, we have œÜ(p^k) = p^k - p^{k-1} = p^{k-1}(p-1). The formula œÜ(n) = n¬∑‚àè_{p|n}(1 - 1/p) expresses œÜ in terms of the prime factorization. The units (‚Ñ§/n‚Ñ§)√ó form a group of order œÜ(n), and by <strong>Euler's theorem</strong>, if gcd(a,n) = 1, then a^{œÜ(n)} ‚â° 1 (mod n).
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">M√∂bius Transformations:</strong> Functions f(z) = (az+b)/(cz+d) where a,b,c,d ‚àà ‚ÑÇ and ad-bc ‚â† 0. These are precisely the conformal automorphisms of the Riemann sphere ‚ÑÇÃÇ. They form a group under composition: if f(z) = (az+b)/(cz+d) and g(z) = (ez+f)/(gz+h), then (f‚àòg)(z) = ((ae+bg)z + (af+bh))/((ce+dg)z + (cf+dh)). The group of M√∂bius transformations is isomorphic to PSL(2,‚ÑÇ) = SL(2,‚ÑÇ)/{¬±I}. Key property: M√∂bius transformations map circles and lines to circles and lines (where lines are considered circles through ‚àû).
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">Ford Circles:</strong> For each rational p/q in lowest terms, the Ford circle C_{p/q} has center (p/q, 1/(2q¬≤)) and radius 1/(2q¬≤) in the upper half-plane. These circles are tangent to the real axis at p/q and are pairwise tangent or disjoint: C_{p/q} and C_{r/s} are tangent iff |ps - qr| = 1 (i.e., they're Farey neighbors). Ford circles provide a beautiful geometric illustration of the Farey sequence and the Stern-Brocot tree structure of rational numbers.
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">Residue Lifts in Modular Sequences:</strong> Given a geometric sequence of moduli M‚Çô = M‚ÇÄ¬∑b‚Åø where b ‚â• 2, a residue r ‚àà ‚Ñ§/M‚Çô‚Ñ§ lifts to the set {r + kM‚Çô mod M‚Çô‚Çä‚ÇÅ : k = 0, 1, ..., b-1} in ‚Ñ§/M‚Çô‚Çä‚ÇÅ‚Ñ§. If gcd(r, M‚ÇÄ) = gcd(r, b) = 1, then coprimality is preserved under lifting: all b lifts satisfy gcd(r + kM‚Çô, M‚Çô‚Çä‚ÇÅ) = 1. This creates a self-similar fractal structure of coprime residues across scales. Gap-g transitions (k, k+g) lift to {(k+jM‚Çô, k+g+jM‚Çô) : j = 0,...,b-1}, preserving the gap structure. When combined with prime distribution (Dirichlet), this reveals how primes populate the modular tower.
                        </li>
                    </ul>
                    
                    <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; margin-top: 20px; border-radius: 4px;">
                        <strong style="color: var(--gold);">Getting Started:</strong> Use the preset buttons in the controls to load common configurations (F‚ÇÉ, F‚ÇÖ, F‚Çá, etc.). Hover over controls for detailed tooltips explaining each parameter. Click any point on the visualizations to see its mathematical properties in a detailed panel. Enable the Interactive Guide below for a step-by-step tutorial. Experiment with different transform types to see how various conformal mappings affect the geometry.
                    </div>

                    <!-- COMPREHENSIVE 12-CANVAS MATHEMATICAL DOCUMENTATION -->
                    <h3 style="color: var(--gold); margin: 35px 0 20px; font-size: 1.8em; border-bottom: 3px solid var(--gold); padding-bottom: 10px;">Complete Mathematical Theory: All 12 Canvases</h3>
                    
                    <div style="background: rgba(0,255,255,0.05); padding: 20px; border: 2px solid var(--cyan); border-radius: 8px; margin-bottom: 25px;">
                        <p style="font-size: 1.05em; line-height: 1.8; margin: 0;">
                            This research suite integrates <strong>12 complementary visualizations</strong> spanning number theory, group theory, analytic number theory, and hyperbolic geometry. Each canvas provides unique mathematical insight while maintaining coherent connections to the underlying modular arithmetic structures.
                        </p>
                    </div>

                    <!-- GROUP 1: FAREY & TRANSFORM SUITE (Canvases 1-6) -->
                    <h4 style="color: var(--gold); font-size: 1.4em; margin: 30px 0 15px; background: linear-gradient(90deg, rgba(255,215,0,0.2), transparent); padding: 10px; border-left: 4px solid var(--gold);">Group 1: Farey Sequence & Transform Suite (Canvases 1-6)</h4>

                    <div style="display: grid; grid-template-columns: 1fr; gap: 20px; margin: 20px 0;">
                        <!-- Canvas 1 -->
                        <div style="background: rgba(255,215,0,0.05); padding: 20px; border-left: 4px solid var(--c1-gold); border-radius: 6px;">
                            <h5 style="color: var(--c1-gold); font-size: 1.2em; margin: 0 0 12px 0;">
                                Canvas 1: ùîª Unit Disk - Farey Triangle & Prime Distribution
                            </h5>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Mathematical Foundation:</strong> The <strong>Farey sequence</strong> F_n is the ordered set of reduced fractions {p/q : 0 ‚â§ p ‚â§ q ‚â§ n, gcd(p,q) = 1}. These points are mapped to the unit circle at angles Œ∏ = 2œÄp/q, creating a dense set of rational points on ‚àÇùîª.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Key Properties:</strong> The mediant property states that for adjacent fractions p/q, r/s in F_n, their mediant (p+r)/(q+s) first appears in F_{q+s}, and |ps - qr| = 1 (unimodular determinant). The Farey triangle connects these boundary points, with edges representing the SL(2,‚Ñ§) action on ‚Ñö/‚Ñ§.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Prime Distribution:</strong> Primes p are placed at angles 2œÄp/M where M is the modulus. <strong>Dirichlet's theorem</strong> guarantees that primes are equidistributed among residue classes coprime to M, each with asymptotic density 1/œÜ(M). The visualization reveals this equidistribution through uniform angular spacing of prime points in coprime residue classes.
                            </p>
                            <p style="line-height: 1.7;">
                                <strong>Applications:</strong> Farey sequences appear in continued fractions, Ford circles, the Stern-Brocot tree, rational approximation theory, and the geometric study of modular curves.
                            </p>
                        </div>

                        <!-- Canvas 2 -->
                        <div style="background: rgba(26,188,156,0.05); padding: 20px; border-left: 4px solid var(--c2-teal); border-radius: 6px;">
                            <h5 style="color: var(--c2-teal); font-size: 1.2em; margin: 0 0 12px 0;">
                                Canvas 2: ‚Ñç Upper Half-Plane - Cayley Transform & Hyperbolic Geometry
                            </h5>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Cayley Transform:</strong> The map w = i(1+z)/(1-z) is a conformal isomorphism from the Poincar√© disk ùîª to the upper half-plane ‚Ñç = {w ‚àà ‚ÑÇ : Im(w) > 0}. It preserves the hyperbolic metric: ds¬≤_ùîª = 4|dz|¬≤/(1-|z|¬≤)¬≤ corresponds to ds¬≤_‚Ñç = |dw|¬≤/Im(w)¬≤.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Hyperbolic Geodesics:</strong> In ‚Ñç, geodesics are semicircles perpendicular to ‚Ñù (or vertical lines). The hyperbolic distance between z‚ÇÅ, z‚ÇÇ ‚àà ‚Ñç is d_‚Ñç(z‚ÇÅ,z‚ÇÇ) = arcosh(1 + |z‚ÇÅ-z‚ÇÇ|¬≤/(2Im(z‚ÇÅ)Im(z‚ÇÇ))). Geodesics minimize this distance.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Modular Group Action:</strong> PSL(2,‚Ñ§) = SL(2,‚Ñ§)/{¬±I} acts on ‚Ñç by M√∂bius transformations Œ≥¬∑z = (az+b)/(cz+d) where [[a,b],[c,d]] ‚àà SL(2,‚Ñ§). Generated by S(z) = -1/z and T(z) = z+1 with relation (ST)¬≥ = 1. The fundamental domain ùíü = {z : |z| ‚â• 1, |Re(z)| ‚â§ 1/2} tiles ‚Ñç under PSL(2,‚Ñ§).
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Ford Circles:</strong> For rational p/q in lowest terms, the Ford circle has center (p/q, 1/(2q¬≤)) and radius 1/(2q¬≤). Ford circles corresponding to Farey neighbors are tangent (|ps-qr| = 1), providing geometric proof of Farey sequence properties.
                            </p>
                            <p style="line-height: 1.7;">
                                <strong>Applications:</strong> Modular forms, elliptic curves, j-invariant, modular curves, automorphic forms, and connections to the Riemann Hypothesis through the Selberg trace formula.
                            </p>
                        </div>

                        <!-- Canvas 3 -->
                        <div style="background: rgba(52,152,219,0.05); padding: 20px; border-left: 4px solid var(--c3-blue); border-radius: 6px;">
                            <h5 style="color: var(--c3-blue); font-size: 1.2em; margin: 0 0 12px 0;">
                                Canvas 3: ‚äö Nested Modular Rings - Group Structure of (‚Ñ§/m‚Ñ§)√ó
                            </h5>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Group of Units:</strong> For each modulus m, (‚Ñ§/m‚Ñ§)√ó = {k ‚àà ‚Ñ§/m‚Ñ§ : gcd(k,m) = 1} forms a multiplicative group of order œÜ(m). The visualization shows all residue classes 0 ‚â§ k < m on a circle, with coprime elements (units) highlighted.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Euler's Totient:</strong> œÜ(m) = m¬∑‚àè_{p|m}(1 - 1/p) counts units. For prime powers: œÜ(p^k) = p^{k-1}(p-1). Multiplicativity: œÜ(mn) = œÜ(m)œÜ(n) when gcd(m,n) = 1. <strong>Euler's theorem:</strong> If gcd(a,m) = 1, then a^{œÜ(m)} ‚â° 1 (mod m).
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>GCD Structure:</strong> Points are colored by gcd(k,m), revealing subgroup structure. Elements with gcd(k,m) = d correspond to m/d¬∑(‚Ñ§/d‚Ñ§)√ó embedded in ‚Ñ§/m‚Ñ§. The Chinese Remainder Theorem: if gcd(m‚ÇÅ,m‚ÇÇ) = 1, then ‚Ñ§/(m‚ÇÅm‚ÇÇ)‚Ñ§ ‚âÖ ‚Ñ§/m‚ÇÅ‚Ñ§ √ó ‚Ñ§/m‚ÇÇ‚Ñ§, visible in the factorization patterns.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Residue Lifting:</strong> In modular towers M‚Çô = M‚ÇÄ¬∑b^n, a residue r at level n lifts to b residues {r, r+M‚Çô, ..., r+(b-1)M‚Çô} at level n+1. Coprimality is preserved: if gcd(r,M‚ÇÄ) = gcd(r,b) = 1, then all lifts remain coprime to M‚Çô‚Çä‚ÇÅ.
                            </p>
                            <p style="line-height: 1.7;">
                                <strong>Applications:</strong> RSA cryptography (œÜ(pq) = (p-1)(q-1)), Diffie-Hellman key exchange, primitive roots, discrete logarithm problem, quadratic reciprocity, and structure theory of finite abelian groups.
                            </p>
                        </div>

                        <!-- Canvas 4 -->
                        <div style="background: rgba(230,126,34,0.05); padding: 20px; border-left: 4px solid var(--c4-orange); border-radius: 6px;">
                            <h5 style="color: var(--c4-orange); font-size: 1.2em; margin: 0 0 12px 0;">
                                Canvas 4: üîÑ Modular Reduction Projection - Channel Decomposition
                            </h5>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Farey Channel Structure:</strong> Every rational p/q with 0 < p < q can be reduced by its GCD: if d = gcd(p,q), then p/q represents the same angle as (p/d)/(q/d). This reduction maps rationals to their "channels" based on the reduced denominator.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Dyadic Lifting:</strong> Starting from a base modulus M‚ÇÄ, create a geometric sequence M_n = M‚ÇÄ¬∑2^n. A residue r mod M_n lifts to two residues {r, r+M_n} mod M_{n+1}. If gcd(r,M‚ÇÄ) = 1 and r is odd, both lifts remain coprime to all future M_k.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Zero-Residue Alignment:</strong> The 0-residue class (multiples of M‚ÇÄ) creates a "prime-avoiding channel" - no primes lie on this ray. As we lift through the tower, these channels bifurcate while preserving the prime-avoiding property, creating the sieve structure.
                            </p>
                            <p style="line-height: 1.7;">
                                <strong>Applications:</strong> Sieve methods (Eratosthenes, Atkin), gap analysis between primes, twin prime conjecture approaches, and fractal sieve structures.
                            </p>
                        </div>

                        <!-- Canvas 5 -->
                        <div style="background: rgba(155,89,182,0.05); padding: 20px; border-left: 4px solid var(--c5-purple); border-radius: 6px;">
                            <h5 style="color: var(--c5-purple); font-size: 1.2em; margin: 0 0 12px 0;">
                                Canvas 5: ‚ÑÇ Full Complex Plane - Complete Transform View
                            </h5>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Riemann Sphere:</strong> The extended complex plane ‚ÑÇÃÇ = ‚ÑÇ ‚à™ {‚àû} forms a compact Riemann surface (sphere). M√∂bius transformations act as conformal automorphisms of ‚ÑÇÃÇ, forming the group Aut(‚ÑÇÃÇ) ‚âÖ PSL(2,‚ÑÇ).
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Complete Cayley Image:</strong> The full transform shows: |z| < 1 ‚Üí Im(w) > 0 (upper half-plane), |z| = 1 ‚Üí Im(w) = 0 (real axis), |z| > 1 ‚Üí Im(w) < 0 (lower half-plane). The point z = 1 maps to w = ‚àû, and z = -1 is the pole (undefined).
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Circle Preservation:</strong> M√∂bius transformations map generalized circles (circles and lines in ‚ÑÇÃÇ) to generalized circles. This property characterizes M√∂bius transformations among all holomorphic maps.
                            </p>
                            <p style="line-height: 1.7;">
                                <strong>Applications:</strong> Complex analysis, Riemann mapping theorem, uniformization theorem, conformal field theory, string theory, and Teichm√ºller theory.
                            </p>
                        </div>

                        <!-- Canvas 6 -->
                        <div style="background: rgba(233,30,99,0.05); padding: 20px; border-left: 4px solid var(--c6-pink); border-radius: 6px;">
                            <h5 style="color: var(--c6-pink); font-size: 1.2em; margin: 0 0 12px 0;">
                                Canvas 6: ‚öô Primitive Roots - Cyclic Structure of (‚Ñ§/M‚Ñ§)√ó
                            </h5>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Primitive Root Definition:</strong> An element g ‚àà (‚Ñ§/M‚Ñ§)√ó is a <strong>primitive root</strong> if its multiplicative order is œÜ(M), i.e., g^{œÜ(M)} ‚â° 1 (mod M) and g^k ‚â¢ 1 (mod M) for 0 < k < œÜ(M). When primitive roots exist, (‚Ñ§/M‚Ñ§)√ó is cyclic.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Existence Theorem:</strong> Primitive roots exist mod M if and only if M ‚àà {1, 2, 4, p^k, 2p^k} where p is an odd prime. For these moduli, (‚Ñ§/M‚Ñ§)√ó ‚âÖ ‚Ñ§/œÜ(M)‚Ñ§ is cyclic, and there are exactly œÜ(œÜ(M)) primitive roots.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Power Sequence Visualization:</strong> The sequence {g^n mod M : n = 0,1,2,...,œÜ(M)-1} cycles through all units, landing at each exactly once. Points are plotted at angles 2œÄ¬∑g^n/M, creating a spiraling pattern that demonstrates the cyclic group structure.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Order Structure:</strong> By Lagrange's theorem, the order of any element divides œÜ(M). Elements are organized by their orders, with primitive roots having maximal order œÜ(M). The visualization color-codes elements by order.
                            </p>
                            <p style="line-height: 1.7;">
                                <strong>Applications:</strong> Discrete logarithm problem, Diffie-Hellman protocol, index calculus, cyclic codes, pseudorandom number generation, and construction of finite fields.
                            </p>
                        </div>
                    </div>

                    <!-- GROUP 2: COPRIME DENSITY ANALYSIS (Canvases 7-11) -->
                    <h4 style="color: var(--gold); font-size: 1.4em; margin: 40px 0 15px; background: linear-gradient(90deg, rgba(255,215,0,0.2), transparent); padding: 10px; border-left: 4px solid var(--gold);">Group 2: Coprime Density & Statistical Analysis (Canvases 7-11)</h4>

                    <div style="display: grid; grid-template-columns: 1fr; gap: 20px; margin: 20px 0;">
                        <!-- Canvas 7 -->
                        <div style="background: rgba(46,204,113,0.05); padding: 20px; border-left: 4px solid var(--c7-green); border-radius: 6px;">
                            <h5 style="color: var(--c7-green); font-size: 1.2em; margin: 0 0 12px 0;">
                                Canvas 7: üîµ Coprime Circle - Visual Coprimality Patterns
                            </h5>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Coprimality Visualization:</strong> For a given modulus M, all integers 1 ‚â§ k < M are placed on a circle at angles 2œÄk/M. Points are colored green if gcd(k,M) = 1 (coprime) and red otherwise, immediately revealing the density œÜ(M)/M.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Pattern Recognition:</strong> For prime M, all points except M itself are green (œÜ(M) = M-1). For composite M, the pattern reveals prime factors: non-coprime points appear at intervals corresponding to divisors of M. For M = p^k, non-coprime points are spaced every p positions.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Connection Structure:</strong> Optional edges connect coprime pairs, revealing the graph structure of (‚Ñ§/M‚Ñ§)√ó. The complete graph on œÜ(M) vertices shows all unit interactions, with visual clustering indicating subgroup structure.
                            </p>
                            <p style="line-height: 1.7;">
                                <strong>Applications:</strong> Visual verification of coprimality, clock arithmetic, modular multiplication tables, and understanding the structure of cyclic groups.
                            </p>
                        </div>

                        <!-- Canvas 8 -->
                        <div style="background: rgba(241,196,15,0.05); padding: 20px; border-left: 4px solid var(--c8-yellow); border-radius: 6px;">
                            <h5 style="color: var(--c8-yellow); font-size: 1.2em; margin: 0 0 12px 0;">
                                Canvas 8: üìä Phi Ratios Chart - œÜ(n)/n Convergence Behavior
                            </h5>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Totient Density Function:</strong> The ratio œÜ(n)/n represents the probability that a randomly chosen integer k with 1 ‚â§ k ‚â§ n is coprime to n. Using the formula œÜ(n) = n¬∑‚àè_{p|n}(1-1/p), we see this equals ‚àè_{p|n}(1-1/p).
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Prime Values:</strong> For prime p, œÜ(p)/p = (p-1)/p ‚Üí 1 as p ‚Üí ‚àû. These are marked as red dots on the chart, showing that primes have maximum coprime density.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Prime Power Values:</strong> For p^k, œÜ(p^k)/p^k = 1 - 1/p, constant in k. This creates horizontal "shelves" in the chart at heights 1/2 (powers of 2), 2/3 (powers of 3), 4/5 (powers of 5), etc.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Multiplicative Pattern:</strong> For n = ‚àè p_i^{a_i}, we have œÜ(n)/n = ‚àè(1-1/p_i). Highly composite numbers with many small prime factors have low ratios, while primorials have systematically decreasing ratios.
                            </p>
                            <p style="line-height: 1.7;">
                                <strong>Asymptotic Results:</strong> The average value of œÜ(n)/n is asymptotically 6/œÄ¬≤ ‚âà 0.6079 (related to probability of coprimality). The minimum values occur at primorials, approaching 0.
                            </p>
                        </div>

                        <!-- Canvas 9 -->
                        <div style="background: rgba(231,76,60,0.05); padding: 20px; border-left: 4px solid var(--c9-red); border-radius: 6px;">
                            <h5 style="color: var(--c9-red); font-size: 1.2em; margin: 0 0 12px 0;">
                                Canvas 9: üìà Convergence to 6/œÄ¬≤ - Mertens' Third Theorem
                            </h5>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Probability of Coprimality:</strong> For randomly chosen integers a,b ‚â§ N, the probability that gcd(a,b) = 1 is asymptotically 6/œÄ¬≤ ‚âà 0.6079 as N ‚Üí ‚àû. This is equivalent to asking: what fraction of all pairs (a,b) with a,b ‚â§ N are coprime?
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Derivation via Euler Product:</strong> The probability equals ‚àè_p (1-1/p¬≤) where the product is over all primes. This Euler product telescopes to 1/Œ∂(2) = 6/œÄ¬≤, where Œ∂(s) = ‚àë_{n‚â•1} 1/n^s is the Riemann zeta function and Œ∂(2) = œÄ¬≤/6 (Basel problem).
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Visualization Method:</strong> The cumulative count of coprime pairs (a,b) with 1 ‚â§ a < b ‚â§ n is ‚àë_{k=1}^n œÜ(k). The ratio of this count to the total number of pairs n(n-1)/2 converges to 6/œÄ¬≤.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Mertens' Third Theorem:</strong> ‚àë_{n‚â§x} œÜ(n) = (3/œÄ¬≤)x¬≤ + O(x log x). This stronger result shows not just convergence but the precise asymptotic density with error term.
                            </p>
                            <p style="line-height: 1.7;">
                                <strong>Connections:</strong> Related to the probability that a random polynomial over ‚Ñ§ is irreducible, the density of squarefree integers (also 6/œÄ¬≤), and probabilistic number theory.
                            </p>
                        </div>

                        <!-- Canvas 10 -->
                        <div style="background: rgba(99,102,241,0.05); padding: 20px; border-left: 4px solid var(--c10-indigo); border-radius: 6px;">
                            <h5 style="color: var(--c10-indigo); font-size: 1.2em; margin: 0 0 12px 0;">
                                Canvas 10: üéØ Coprime Pairs Grid - GCD Matrix Visualization
                            </h5>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>GCD Matrix:</strong> The grid displays gcd(i,j) for 1 ‚â§ i,j < M as a heatmap. Coprime pairs (gcd = 1) are bright, while pairs with common factors are dimmer. The visual intensity is proportional to 1/gcd(i,j).
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Diagonal Structure:</strong> The main diagonal (i = j) shows gcd(i,i) = i, highlighted in gold. These are the only "self-GCD" values. The matrix is symmetric: gcd(i,j) = gcd(j,i).
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Prime Patterns:</strong> Row/column i corresponding to prime p shows: gcd(i,j) ‚àà {1,p}. The row is bright except at multiples of p, creating a characteristic sparse pattern. Prime powers show similar but denser patterns.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Totient Interpretation:</strong> Each row i has exactly œÜ(i) bright cells (coprime pairs). The total number of bright cells in the matrix equals ‚àë_{i=1}^{M-1} œÜ(i), which asymptotically equals (3/œÄ¬≤)M¬≤.
                            </p>
                            <p style="line-height: 1.7;">
                                <strong>Applications:</strong> Visual GCD computation, verification of coprimality, identification of common divisors, and pattern recognition in number theory. Related to the M√∂bius function and inclusion-exclusion.
                            </p>
                        </div>

                        <!-- Canvas 11 -->
                        <div style="background: rgba(39,174,96,0.05); padding: 20px; border-left: 4px solid var(--c11-lime); border-radius: 6px;">
                            <h5 style="color: var(--c11-lime); font-size: 1.2em; margin: 0 0 12px 0;">
                                Canvas 11: üî¢ Nested Density Rings - Sequential œÜ(n)/n Visualization
                            </h5>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Concentric Ring Structure:</strong> Each ring n (from 2 to M) displays all integers 1 ‚â§ k < n on a circle of radius proportional to n. Coprime points (gcd(k,n) = 1) are shown in lime green, revealing the density œÜ(n)/n geometrically.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Visual Density Comparison:</strong> Ring opacity/brightness is proportional to œÜ(n)/n. Prime rings are almost fully bright (only one missing point). Highly composite rings are dimmer, reflecting lower coprime density. This allows instant visual comparison across moduli.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Radial Alignment:</strong> A vertical ray from center intersects each ring at the point k = ‚åän/2‚åã. Following this ray outward shows how a particular residue class evolves across increasing moduli, demonstrating the lifting structure.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Pattern Recognition:</strong> Composite n with small prime factors show clear "gaps" - empty sectors where all multiples of those primes lie. Prime powers p^k show regular p-fold rotational symmetry in their gap structure.
                            </p>
                            <p style="line-height: 1.7;">
                                <strong>Applications:</strong> Visual verification of coprime density trends, understanding how (‚Ñ§/n‚Ñ§)√ó grows with n, identifying highly composite vs prime moduli, and seeing the self-similar structure of coprimality across scales.
                            </p>
                        </div>
                    </div>

                    <!-- GROUP 3: DIRICHLET CHARACTERS (Canvas 12) -->
                    <h4 style="color: var(--gold); font-size: 1.4em; margin: 40px 0 15px; background: linear-gradient(90deg, rgba(255,215,0,0.2), transparent); padding: 10px; border-left: 4px solid var(--gold);">Group 3: Analytic Number Theory (Canvas 12)</h4>

                    <div style="display: grid; grid-template-columns: 1fr; gap: 20px; margin: 20px 0;">
                        <!-- Canvas 12 -->
                        <div style="background: rgba(156,39,176,0.05); padding: 20px; border-left: 4px solid var(--c12-magenta); border-radius: 6px;">
                            <h5 style="color: var(--c12-magenta); font-size: 1.2em; margin: 0 0 12px 0;">
                                Canvas 12: üåü Dirichlet Characters - Multiplicative Characters & L-Functions
                            </h5>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Dirichlet Character Definition:</strong> A <strong>Dirichlet character</strong> modulo M is a group homomorphism œá: (‚Ñ§/M‚Ñ§)√ó ‚Üí ‚ÑÇ√ó extended to all of ‚Ñ§/M‚Ñ§ by setting œá(n) = 0 if gcd(n,M) > 1. The character is <strong>completely multiplicative</strong>: œá(mn) = œá(m)œá(n) for all m,n.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Principal Character:</strong> The <strong>principal character</strong> œá‚ÇÄ is defined by œá‚ÇÄ(n) = 1 if gcd(n,M) = 1 and œá‚ÇÄ(n) = 0 otherwise. This is the trivial homomorphism on (‚Ñ§/M‚Ñ§)√ó. The visualization shows this character: green points (œá = 1) for coprime n, faded points (œá = 0) for non-coprime n.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Character Group:</strong> The set of all Dirichlet characters mod M forms a group under pointwise multiplication, isomorphic to the dual group (‚Ñ§/M‚Ñ§)^√ó. There are exactly œÜ(M) distinct characters. For cyclic (‚Ñ§/M‚Ñ§)√ó (when primitive roots exist), characters correspond to powers of a primitive root of unity.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Order Coloring:</strong> Points are colored by the multiplicative order of n in (‚Ñ§/M‚Ñ§)√ó. This order equals the smallest positive k such that n^k ‚â° 1 (mod M). For any character œá, we have œá(n)^{ord(n)} = 1, so œá(n) is an ord(n)-th root of unity. The color coding reveals this structure.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Dirichlet L-Function:</strong> For a character œá, the <strong>Dirichlet L-function</strong> is L(s,œá) = ‚àë_{n‚â•1} œá(n)/n^s for Re(s) > 1. This generalizes the Riemann zeta function (L(s,œá‚ÇÄ) = Œ∂(s)‚àè_{p|M}(1-p^{-s})). The Euler product is L(s,œá) = ‚àè_p (1-œá(p)p^{-s})^{-1}.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Orthogonality Relations:</strong> Characters satisfy beautiful orthogonality: ‚àë_{n mod M} œá(n)œàÃÑ(n) = œÜ(M)Œ¥_{œá,œà} (character orthogonality) and ‚àë_œá œá(n)œáÃÑ(m) = œÜ(M)Œ¥_{n,m} (where Œ¥ is 1 if arguments equal, 0 otherwise). These are analogs of Fourier orthogonality.
                            </p>
                            <p style="margin-bottom: 12px; line-height: 1.7;">
                                <strong>Applications to Prime Distribution:</strong> Dirichlet's theorem on primes in arithmetic progressions uses characters: œÄ(x;M,a) ~ x/(œÜ(M)log x) is proved via L(1,œá) ‚â† 0 for non-principal œá. The Generalized Riemann Hypothesis (GRH) concerns zeros of L(s,œá): all non-trivial zeros should satisfy Re(s) = 1/2.
                            </p>
                            <p style="line-height: 1.7;">
                                <strong>Advanced Connections:</strong> Class field theory, Artin L-functions, automorphic forms, Hecke characters, algebraic number theory, Langlands program, and the study of Galois representations.
                            </p>
                        </div>
                    </div>

                    <!-- UNIFYING PRINCIPLES -->
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(0,255,255,0.1)); padding: 25px; border: 3px solid var(--gold); border-radius: 10px; margin: 35px 0;">
                        <h4 style="color: var(--gold); font-size: 1.5em; margin: 0 0 15px 0;">Unifying Mathematical Principles Across All 12 Canvases</h4>
                        <ul style="list-style: none; padding: 0;">
                            <li style="margin-bottom: 15px; padding-left: 20px; border-left: 3px solid var(--cyan);">
                                <strong style="color: var(--cyan);">Modular Arithmetic:</strong> The foundation underlying all visualizations. The structure of ‚Ñ§/M‚Ñ§ and its unit group (‚Ñ§/M‚Ñ§)√ó appears in every canvas, from Farey fractions (canvas 1) to Dirichlet characters (canvas 12).
                            </li>
                            <li style="margin-bottom: 15px; padding-left: 20px; border-left: 3px solid var(--cyan);">
                                <strong style="color: var(--cyan);">Coprimality & œÜ(M):</strong> Euler's totient function connects geometric density (canvases 7,11), statistical limits (canvases 8,9,10), group structure (canvases 3,6), and character theory (canvas 12).
                            </li>
                            <li style="margin-bottom: 15px; padding-left: 20px; border-left: 3px solid var(--cyan);">
                                <strong style="color: var(--cyan);">Conformal Geometry:</strong> Cayley transforms (canvas 2) and M√∂bius transformations (canvas 5) provide the geometric framework connecting hyperbolic geometry to number theory via the modular group PSL(2,‚Ñ§).
                            </li>
                            <li style="margin-bottom: 15px; padding-left: 20px; border-left: 3px solid var(--cyan);">
                                <strong style="color: var(--cyan);">Prime Distribution:</strong> Dirichlet's theorem appears geometrically (canvas 1), through residue classes (canvas 3), via channel decomposition (canvas 4), and analytically via L-functions (canvas 12).
                            </li>
                            <li style="margin-bottom: 15px; padding-left: 20px; border-left: 3px solid var(--cyan);">
                                <strong style="color: var(--cyan);">Group Theory:</strong> The structure of (‚Ñ§/M‚Ñ§)√ó unifies the nested rings (canvas 3), primitive roots (canvas 6), and Dirichlet characters (canvas 12), showing how abstract algebra manifests geometrically.
                            </li>
                            <li style="padding-left: 20px; border-left: 3px solid var(--cyan);">
                                <strong style="color: var(--cyan);">Asymptotic Density:</strong> The limit 6/œÄ¬≤ connects coprime probability (canvas 9), matrix density (canvas 10), and the average behavior of œÜ(n)/n (canvas 8), demonstrating how local arithmetic determines global statistics.
                            </li>
                        </ul>
                    </div>

                    <!-- REFERENCES -->
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; margin-top: 35px; border-radius: 8px;">
                        <h4 style="color: var(--gold); margin: 0 0 15px 0;">Mathematical References & Further Reading</h4>
                        <ul style="font-size: 0.9em; line-height: 1.8; color: rgba(255,255,255,0.8);">
                            <li>Hardy & Wright, "An Introduction to the Theory of Numbers" - Classic reference for number theory fundamentals</li>
                            <li>Ireland & Rosen, "A Classical Introduction to Modern Number Theory" - Comprehensive treatment of algebraic number theory</li>
                            <li>Apostol, "Introduction to Analytic Number Theory" - Dirichlet characters, L-functions, and prime number theorem</li>
                            <li>Silverman, "The Arithmetic of Elliptic Curves" - Connections to modular curves and modular forms</li>
                            <li>Serre, "A Course in Arithmetic" - Modular forms and quadratic forms</li>
                            <li>Needham, "Visual Complex Analysis" - Geometric approach to complex analysis and M√∂bius transformations</li>
                            <li>Anderson & Feil, "A First Course in Abstract Algebra" - Group theory and ring theory foundations</li>
                            <li>Davenport, "Multiplicative Number Theory" - Advanced treatment of Dirichlet series and L-functions</li>
                        </ul>
                    </div>
                </div>r| = 1 (mediant property). The sequence has ‚àë_{k=1}^n œÜ(k) terms, where œÜ is Euler's totient function.
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">Cayley Transform:</strong> The M√∂bius transformation w = i(1-z)/(1+z) providing a conformal equivalence between the Poincar√© disk model (|z| < 1) and the upper half-plane model (Im(w) > 0) of hyperbolic geometry. Its inverse is z = (i-w)/(i+w).
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">Modular Group PSL(2,Z):</strong> The quotient group SL(2,Z)/{¬±I} acting on the upper half-plane via z ‚Üí (az+b)/(cz+d) where ad-bc=1 and a,b,c,d are integers. This group is generated by S: z ‚Üí -1/z and T: z ‚Üí z+1, and is fundamental in the theory of modular forms and elliptic curves.
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">Hyperbolic Geodesics:</strong> In the upper half-plane model, geodesics are either vertical lines or semicircles perpendicular to the real axis. The hyperbolic distance between two points is preserved under PSL(2,Z) actions.
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">Prime Distribution mod m:</strong> Primes p are visualized at angle 2œÄp/m. By Dirichlet's theorem on primes in arithmetic progressions, primes are equidistributed among residue classes coprime to m. The density in each such class approaches 1/œÜ(m) as we consider larger primes.
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">Smith Chart Mapping:</strong> The transformation w = (z-1)/(z+1) used in electrical engineering for impedance visualization. Unlike the Cayley transform, it maps the unit disk to itself, with the real axis of z mapping to the unit circle in w.
                        </li>
                        <li style="margin-bottom: 12px;">
                            <strong style="color: var(--cyan);">M√∂bius Transformations:</strong> General linear fractional transformations w = (az+b)/(cz+d) with ad-bc ‚â† 0. These form a group under composition and are the conformal automorphisms of the Riemann sphere. They map circles and lines to circles and lines.
                        </li>
                    </ul>
                    
                    <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; margin-top: 20px; border-radius: 4px;">
                        <strong style="color: var(--gold);">Getting Started:</strong> Use the preset buttons below to load common configurations. Hover over any control for detailed tooltips. Click the Guide button for an interactive tutorial. Explore the various transform types to see how different conformal mappings affect the geometry.
                    </div>
                </div>
            </div>
        </div>



        <!-- Visualization Canvases -->
        <div class="viz-grid" id="vizGrid">
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title">ùîª Unit Disk</div>
                        <div class="panel-subtitle">Custom Farey Configuration</div>
                    </div>
                    <button class="btn btn-small" onclick="exportSingleCanvas('diskCanvas', 'unit_disk_4k.png')" style="padding: 6px 12px; font-size: 0.85em;">
                        üì• Export 2K
                    </button>
                </div>
                <canvas id="diskCanvas" width="1000" height="1000"></canvas>
            </div>

            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title">‚Ñç Upper Half-Plane</div>
                        <div class="panel-subtitle">Cayley Transform & Geodesics</div>
                    </div>
                    <button class="btn btn-small" onclick="exportSingleCanvas('cayleyCanvas', 'cayley_plane_4k.png')" style="padding: 6px 12px; font-size: 0.85em;">
                        üì• Export 2K
                    </button>
                </div>
                <canvas id="cayleyCanvas" width="1000" height="1000"></canvas>
            </div>

            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title">‚äö Nested Modular Rings</div>
                        <div class="panel-subtitle">Unlimited GCD Structure</div>
                    </div>
                    <button class="btn btn-small" onclick="exportSingleCanvas('nestedCanvas', 'nested_rings_4k.png')" style="padding: 6px 12px; font-size: 0.85em;">
                        üì• Export 2K
                    </button>
                </div>
                <canvas id="nestedCanvas" width="1000" height="1000"></canvas>
            </div>

            <div class="canvas-panel" id="reductionPanel" style="display: none;">
                <div class="panel-header">
                    <div>
                        <div class="panel-title">Modular Reduction Projection</div>
                        <div class="panel-subtitle">Farey Channel Decomposition: r/M ‚Üí r'/M' where M' = M/gcd(r,M)</div>
                    </div>
                    <button class="btn btn-small" onclick="exportSingleCanvas('reductionCanvas', 'modular_reduction_4k.png')" style="padding: 6px 12px; font-size: 0.85em;">
                        üì• Export 2K
                    </button>
                </div>
                <canvas id="reductionCanvas" width="1000" height="1000"></canvas>
            </div>

            <div class="canvas-panel" id="fullPlanePanel" style="display: none;">
                <div class="panel-header">
                    <div>
                        <div class="panel-title">‚ÑÇ Full Complex Plane</div>
                        <div class="panel-subtitle">Complete Cayley Transform View (Interior + Exterior)</div>
                    </div>
                    <button class="btn btn-small" onclick="exportSingleCanvas('fullPlaneCanvas', 'full_plane_4k.png')" style="padding: 6px 12px; font-size: 0.85em;">
                        üì• Export 2K
                    </button>
                </div>
                <canvas id="fullPlaneCanvas" width="1000" height="1000"></canvas>
            </div>

            <div class="canvas-panel" id="primitiveRootsPanel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title" style="color: var(--c6-pink);">6. ‚öô Primitive Roots</div>
                        <div class="panel-subtitle">Power Sequence g^n mod M</div>
                    </div>
                    <button class="btn btn-small" onclick="exportPixiCanvas()" style="padding: 6px 12px; font-size: 0.85em;">
                        üì• Export 2K
                    </button>
                </div>
                <div id="pixiPrimitiveRootsContainer" style="width: 100%; height: 1000px; display: flex; justify-content: center; align-items: center;"></div>
                <canvas id="primitiveRootsCanvas" width="1000" height="1000" style="display: none;"></canvas>
            </div>

            <!-- Canvas 7: Coprime Circle -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title" style="color: var(--c7-green);">7. üîµ Coprime Circle</div>
                        <div class="panel-subtitle">Visual Coprimality Patterns</div>
                    </div>
                    <button class="btn btn-small" onclick="exportCanvas7()" style="padding: 6px 12px; font-size: 0.85em;">
                        üì• Export 2K
                    </button>
                </div>
                <canvas id="canvas7" width="1000" height="1000"></canvas>
            </div>

            <!-- Canvas 8: Phi Ratios Chart -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title" style="color: var(--c8-yellow);">8. üìä Phi Ratios</div>
                        <div class="panel-subtitle">œÜ(n)/n Convergence Chart</div>
                    </div>
                    <button class="btn btn-small" onclick="exportCanvas8()" style="padding: 6px 12px; font-size: 0.85em;">
                        üì• Export 2K
                    </button>
                </div>
                <canvas id="canvas8" width="1000" height="800"></canvas>
            </div>

            <!-- Canvas 9: Convergence to 6/œÄ¬≤ -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title" style="color: var(--c9-red);">9. üìà Convergence</div>
                        <div class="panel-subtitle">Limit to 6/œÄ¬≤ ‚âà 0.6079</div>
                    </div>
                    <button class="btn btn-small" onclick="exportCanvas9()" style="padding: 6px 12px; font-size: 0.85em;">
                        üì• Export 2K
                    </button>
                </div>
                <canvas id="canvas9" width="1000" height="800"></canvas>
            </div>

            <!-- Canvas 10: Coprime Pairs Grid -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title" style="color: var(--c10-indigo);">10. üéØ Coprime Grid</div>
                        <div class="panel-subtitle">GCD Pairs Matrix View</div>
                    </div>
                    <button class="btn btn-small" onclick="exportCanvas10()" style="padding: 6px 12px; font-size: 0.85em;">
                        üì• Export 2K
                    </button>
                </div>
                <canvas id="canvas10" width="1000" height="1000"></canvas>
            </div>

            <!-- Canvas 11: Nested Density Rings -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title" style="color: var(--c11-lime);">11. üî¢ Density Rings</div>
                        <div class="panel-subtitle">Nested 1‚Üín Coprime View</div>
                    </div>
                    <button class="btn btn-small" onclick="exportCanvas11()" style="padding: 6px 12px; font-size: 0.85em;">
                        üì• Export 2K
                    </button>
                </div>
                <canvas id="canvas11" width="1000" height="1000"></canvas>
            </div>

            <!-- Canvas 12: Dirichlet Characters -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title" style="color: var(--c12-magenta);">12. üåü Dirichlet Characters</div>
                        <div class="panel-subtitle">œá(n) mod M Character Visualization</div>
                    </div>
                    <button class="btn btn-small" onclick="exportCanvas12()" style="padding: 6px 12px; font-size: 0.85em;">
                        üì• Export 2K
                    </button>
                </div>
                <canvas id="canvas12" width="1000" height="1000"></canvas>
            </div>
        </div>

        <!-- Statistical Analysis Panel -->
        <div class="controls-section">
            <div class="controls-header" style="cursor: pointer;" onclick="toggleStats()">
                <span id="statsToggle">‚ñº</span> Live Statistical Analysis
            </div>
            <div class="controls-body" id="statsPanel">
                <div id="statsContent" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;"></div>
            </div>
        </div>

        <!-- Advanced Filtering -->
        <div class="controls-section">
            <div class="controls-header" style="cursor: pointer;" onclick="toggleAdvancedFilter()">
                <span id="filterToggle">‚ñ∂</span> Advanced Point Filtering
            </div>
            <div class="controls-body" id="filterPanel" style="display: none;">
                <div class="control-row">
                    <div class="control-item">
                        <div class="control-label">
                            <span>Filter by GCD Value</span>
                        </div>
                        <select id="filterGCD">
                            <option value="">All GCD Values</option>
                            <option value="1">Only GCD = 1 (Coprime)</option>
                            <option value="2">Only GCD = 2</option>
                            <option value="3">Only GCD = 3</option>
                            <option value="5">Only GCD = 5</option>
                        </select>
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>Modulus Range Filter</span>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="number" id="filterModMin" placeholder="Min" value="" style="width: 80px;">
                            <span style="color: var(--text-dim);">to</span>
                            <input type="number" id="filterModMax" placeholder="Max" value="" style="width: 80px;">
                        </div>
                        <div class="help-text">Leave empty for no filter</div>
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>Residue Class Filter</span>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="number" id="filterResClass" placeholder="r" style="width: 80px;">
                            <span style="color: var(--text-dim);">mod</span>
                            <input type="number" id="filterResMod" placeholder="d" style="width: 80px;">
                        </div>
                        <div class="help-text">Show only k ‚â° r (mod d)</div>
                    </div>

                    <div class="control-item">
                        <button class="btn btn-primary" onclick="applyFilters()" style="width: 100%;">
                            <span>Apply Filters</span>
                        </button>
                    </div>

                    <div class="control-item">
                        <button class="btn btn-secondary" onclick="clearFilters()" style="width: 100%;">
                            <span>Clear All Filters</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Animation Controls -->
        <div class="controls-section">
            <div class="controls-header" style="cursor: pointer;" onclick="toggleAnimationPanel()">
                <span id="animToggle">‚ñ∂</span> Animation & Recording
            </div>
            <div class="controls-body" id="animationPanel" style="display: none;">
                <div class="control-row">
                    <div class="control-item">
                        <div class="control-label">
                            <span>Record Which Canvas</span>
                        </div>
                        <select id="recordCanvas">
                            <option value="disk">Unit Disk</option>
                            <option value="cayley">Cayley Plane</option>
                            <option value="nested">Nested Rings</option>
                            <option value="reduction">Modular Reduction</option>
                            <option value="fullplane">Full Plane</option>
                            <option value="all">All 5 Canvases</option>
                        </select>
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>Include Legend in Frames</span>
                        </div>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="recordWithLegend" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: var(--text); font-size: 0.9em;">Export with legend & stats</span>
                        </label>
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>Animation Mode</span>
                        </div>
                        <select id="animationMode">
                            <option value="rotate">Continuous Rotation</option>
                            <option value="zoom">Zoom In/Out</option>
                            <option value="pulse">Pulsing Rings</option>
                            <option value="spiral">Spiral Rotation</option>
                        </select>
                    </div>

                    <div class="control-item" data-tooltip="Controls how fast the visualization rotates when auto-rotate is enabled.">
                        <div class="control-label">
                            <span>Animation Speed</span>
                            <span class="control-value" id="speedValue">1.0√ó</span>
                        </div>
                        <input type="range" id="speedSlider" min="0.1" max="20" value="1" step="0.1">
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>Frame Rate</span>
                            <span class="control-value" id="fpsValue">30 fps</span>
                        </div>
                        <input type="range" id="fpsSlider" min="10" max="60" value="30" step="5">
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>Recording Duration (seconds)</span>
                            <span class="control-value" id="durationValue">5</span>
                        </div>
                        <input type="range" id="durationSlider" min="1" max="30" value="5" step="1">
                    </div>

                    <div class="control-item">
                        <button class="btn btn-primary" onclick="startRecording()" id="recordBtn" style="width: 100%;">
                            <span>Start Recording Frames</span>
                        </button>
                    </div>

                    <div class="control-item" style="grid-column: 1 / -1;">
                        <div id="recordingStatus" style="font-family: 'Fira Code', monospace; font-size: 0.9em; color: var(--cyan); padding: 10px; background: rgba(0,0,0,0.3); border-radius: 4px; display: none;">
                            Recording: <span id="frameCount">0</span> frames captured
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Interactive Guide -->
        <div class="controls-section">
            <div class="controls-header" style="cursor: pointer; user-select: none;" onclick="toggleGuide()">
                <span id="guideToggle">&#9654;</span> Interactive Guide
            </div>
            <div class="controls-body" id="guidePanel" style="display: none;">
                <div style="line-height: 1.8; font-size: 0.95em;">
                    <h3 style="color: var(--gold); margin-bottom: 15px;">Step-by-Step Tutorial</h3>
                    
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; margin-bottom: 20px; border-left: 3px solid var(--gold);">
                        <h4 style="color: var(--gold); margin-bottom: 10px;">Step 1: Understanding the Farey Sequence</h4>
                        <p style="margin-bottom: 10px;">The Farey sequence F_n consists of all reduced fractions between 0 and 1 with denominators not exceeding n, arranged in increasing order.</p>
                        <ul style="margin-left: 20px; margin-bottom: 10px;">
                            <li>F_3 = {0/1, 1/3, 1/2, 2/3, 1/1}</li>
                            <li>F_5 = {0/1, 1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5, 1/1}</li>
                        </ul>
                        <p><strong>Try it:</strong> Click "Generate F_5" button in the Farey Sequence section to see these points on the unit circle.</p>
                    </div>
                    
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; margin-bottom: 20px; border-left: 3px solid var(--cyan);">
                        <h4 style="color: var(--cyan); margin-bottom: 10px;">Step 2: The Cayley Transform</h4>
                        <p style="margin-bottom: 10px;">The standard Cayley transform w = i(1-z)/(1+z) maps the unit disk conformally onto the upper half-plane.</p>
                        <ul style="margin-left: 20px; margin-bottom: 10px;">
                            <li>Points on the unit circle |z|=1 map to the real axis Im(w)=0</li>
                            <li>Interior points |z|&lt;1 map to upper half-plane Im(w)&gt;0</li>
                            <li>The point z=1 maps to infinity</li>
                            <li>The point z=-1 maps to w=0</li>
                        </ul>
                        <p><strong>Try it:</strong> Switch between transform types in the "Cayley Transform & View Options" to see different conformal mappings.</p>
                    </div>
                    
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; margin-bottom: 20px; border-left: 3px solid var(--geodesic);">
                        <h4 style="color: var(--geodesic); margin-bottom: 10px;">Step 3: Prime Distribution</h4>
                        <p style="margin-bottom: 10px;">Primes are positioned at angles 2œÄp/m on the unit circle, where m is the modulus.</p>
                        <ul style="margin-left: 20px; margin-bottom: 10px;">
                            <li>Set modulus m to see primes distributed in residue classes</li>
                            <li>Enable "Residue Channels" to color primes by their class mod m</li>
                            <li>Only primes coprime to m are shown when channels are enabled</li>
                        </ul>
                        <p><strong>Try it:</strong> Set modulus to 12, enable "Residue Channels" toggle, and observe how primes cluster in coprime classes.</p>
                    </div>
                    
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; margin-bottom: 20px; border-left: 3px solid var(--cusp);">
                        <h4 style="color: var(--cusp); margin-bottom: 10px;">Step 4: Nested Ring Structure</h4>
                        <p style="margin-bottom: 10px;">Concentric rings show the structure of (Z/mZ)√ó for each modulus m from min to max.</p>
                        <ul style="margin-left: 20px; margin-bottom: 10px;">
                            <li>Points are colored by gcd(k,m) where k is the residue</li>
                            <li>Gold points have gcd(k,m)=1 (units in Z/mZ)</li>
                            <li>The number of gold points on ring m equals œÜ(m)</li>
                        </ul>
                        <p><strong>Try it:</strong> Set min ring to 1, max ring to 20, and enable "GCD Coloring" to see totient structure.</p>
                    </div>
                    
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; margin-bottom: 20px; border-left: 3px solid var(--prime);">
                        <h4 style="color: var(--prime); margin-bottom: 10px;">Step 5: Geodesics and Hyperbolic Geometry</h4>
                        <p style="margin-bottom: 10px;">In the upper half-plane, hyperbolic geodesics appear as semicircles perpendicular to the real axis.</p>
                        <ul style="margin-left: 20px; margin-bottom: 10px;">
                            <li>Geodesics connect Farey points on the boundary</li>
                            <li>These are the "straight lines" of hyperbolic geometry</li>
                            <li>The modular group PSL(2,Z) acts by isometries</li>
                        </ul>
                        <p><strong>Try it:</strong> Enable "Geodesic Arc" to see hyperbolic lines connecting Farey fractions.</p>
                    </div>
                    
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; margin-bottom: 20px; border-left: 3px solid var(--prime);">
                        <h4 style="color: var(--prime); margin-bottom: 10px;">Step 5: Generalized Lift Dynamics</h4>
                        <p style="margin-bottom: 10px;">For modular sequences M‚ÇÄ, M‚ÇÅ, M‚ÇÇ,... where M‚Çô = M‚ÇÄ¬∑b‚Åø (b ‚â• 2 is the scaling factor):</p>
                        <ul style="margin-left: 20px; margin-bottom: 10px;">
                            <li><strong>Residue Lift:</strong> Lift(n‚Üín+1)(r) = {r + k¬∑M‚Çô mod M‚Çô‚Çä‚ÇÅ : k=0,1,...,b-1}</li>
                            <li><strong>Transition Lift:</strong> Gap-g pair (r, r+g) lifts to {(r+kM‚Çô, r+g+kM‚Çô) : k=0,...,b-1}</li>
                            <li><strong>Coprimality:</strong> If gcd(r, M‚Çô) = 1 and gcd(r, b) = 1, then gcd(r, M‚Çô‚Çä‚ÇÅ) = 1</li>
                            <li><strong>Counting:</strong> If each element lifts to b valid elements: |S‚Çô‚Çä‚ÇÅ| = b¬∑|S‚Çô|</li>
                        </ul>
                        <p><strong>Try it:</strong> Use "Gap-2n" connection mode to visualize gap-preserving lifts where r connects to r+gap within each ring.</p>
                    </div>
                    
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; margin-bottom: 20px; border-left: 3px solid var(--cusp);">
                        <h4 style="color: var(--cusp); margin-bottom: 10px;">Mathematical Framework</h4>
                        <p style="margin-bottom: 10px;"><strong>Base Modulus M‚ÇÄ ‚àà ‚Ñ§‚Çä</strong> and scaling factor <strong>b ‚àà ‚Ñ§‚â•‚ÇÇ</strong></p>
                        <p style="margin-bottom: 10px;"><strong>Modulus Sequence:</strong> M‚Çô = M‚ÇÄ¬∑b‚Åø for n ‚àà ‚Ñ§‚â•‚ÇÄ</p>
                        <p style="margin-bottom: 10px;"><strong>Residue Lift Formula:</strong></p>
                        <div style="font-family: 'Fira Code', monospace; background: rgba(0,0,0,0.4); padding: 10px; margin: 10px 0; border-radius: 4px;">
                            Lift_{n‚Üín+1}(r) = {r, r+M‚Çô, r+2M‚Çô, ..., r+(b-1)M‚Çô} mod M‚Çô‚Çä‚ÇÅ
                        </div>
                        <p style="margin-bottom: 10px;"><strong>GCD Preservation Condition:</strong></p>
                        <div style="font-family: 'Fira Code', monospace; background: rgba(0,0,0,0.4); padding: 10px; margin: 10px 0; border-radius: 4px;">
                            gcd(r, M‚Çô) = 1 ‚àß gcd(r, b) = 1  ‚üπ  gcd(r, M‚Çô‚Çä‚ÇÅ) = 1
                        </div>
                        <p style="margin-bottom: 10px;"><strong>Self-Similarity:</strong> When PrimeFactors(b) ‚äÜ PrimeFactors(M‚ÇÄ), coprimality is automatically preserved across lifts.</p>
                        <p style="margin-bottom: 10px;"><strong>Transition Counting:</strong> For valid transitions T(M‚Çô), if each lifts to b valid transitions: T(M‚Çô‚Çä‚ÇÅ) = b¬∑T(M‚Çô)</p>
                    </div>
                    
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; border-left: 3px solid var(--text);">
                        <h4 style="color: var(--text); margin-bottom: 10px;">Advanced: Ford Circles & Gap Connections</h4>
                        <p style="margin-bottom: 10px;">Experiment with general M√∂bius transformations w = (az+b)/(cz+d).</p>
                        <ul style="margin-left: 20px; margin-bottom: 10px;">
                            <li>Select "M√∂bius" transform type to reveal parameter controls</li>
                            <li>Ensure ad-bc ‚â† 0 for a valid transformation</li>
                            <li>Common choices: (a,b,c,d) = (1,1,1,0) gives w=(z+1)/z</li>
                            <li>Try (0,-1,1,0) for w=-1/z (inversion)</li>
                        </ul>
                        <p><strong>Mathematical note:</strong> M√∂bius transformations form a group isomorphic to PSL(2,C), the group of conformal automorphisms of the Riemann sphere.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Advanced Controls -->
        <div class="controls-section">
            <div class="controls-header">
                Unlimited Parameter Control
            </div>
            
            <!-- Canvas Color Legend -->
            <div style="padding: 15px; background: rgba(10, 14, 39, 0.8); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 8px; margin: 15px 15px 0 15px;">
                <div style="font-family: 'Fira Code', monospace; font-size: 0.9em; font-weight: bold; color: #00ffff; margin-bottom: 10px; text-align: center;">
                    CANVAS COLOR LEGEND
                </div>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; font-family: 'Fira Code', monospace; font-size: 0.75em;">
                    <div style="color: #ffd700; display: flex; align-items: center;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #ffd700; border-radius: 2px; margin-right: 6px;"></span>
                        ùîª Unit Disk
                    </div>
                    <div style="color: #1abc9c; display: flex; align-items: center;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #1abc9c; border-radius: 2px; margin-right: 6px;"></span>
                        ‚Ñç Cayley Plane
                    </div>
                    <div style="color: #3498db; display: flex; align-items: center;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #3498db; border-radius: 2px; margin-right: 6px;"></span>
                        ‚äö Nested Rings
                    </div>
                    <div style="color: #e67e22; display: flex; align-items: center;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #e67e22; border-radius: 2px; margin-right: 6px;"></span>
                        üîÑ Reduction
                    </div>
                    <div style="color: #9b59b6; display: flex; align-items: center;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #9b59b6; border-radius: 2px; margin-right: 6px;"></span>
                        ‚ÑÇ Full Plane
                    </div>
                    <div style="color: #e91e63; display: flex; align-items: center;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #e91e63; border-radius: 2px; margin-right: 6px;"></span>
                        ‚öô Primitive Roots
                    </div>
                </div>
                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255, 255, 255, 0.1); color: #888; font-size: 0.7em; text-align: center;">
                    Controls are color-coded to show which canvas they affect
                </div>
            </div>
            
            <div class="controls-body">
                <!-- Basic Parameters -->
                <div class="section-header canvas-global">Basic Parameters</div>
                
                <!-- Angular Layout Mode -->
                <div class="control-row">
                    <div class="control-item" data-tooltip="Choose how residues are positioned on circles: by angle (natural fractions) or by sequential order (1, 2, 3, ...)">
                        <div class="control-label">
                            <span>Angular Layout Mode</span>
                        </div>
                        <select id="angularLayoutMode" onchange="updateAngularLayoutMode(this.value)" style="width: 100%; padding: 8px; margin-top: 8px; background: var(--bg-mid); color: var(--text); border: 1px solid var(--border); border-radius: 4px; font-family: 'Fira Code', monospace;">
                            <option value="fractional">Fractional: Œ∏ = 2œÄk/m (Natural Angles)</option>
                            <option value="sequential">Sequential: Order by Index (1‚Üí2‚Üí3‚Üí...‚Üím)</option>
                        </select>
                        <div class="help-text" id="layoutModeHelp">Fractional mode uses natural angular positions based on k/m</div>
                    </div>
                </div>
                
                <div class="control-row">
                    <div class="control-item" data-tooltip="Rotates all visualizations by this angle. Animated when auto-rotate is enabled.">
                        <div class="control-label">
                            <span>Phase Rotation Œ∏</span>
                            <span class="control-value" id="phaseValue">0¬∞</span>
                        </div>
                        <input type="range" id="phaseSlider" min="0" max="360" value="0" step="0.1">
                        <input type="number" id="phaseInput" value="0" min="0" max="360" step="0.00000000000000001" style="margin-top: 8px;" placeholder="Enter angle in degrees (17 decimal precision)">
                        
                        <!-- Angle Presets Dropdown -->
                        <div style="margin-top: 8px;">
                            <label style="font-size: 0.85em; color: #8b949e; display: block; margin-bottom: 4px;">Famous Angle Presets</label>
                            <select id="anglePresets" onchange="applyAnglePreset(this.value)" style="width: 100%; padding: 6px; background: #0d1117; border: 1px solid #30363d; border-radius: 4px; color: #c9d1d9; font-size: 0.9em;">
                                <option value="">-- Select Preset --</option>
                                <option value="0">0¬∞ (Origin)</option>
                                <option value="30">30¬∞ (Standard)</option>
                                <option value="45">45¬∞ (Diagonal)</option>
                                <option value="60">60¬∞ (Hexagonal)</option>
                                <option value="90">90¬∞ (Quadrant)</option>
                                <option value="120">120¬∞ (Trisection)</option>
                                <option value="137.50776405003785">137.508¬∞ (Golden Angle œÜ)</option>
                                <option value="180">180¬∞ (Half Turn)</option>
                                <option value="222.49223594996215">222.492¬∞ (Conjugate Golden)</option>
                                <option value="270">270¬∞ (Three-Quarter)</option>
                                <option value="360">360¬∞ (Full Circle)</option>
                                <option value="51.82729237329962">51.827¬∞ (Fibonacci Spiral)</option>
                                <option value="26.56505117707799">26.565¬∞ (Silver Angle)</option>
                            </select>
                        </div>
                        
                        <!-- Phase Animation Controls -->
                        <div style="display: flex; gap: 8px; margin-top: 12px; align-items: center;">
                            <button class="btn btn-primary" onclick="togglePhaseAnimation()" id="phaseAnimateBtn" style="flex: 1; padding: 8px;">
                                <span>‚ñ∂ Animate 360¬∞</span>
                            </button>
                            <label style="display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 0.85em; white-space: nowrap;">
                                <input type="checkbox" id="phaseLoopCheck" checked style="width: 14px; height: 14px; cursor: pointer;">
                                <span>Loop</span>
                            </label>
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center; margin-top: 8px;">
                            <span style="font-size: 0.85em; color: var(--text); opacity: 0.8; min-width: 50px;">Speed:</span>
                            <input type="range" id="phaseSpeedSlider" min="0.1" max="5" value="1" step="0.1" style="flex: 1;">
                            <span id="phaseSpeedValue" style="font-size: 0.85em; color: var(--cyan); min-width: 35px;">1.0x</span>
                        </div>
                    </div>

                    <div class="control-item" data-tooltip="The modulus for residue classes. Farey points shown have denominators that divide m. Example: m=6 shows fractions with denominators 1,2,3,6">
                        <div class="control-label">
                            <span>Modulus m (Any Integer)</span>
                            <span class="control-value" id="modulusDisplay">101</span>
                        </div>
                        <input type="number" id="modulusInput" value="101" min="1" step="1">
                        <div class="help-text" id="modulusHelp">Farey: denominators divide m (no upper limit)</div>
                    </div>
                </div>

                <!-- Canvas Zoom Controls -->
                <div class="section-header canvas-global">Canvas Zoom Controls</div>
                <div class="control-row">
                    <div class="control-item">
                        <div class="control-label">
                            <span>Unit Disk Zoom</span>
                            <span class="control-value" id="diskZoomValue">100%</span>
                        </div>
                        <input type="range" id="diskZoomSlider" min="50" max="300" value="100" step="5">
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>Upper Half-Plane Zoom</span>
                            <span class="control-value" id="cayleyZoomValue">100%</span>
                        </div>
                        <input type="range" id="cayleyZoomSlider" min="50" max="300" value="100" step="5">
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>Nested Rings Zoom</span>
                            <span class="control-value" id="nestedZoomValue">100%</span>
                        </div>
                        <input type="range" id="nestedZoomSlider" min="50" max="300" value="100" step="5">
                    </div>
                </div>

                <div class="control-row">
                    <div class="control-item">
                        <div class="control-label">
                            <span>Modular Reduction Zoom</span>
                            <span class="control-value" id="reductionZoomValue">100%</span>
                        </div>
                        <input type="range" id="reductionZoomSlider" min="50" max="300" value="100" step="5">
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>Full Complex Plane Zoom</span>
                            <span class="control-value" id="fullPlaneZoomValue">100%</span>
                        </div>
                        <input type="range" id="fullPlaneZoomSlider" min="50" max="300" value="100" step="5">
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>Primitive Roots Zoom</span>
                            <span class="control-value" id="primitiveZoomValue">100%</span>
                        </div>
                        <input type="range" id="primitiveZoomSlider" min="50" max="300" value="100" step="5">
                    </div>
                </div>

                <div class="control-row">
                    <div class="control-item">
                        <button class="btn btn-primary" onclick="resetAllZoom()" style="width: 100%;">
                            <span>Reset All Zoom to 100%</span>
                        </button>
                    </div>
                    <div class="control-item">
                        <div class="control-label">
                            <span>Master Zoom (All Canvases)</span>
                            <span class="control-value" id="masterZoomValue">100%</span>
                        </div>
                        <input type="range" id="masterZoomSlider" min="50" max="300" value="100" step="5">
                    </div>
                </div>

                <div class="control-row">
                    <div class="control-item" data-tooltip="Quick presets for per-ring rotation to align specific fractions to top (90¬∞)">
                        <div class="control-label">
                            <span>Per-Ring Rotation Presets</span>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 8px;">
                            <!-- k/d preset -->
                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                <button class="btn btn-secondary" onclick="setRingRotationPreset('k/d')" style="padding: 8px 12px; height: 60px;">
                                    <span id="kdPresetLabel" style="font-size: 1.1em;">1/2</span>
                                    <div style="font-size: 0.7em; opacity: 0.7; margin-top: 4px;">Custom</div>
                                </button>
                                <div style="display: flex; gap: 4px; align-items: center;">
                                    <input type="number" id="kdNumerator" value="1" min="0" step="1" placeholder="k" style="width: 45%; padding: 4px; text-align: center; font-size: 0.85em;" onchange="updatePresetLabel('k/d')">
                                    <span style="color: var(--text); font-weight: bold;">/</span>
                                    <input type="number" id="kdDenominator" value="2" min="1" step="1" placeholder="d" style="width: 45%; padding: 4px; text-align: center; font-size: 0.85em;" onchange="updatePresetLabel('k/d')">
                                </div>
                            </div>
                            <!-- n/n preset -->
                            <button class="btn btn-secondary" onclick="setRingRotationPreset('0')" style="padding: 8px 12px;">
                                <span style="font-size: 1.1em;">0/n</span>
                                <div style="font-size: 0.7em; opacity: 0.7; margin-top: 4px;">Zero</div>
                            </button>
                            <!-- Animate button -->
                            <button class="btn btn-primary" onclick="animateRotationPresets()" id="rotationAnimateBtn" style="padding: 8px 12px;">
                                <span>‚ñ∂ Animate</span>
                                <div style="font-size: 0.7em; opacity: 0.9; margin-top: 4px;">Cycle</div>
                            </button>
                        </div>
                        <label style="display: flex; align-items: center; gap: 8px; margin-top: 8px; cursor: pointer;">
                            <input type="checkbox" id="applyPresetsToAllCanvas" style="width: 16px; height: 16px; cursor: pointer;">
                            <span style="color: var(--text); font-size: 0.9em;">Also apply to Phase Rotation (all canvases)</span>
                        </label>
                        <div class="help-text">Sets per-ring rotation: k/d √ó 360¬∞ (e.g., 1/2 = 180¬∞, 1/4 = 90¬∞, 2/3 = 240¬∞). Check box above to also set Phase.</div>
                    </div>
                </div>

                <!-- Nested Rings Quick Controls -->
                <div class="control-row">
                    <div class="control-item" data-tooltip="Starting modulus for the innermost ring">
                        <div class="control-label">
                            <span>Min Ring (m_start)</span>
                            <span class="control-value" id="minRingDisplay2">1</span>
                        </div>
                        <input type="number" id="minRingInput2" value="1" min="1" step="1" onchange="syncMinRing(this.value)">
                    </div>

                    <div class="control-item" data-tooltip="Ending modulus for the outermost ring">
                        <div class="control-label">
                            <span>Max Ring (m_end)</span>
                            <span class="control-value" id="maxRingDisplay2">12</span>
                        </div>
                        <input type="number" id="maxRingInput2" value="12" min="1" step="1" onchange="syncMaxRing(this.value)">
                        <div class="help-text">Unlimited - 100+ rings possible</div>
                    </div>
                </div>

                <div class="control-row">
                    <div class="control-item" data-tooltip="Controls how spread out the rings are">
                        <div class="control-label">
                            <span>Ring Spacing Factor</span>
                            <span class="control-value" id="spacingValue2">1.0</span>
                        </div>
                        <input type="range" id="spacingSlider2" min="0.1" max="5" value="1" step="0.1" oninput="syncSpacing(this.value)">
                    </div>

                    <div class="control-item" data-tooltip="Rotate each individual ring by this angle">
                        <div class="control-label">
                            <span>Per-Ring Rotation</span>
                            <span class="control-value" id="ringRotationValue2">0¬∞</span>
                        </div>
                        <input type="range" id="ringRotationSlider2" min="0" max="360" value="0" step="0.01" oninput="syncRingRotation(this.value)">
                        <input type="number" id="ringRotationInput2" value="0" min="0" max="3600" step="0.0000000000000001" style="margin-top: 8px;" placeholder="Degrees per ring" onchange="syncRingRotation(this.value)">
                    </div>
                </div>

                <!-- Nested Rings Display Mode -->
                <div class="section-header canvas-nested">Nested Rings Display Mode</div>
                <div class="control-row">
                    <div class="control-item" data-tooltip="Choose how to display the nested rings">
                        <div class="control-label">
                            <span>Display Mode</span>
                        </div>
                        <select id="nestedDisplayMode" onchange="updateNestedMode()" style="width: 100%; padding: 8px; margin-top: 8px; background: var(--bg-mid); color: var(--text); border: 1px solid var(--border); border-radius: 4px;">
                            <option value="range">Ring Range (Min to Max)</option>
                            <option value="sequential">Sequential 1 to N</option>
                        </select>
                    </div>
                </div>

                <div id="sequentialControls" style="display: none;">
                    <div class="control-row">
                        <div class="control-item" data-tooltip="Angular mapping formula for positioning points">
                            <div class="control-label">
                                <span>Angular Mapping</span>
                            </div>
                            <select id="angularMapping" onchange="drawNested()" style="width: 100%; padding: 8px; margin-top: 8px; background: var(--bg-mid); color: var(--text); border: 1px solid var(--border); border-radius: 4px;">
                                <option value="standard">Standard: Œ∏ = 2œÄr/m</option>
                                <option value="reverse">Reverse: Œ∏ = -2œÄr/m</option>
                                <option value="complement">Complement: Œ∏ = 2œÄ(m-r)/m</option>
                                <option value="rotated">Rotated: Œ∏ = 2œÄr/m - œÄ/2</option>
                            </select>
                        </div>
                    </div>

                    <div class="control-row">
                        <div class="control-item" data-tooltip="Show GCD-based colors">
                            <div class="control-label">
                                <span>Color by GCD</span>
                            </div>
                            <label class="toggle-label" style="margin-top: 8px;">
                                <input type="checkbox" id="colorByGCD" checked onchange="drawNested()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="control-item" data-tooltip="Show connections from center to coprime points">
                            <div class="control-label">
                                <span>Show Coprime Connections</span>
                            </div>
                            <label class="toggle-label" style="margin-top: 8px;">
                                <input type="checkbox" id="showCoprimeConnections" onchange="drawNested()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>

                <!-- Primitive Roots Generator -->
                <div class="section-header canvas-primitive">Primitive Roots & Generator</div>
                <div class="control-row">
                    <div class="control-item" data-tooltip="Select generator g for the power sequence. Auto-finds smallest primitive root if one exists.">
                        <div class="control-label">
                            <span>Generator g</span>
                            <span class="control-value" id="generatorValue">3</span>
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 8px;">
                            <button class="btn btn-secondary" onclick="findSmallestPrimitiveRoot()" style="flex: 1;">
                                <span>Find Smallest Primitive Root</span>
                            </button>
                            <button class="btn btn-secondary" onclick="showAllPrimitiveRoots()" style="flex: 1;">
                                <span>Show All Generators</span>
                            </button>
                        </div>
                        <input type="number" id="generatorInput" value="3" min="1" step="1" style="margin-top: 8px;" placeholder="Enter generator g" onchange="updateGenerator(this.value)">
                        <div class="help-text" id="generatorHelp">g=3 for M=101 (smallest primitive root)</div>
                    </div>
                </div>

                <!-- Order Selection Dropdown -->
                <div class="control-row">
                    <div class="control-item" data-tooltip="Browse all coprime elements by their order. Shows complete group structure.">
                        <div class="control-label">
                            <span>Select Element by Order</span>
                        </div>
                        <button class="btn btn-secondary" onclick="showOrderTable()" style="width: 100%; margin-top: 8px;">
                            <span>üìä Show Order Table for M=<span id="orderTableModulus">101</span></span>
                        </button>
                        <select id="orderElementSelect" style="width: 100%; padding: 8px; margin-top: 8px; background: var(--bg-mid); color: var(--text); border: 1px solid var(--border); border-radius: 4px; font-family: 'Fira Code', monospace; font-size: 0.9em;" onchange="selectElementFromOrder(this.value)">
                            <option value="">-- Select element by order --</option>
                        </select>
                        <div class="help-text" id="orderSelectHelp">Dropdown shows: element (order)</div>
                    </div>
                </div>

                <!-- Global Line Thickness -->
                <div class="section-header canvas-global">Global Line Thickness</div>
                <div class="control-row">
                    <div class="control-item" data-tooltip="Control line thickness globally for all visualizations. Lower values create sharper, cleaner lines for large moduli.">
                        <div class="control-label">
                            <span>Line Thickness (All Canvases)</span>
                            <span class="control-value" id="globalLineThicknessValue">1.00</span>
                        </div>
                        <input type="range" id="globalLineThickness" min="0.1" max="5.0" value="1.0" step="0.05" oninput="updateGlobalLineThickness(this.value)">
                    </div>
                </div>

                <!-- Zoom Controls -->
                <div class="section-header">Canvas Zoom Controls</div>
                <div class="control-row">
                    <div class="control-item" data-tooltip="Zoom in or out on the Unit Disk visualization. 1.0 = default view.">
                        <div class="control-label">
                            <span>Unit Disk Zoom</span>
                            <span class="control-value" id="diskZoomValue">1.00√ó</span>
                        </div>
                        <input type="range" id="diskZoomSlider" min="0.1" max="5" value="1" step="0.05">
                    </div>

                    <div class="control-item" data-tooltip="Zoom in or out on the Cayley/Upper Half-Plane view. 1.0 = default view.">
                        <div class="control-label">
                            <span>Cayley Plane Zoom</span>
                            <span class="control-value" id="cayleyZoomValue">1.00√ó</span>
                        </div>
                        <input type="range" id="cayleyZoomSlider" min="0.1" max="5" value="1" step="0.05">
                    </div>

                    <div class="control-item" data-tooltip="Zoom in or out on the Nested Rings visualization. 1.0 = default view.">
                        <div class="control-label">
                            <span>Nested Rings Zoom</span>
                            <span class="control-value" id="nestedZoomValue">1.00√ó</span>
                        </div>
                        <input type="range" id="nestedZoomSlider" min="0.1" max="5" value="1" step="0.05">
                    </div>
                </div>

                <!-- Cayley View Controls -->
                <div class="section-header canvas-cayley">Cayley Transform & View Options</div>
                <div class="control-row">
                    <div class="control-item" style="grid-column: 1 / -1;" data-tooltip="Choose which mathematical transformation to apply">
                        <div class="control-label">
                            <span>Transform Type</span>
                        </div>
                        <select id="cayleyTransformType">
                            <option value="standard">Standard Cayley: w = i(1+z)/(1-z)</option>
                            <option value="alternate">Inverse Cayley: w = i(1-z)/(1+z)</option>
                            <option value="ftt">FTT Transform: w = (z-i)/(z+i)</option>
                            <option value="smith">Smith Chart: (z-1)/(z+1)</option>
                            <option value="mobius">M√∂bius: (az+b)/(cz+d)</option>
                        </select>
                        <div class="help-text" id="transformDescription">Standard Cayley: Disk‚ÜíUpper Half-Plane | Inverse: Different orientation | FTT: Upper Half-Plane‚ÜíDisk | Smith: Disk‚ÜíDisk (RF) | M√∂bius: Fully customizable</div>
                    </div>
                    
                    <div class="control-item" id="mobiusParamsA" style="display: none;" data-tooltip="Coefficient a in M√∂bius transformation w=(az+b)/(cz+d). Must satisfy ad-bc not equal to zero for invertibility.">
                        <div class="control-label">
                            <span>M√∂bius coefficient a</span>
                        </div>
                        <input type="number" id="mobiusA" value="1" step="1">
                    </div>
                    
                    <div class="control-item" id="mobiusParamsB" style="display: none;" data-tooltip="Coefficient b in M√∂bius transformation w=(az+b)/(cz+d). Represents translation component in numerator.">
                        <div class="control-label">
                            <span>M√∂bius coefficient b</span>
                        </div>
                        <input type="number" id="mobiusB" value="0" step="1">
                    </div>
                    
                    <div class="control-item" id="mobiusParamsC" style="display: none;" data-tooltip="Coefficient c in M√∂bius transformation w=(az+b)/(cz+d). When c=0, transformation reduces to affine map.">
                        <div class="control-label">
                            <span>M√∂bius coefficient c</span>
                        </div>
                        <input type="number" id="mobiusC" value="0" step="1">
                    </div>
                    
                    <div class="control-item" id="mobiusParamsD" style="display: none;" data-tooltip="Coefficient d in M√∂bius transformation w=(az+b)/(cz+d). Determinant ad-bc must be nonzero.">
                        <div class="control-label">
                            <span>M√∂bius coefficient d</span>
                        </div>
                        <input type="number" id="mobiusD" value="1" step="1">
                        <div class="help-text">Constraint: determinant ad - bc must be nonzero</div>
                    </div>
                </div>

                <div class="section-header canvas-cayley">Cayley Plane View Range</div>
                <div class="control-row">
                    
                    <div class="control-item" data-tooltip="Width of the visible window in the upper half-plane. Increase to see more of the real axis.">
                        <div class="control-label">
                            <span>Horizontal Range (Re)</span>
                            <span class="control-value" id="cayleyHRangeValue">6.0</span>
                        </div>
                        <input type="range" id="cayleyHRangeSlider" min="2" max="20" value="6" step="0.5">
                        <div class="help-text">Width of visible area in ‚Ñç</div>
                    </div>

                    <div class="control-item" data-tooltip="Height of the visible window. Increase to see more of the upper half-plane.">
                        <div class="control-label">
                            <span>Vertical Range (Im)</span>
                            <span class="control-value" id="cayleyVRangeValue">4.0</span>
                        </div>
                        <input type="range" id="cayleyVRangeSlider" min="1" max="15" value="4" step="0.5">
                        <div class="help-text">Height of visible area in ‚Ñç</div>
                    </div>

                    <div class="control-item" data-tooltip="Shifts the viewing window up or down. Useful for focusing on different regions.">
                        <div class="control-label">
                            <span>Vertical Offset</span>
                            <span class="control-value" id="cayleyVOffsetValue">0.0</span>
                        </div>
                        <input type="range" id="cayleyVOffsetSlider" min="-5" max="5" value="0" step="0.1">
                        <div class="help-text">Shift view up/down</div>
                    </div>

                    <div class="control-item" data-tooltip="Controls spacing between grid lines. Lower values = more grid lines.">
                        <div class="control-label">
                            <span>Grid Density</span>
                            <span class="control-value" id="cayleyGridDensityValue">1.0</span>
                        </div>
                        <input type="range" id="cayleyGridDensitySlider" min="0.5" max="3" value="1" step="0.1">
                        <div class="help-text">Grid line spacing</div>
                    </div>
                </div>

                <!-- Prime Distribution -->
                <div class="section-header canvas-disk">Prime Distribution</div>
                <div class="control-row">
                    <div class="control-item" data-tooltip="How many prime numbers to display. More primes = denser visualization but slower rendering.">
                        <div class="control-label">
                            <span>Number of Primes</span>
                            <span class="control-value" id="primesDisplay">150</span>
                        </div>
                        <input type="number" id="primesInput" value="150" min="0" step="10">
                        <div class="help-text">No limit - computation may slow with >5000</div>
                    </div>

                    <div class="control-item" data-tooltip="Generate all primes up to this value using the Sieve of Eratosthenes.">
                        <div class="control-label">
                            <span>Prime Upper Limit</span>
                            <span class="control-value" id="primeLimitDisplay">10000</span>
                        </div>
                        <input type="number" id="primeLimitInput" value="10000" min="100" step="100">
                        <div class="help-text">Generate primes up to this value</div>
                    </div>
                </div>

                <!-- Nested Rings Parameters -->
                <div class="section-header canvas-nested">Nested Rings Configuration</div>
                <div class="control-row">
                    <div class="control-item" style="grid-column: 1 / -1;" data-tooltip="Choose how ring moduli are generated">
                        <div class="control-label">
                            <span>Ring Generation Mode</span>
                        </div>
                        <select id="ringGenerationMode">
                            <option value="manual">Manual Range</option>
                            <option value="dyadic">Dyadic (M‚ÇÄ√ó2‚Åø)</option>
                            <option value="padic">p-adic (M‚ÇÄ√óp‚Åø)</option>
                            <option value="custom">Custom (M‚ÇÄ√ób‚Åø)</option>
                            <option value="customlist">Custom Moduli List</option>
                        </select>
                        <div class="help-text">Choose "Custom Moduli List" to specify any arbitrary sequence</div>
                    </div>
                </div>

                <div id="manualRingControls" class="control-row">
                    <div class="control-item" data-tooltip="Starting modulus for the innermost ring. Usually 1 or 2.">
                        <div class="control-label">
                            <span>Min Ring (m_start)</span>
                            <span class="control-value" id="minRingDisplay">1</span>
                        </div>
                        <input type="number" id="minRingInput" value="1" min="1" step="1">
                    </div>

                    <div class="control-item" data-tooltip="Ending modulus for the outermost ring. No limit - try 50+ for impressive patterns!">
                        <div class="control-label">
                            <span>Max Ring (m_end)</span>
                            <span class="control-value" id="maxRingDisplay">101</span>
                        </div>
                        <input type="number" id="maxRingInput" value="101" min="1" step="1">
                        <div class="help-text">Unlimited - 100+ rings possible</div>
                    </div>

                    <div class="control-item" data-tooltip="Controls how spread out the rings are. Higher = more space between rings.">
                        <div class="control-label">
                            <span>Ring Spacing Factor</span>
                            <span class="control-value" id="spacingValue">1.0</span>
                        </div>
                        <input type="range" id="spacingSlider" min="0.1" max="5" value="1" step="0.1">
                    </div>

                    <div class="control-item" data-tooltip="Rotate each individual ring by this angle. Creates spiraling patterns.">
                        <div class="control-label">
                            <span>Per-Ring Rotation</span>
                            <span class="control-value" id="ringRotationValue">0¬∞</span>
                        </div>
                        <input type="range" id="ringRotationSlider" min="0" max="360" value="0" step="0.01">
                        <input type="number" id="ringRotationInput" value="0" min="0" max="3600" step="0.0000000000000001" style="margin-top: 8px;" placeholder="Degrees per ring">
                    </div>
                </div>

                <div id="dyadicRingControls" class="control-row" style="display: none;">
                    <div class="control-item" data-tooltip="Base modulus M‚ÇÄ for the sequence">
                        <div class="control-label">
                            <span>Base Modulus (M‚ÇÄ)</span>
                            <span class="control-value" id="baseModDisplay">30</span>
                        </div>
                        <input type="number" id="baseModInput" value="30" min="1" step="1">
                    </div>

                    <div class="control-item" data-tooltip="Scaling factor b (typically 2, 3, 5 for dyadic/p-adic)">
                        <div class="control-label">
                            <span>Scale Factor (b)</span>
                            <span class="control-value" id="scaleFactorDisplay">2</span>
                        </div>
                        <input type="number" id="scaleFactorInput" value="2" min="2" step="1">
                    </div>

                    <div class="control-item" data-tooltip="Starting exponent n‚ÇÄ">
                        <div class="control-label">
                            <span>Start Exponent (n‚ÇÄ)</span>
                            <span class="control-value" id="startExpDisplay">0</span>
                        </div>
                        <input type="number" id="startExpInput" value="0" min="0" step="1">
                    </div>

                    <div class="control-item" data-tooltip="Ending exponent n_max">
                        <div class="control-label">
                            <span>End Exponent (n_max)</span>
                            <span class="control-value" id="endExpDisplay">10</span>
                        </div>
                        <input type="number" id="endExpInput" value="10" min="0" step="1">
                    </div>

                    <div class="control-item" style="grid-column: 1 / -1;">
                        <div class="control-label">
                            <span>Sequence Preview</span>
                        </div>
                        <div id="ringSequencePreview" style="font-family: 'Fira Code', monospace; font-size: 0.85em; color: var(--cyan); padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; margin-top: 8px;">
                            Will show: M‚ÇÄ √ó b^n‚ÇÄ, M‚ÇÄ √ó b^(n‚ÇÄ+1), ..., M‚ÇÄ √ó b^n_max
                        </div>
                    </div>

                    <div class="control-item" style="grid-column: 1 / -1;">
                        <button class="btn btn-primary" onclick="applyDyadicFamily()" style="width: 100%; padding: 15px; font-size: 1.1em; margin-top: 15px; box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);">
                            <span>APPLY</span>
                        </button>
                    </div>

                    <div class="control-item" style="grid-column: 1 / -1;">
                        <div class="control-label">
                            <span>Quick Dyadic Presets</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 8px;">
                            <button class="btn btn-accent" onclick="setDyadicPreset(2, 2, 0, 10)" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>2√ó2‚Åø</span>
                            </button>
                            <button class="btn btn-accent" onclick="setDyadicPreset(3, 2, 0, 10)" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>3√ó2‚Åø</span>
                            </button>
                            <button class="btn btn-accent" onclick="setDyadicPreset(6, 2, 0, 10)" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>6√ó2‚Åø</span>
                            </button>
                            <button class="btn btn-accent" onclick="setDyadicPreset(30, 2, 0, 10)" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>30√ó2‚Åø</span>
                            </button>
                            <button class="btn btn-accent" onclick="setDyadicPreset(5, 5, 0, 8)" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>5√ó5‚Åø</span>
                            </button>
                            <button class="btn btn-accent" onclick="setDyadicPreset(3, 3, 0, 9)" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>3√ó3‚Åø</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Custom Moduli List Controls -->
                <div id="customModuliControls" class="control-row" style="display: none;">
                    <div class="control-item" style="grid-column: 1 / -1;">
                        <div class="control-label">
                            <span>Custom Moduli Sequence (Click ‚úï to remove)</span>
                            <span class="control-value" id="customCountDisplay">0 moduli</span>
                        </div>
                        <div id="customModuliList" class="farey-point-list" style="max-height: 250px;"></div>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button class="add-btn" onclick="addCustomModulus()">+ Add Modulus</button>
                            <button class="btn btn-secondary" onclick="clearAllCustomModuli()" style="padding: 8px 20px; background: #e74c3c;">
                                <span>Clear All</span>
                            </button>
                        </div>
                        <div class="help-text">Enter moduli as integers (e.g., 30, 60, 120, 240, or any custom sequence)</div>
                    </div>

                    <div class="control-item" style="grid-column: 1 / -1;">
                        <div class="control-label">
                            <span>Sequence Preview</span>
                        </div>
                        <div id="customModuliPreview" style="font-family: 'Fira Code', monospace; font-size: 0.85em; color: var(--cyan); padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; margin-top: 8px;">
                            No moduli added yet
                        </div>
                    </div>

                    <div class="control-item" style="grid-column: 1 / -1;">
                        <button class="btn btn-primary" onclick="applyCustomModuli()" style="width: 100%; padding: 15px; font-size: 1.1em; margin-top: 15px; box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);">
                            <span>‚úì APPLY CUSTOM SEQUENCE</span>
                        </button>
                    </div>

                    <div class="control-item" style="grid-column: 1 / -1;">
                        <div class="control-label">
                            <span>Quick Custom Presets</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 8px;">
                            <button class="btn btn-accent" onclick="loadCustomPreset('2x2n')" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>2√ó2‚Åø (n=0‚Üí10)</span>
                            </button>
                            <button class="btn btn-accent" onclick="loadCustomPreset('3x2n')" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>3√ó2‚Åø (n=0‚Üí10)</span>
                            </button>
                            <button class="btn btn-accent" onclick="loadCustomPreset('6x2n')" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>6√ó2‚Åø (n=0‚Üí10)</span>
                            </button>
                            <button class="btn btn-accent" onclick="loadCustomPreset('30x2n')" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>30√ó2‚Åø (n=0‚Üí10)</span>
                            </button>
                            <button class="btn btn-accent" onclick="loadCustomPreset('5x5n')" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>5√ó5‚Åø (n=0‚Üí8)</span>
                            </button>
                            <button class="btn btn-accent" onclick="loadCustomPreset('fibonacci')" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>Fibonacci</span>
                            </button>
                            <button class="btn btn-accent" onclick="loadCustomPreset('primes')" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>First 15 Primes</span>
                            </button>
                            <button class="btn btn-accent" onclick="loadCustomPreset('squares')" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>Perfect Squares</span>
                            </button>
                            <button class="btn btn-accent" onclick="loadCustomPreset('factorials')" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>Factorials</span>
                            </button>
                        </div>
                    </div>
                </div>



                <!-- Custom Farey Points -->
                <div class="section-header canvas-global">Farey Sequence & Custom Points</div>
                <div class="control-row">
                    <div class="control-item" data-tooltip="Generate complete Farey sequence F_n with option to include 0/n for each denominator n (0/1, 0/2, 0/3, etc.)">
                        <div class="control-label">
                            <span>Generate Farey Sequence F_n</span>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="number" id="fareyOrderInput" value="5" min="1" max="100" style="flex: 1;">
                            <button class="btn btn-secondary" onclick="generateFareySequence()" style="padding: 8px 20px; margin: 0;">
                                <span>Generate F_n</span>
                            </button>
                        </div>
                        <div class="help-text">F_n max = current modulus m (currently F_<span id="maxFareyOrder">101</span> available). Option to include 0/n for each n.</div>
                    </div>

                    <div class="control-item" data-tooltip="Add all residue classes k/m for a given modulus m, from 0/m to (m-1)/m">
                        <div class="control-label">
                            <span>Add All Residues for Modulus</span>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="number" id="residueModInput" value="12" min="1" step="1" style="flex: 1;" placeholder="Modulus">
                            <button class="btn btn-secondary" onclick="addAllResidues()" style="padding: 8px 20px; margin: 0;">
                                <span>Add 0/m to (m-1)/m</span>
                            </button>
                        </div>
                        <div class="help-text">Adds all fractions k/m for k = 0 to m-1 (includes 0/m)</div>
                    </div>

                    <div class="control-item" data-tooltip="Quick preset Farey sequences for common exploration">
                        <div class="control-label">
                            <span>Quick Presets</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                            <button class="btn btn-accent" onclick="generateFareySequence(3)" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>F‚ÇÉ</span>
                            </button>
                            <button class="btn btn-accent" onclick="generateFareySequence(5)" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>F‚ÇÖ</span>
                            </button>
                            <button class="btn btn-accent" onclick="generateFareySequence(7)" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>F‚Çá</span>
                            </button>
                            <button class="btn btn-accent" onclick="addAllResidues(6)" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>All mod 6</span>
                            </button>
                            <button class="btn btn-accent" onclick="addAllResidues(12)" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>All mod 12</span>
                            </button>
                            <button class="btn btn-accent" onclick="addAllResidues(24)" style="padding: 6px 10px; font-size: 0.8em;">
                                <span>All mod 24</span>
                            </button>
                        </div>
                    </div>

                    <div class="control-item" style="grid-column: 1 / -1;" data-tooltip="Manually add or remove specific rational fractions. Click ‚úï to remove a point.">
                        <div class="control-label">
                            <span>Custom Points (Click ‚úï to remove)</span>
                            <span class="control-value" id="fareyCountDisplay">3 points</span>
                        </div>
                        <div id="fareyPointsList" class="farey-point-list"></div>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button class="add-btn" onclick="addFareyPoint()">+ Add Custom Point</button>
                            <button class="btn btn-secondary" onclick="clearAllFareyPoints()" style="padding: 8px 20px; background: #e74c3c;">
                                <span>Clear All</span>
                            </button>
                        </div>
                        <div class="help-text">Format: numerator/denominator (e.g., 1/3, 2/5, 3/7)</div>
                    </div>
                </div>

                <!-- Connection Options -->
                <div class="section-header canvas-nested">Connection Options</div>
                <div class="control-row">
                    <div class="control-item" data-tooltip="Filter which points get connections based on their GCD with the modulus">
                        <div class="control-label">
                            <span>Apply Connections To</span>
                        </div>
                        <select id="gcdFilter">
                            <option value="both">Both GCD=1 and GCD‚â†1</option>
                            <option value="coprime">Only GCD=1 (Coprime)</option>
                            <option value="noncoprime">Only GCD‚â†1 (Non-Coprime)</option>
                        </select>
                        <div class="help-text">Filter points by their GCD relationship</div>
                    </div>

                    <div class="control-item" data-tooltip="Choose color scheme for nested rings visualization">
                        <div class="control-label">
                            <span>Nested Rings Color Scheme</span>
                        </div>
                        <select id="nestedColorScheme">
                            <option value="gcd">By GCD Value (Default)</option>
                            <option value="coprime">Binary (Coprime vs Non-Coprime)</option>
                            <option value="rainbow">Rainbow by Angle</option>
                            <option value="ring">By Ring (Modulus)</option>
                            <option value="prime">Prime Factorization</option>
                            <option value="totient">Totient Class</option>
                            <option value="monochrome">Monochrome (Gold)</option>
                            <option value="default">Blue-Red Gradient</option>
                            <option value="fire">Fire (Black-Red-Orange-Yellow)</option>
                            <option value="plasma">Plasma (Purple-Pink-Yellow)</option>
                            <option value="viridis">Viridis (Purple-Green-Yellow)</option>
                            <option value="cool">Cool (Cyan-Blue-Magenta)</option>
                            <option value="thermal">Thermal (Black-Red-White)</option>
                            <option value="ocean">Ocean (Deep Blue to Cyan)</option>
                            <option value="sunset">Sunset (Purple-Orange-Gold)</option>
                            <option value="forest">Forest (Dark Green to Light)</option>
                            <option value="rainbow">Rainbow (Full Spectrum)</option>
                            <option value="grayscale">Grayscale</option>
                        </select>
                        <div class="help-text">Different color schemes reveal different patterns. Gradient schemes (fire, plasma, viridis, etc.) color by angular position</div>
                        <div id="colorSchemePreview" style="width: 100%; height: 20px; margin-top: 8px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.1);"></div>
                    </div>

                    <div class="control-item" data-tooltip="Draw lines connecting points based on mathematical relationships in the nested rings view.">
                        <div class="control-label">
                            <span>Connect Points By</span>
                        </div>
                        <select id="connectionMode">
                            <option value="none">No Connections</option>
                            <option value="farey">Farey Points Only</option>
                            <option value="mod">Same Modulus</option>
                            <option value="angle">Same Angle</option>
                            <option value="gcd">Same GCD</option>
                            <option value="fraction">Same Fraction Value</option>
                            <option value="gap2n">Gap-2n (r to r+2n)</option>
                            <option value="evengaps">Multiple Even Gaps</option>
                        </select>
                    </div>

                    <div class="control-item" id="singleGapControl" data-tooltip="For gap-2n connections: the gap size between connected residues (connects r to r+gap).">
                        <div class="control-label">
                            <span>Gap Size (2n)</span>
                            <span class="control-value" id="gapSizeDisplay">2</span>
                        </div>
                        <input type="number" id="gapSizeInput" value="2" min="1" step="1">
                        <div class="help-text">Connect r to r+gap in residue space</div>
                    </div>

                    <div class="control-item" id="multiGapControl" style="display: none;" data-tooltip="Show multiple even gap patterns simultaneously (2, 4, 6, 8...)">
                        <div class="control-label">
                            <span>Max Even Gap</span>
                            <span class="control-value" id="maxGapDisplay">8</span>
                        </div>
                        <input type="number" id="maxGapInput" value="8" min="2" step="2">
                        <div class="help-text">Show all even gaps from 2 to this value</div>
                    </div>

                    <div class="control-item" data-tooltip="Line width for connections in the nested rings visualization.">
                        <div class="control-label">
                            <span>Connection Thickness</span>
                            <span class="control-value" id="connectionThicknessValue">1.0</span>
                        </div>
                        <input type="range" id="connectionThicknessSlider" min="0.1" max="10" value="1" step="0.1">
                    </div>

                    <div class="control-item" data-tooltip="Transparency of connection lines. Lower = more transparent, easier to see overlapping patterns.">
                        <div class="control-label">
                            <span>Connection Opacity</span>
                            <span class="control-value" id="connectionOpacityValue">0.3</span>
                        </div>
                        <input type="range" id="connectionOpacitySlider" min="0" max="1" value="0.3" step="0.05">
                    </div>
                </div>

                <!-- Label Options -->
                <div class="section-header canvas-global">Label Options</div>
                <div class="control-row">
                    <div class="control-item" data-tooltip="Choose which elements get text labels. 'Everything' can be cluttered for large visualizations.">
                        <div class="control-label">
                            <span>Label Mode</span>
                        </div>
                        <select id="labelMode">
                            <option value="none">No Labels</option>
                            <option value="farey">Farey Points Only</option>
                            <option value="integers">Integers (k) Only</option>
                            <option value="all">All Points (Fractions)</option>
                            <option value="coprime">Coprime Only</option>
                            <option value="rings">Ring Numbers Only</option>
                            <option value="everything">Everything</option>
                        </select>
                    </div>

                    <div class="control-item" data-tooltip="Font size for labels in pixels.">
                        <div class="control-label">
                            <span>Label Size</span>
                            <span class="control-value" id="labelSizeValue">10</span>
                        </div>
                        <input type="range" id="labelSizeSlider" min="6" max="24" value="10" step="1">
                    </div>

                    <div class="control-item" data-tooltip="Label only every Nth ring to reduce clutter. Set to 1 to label all rings.">
                        <div class="control-label">
                            <span>Label Every Nth Ring</span>
                            <span class="control-value" id="labelFreqValue">1</span>
                        </div>
                        <input type="number" id="labelFreqInput" value="1" min="1" step="1">
                    </div>

                    <div class="control-item" data-tooltip="Position labels radially outward from the center to avoid overlapping with points.">
                        <div class="control-label">
                            <span>Label Position</span>
                        </div>
                        <select id="labelPosition">
                            <option value="center">On Point (Center)</option>
                            <option value="radial" selected>Radial (Outside Point)</option>
                        </select>
                    </div>

                    <div class="control-item" data-tooltip="Distance from point to label when using radial positioning.">
                        <div class="control-label">
                            <span>Label Offset</span>
                            <span class="control-value" id="labelOffsetValue">18</span>
                        </div>
                        <input type="range" id="labelOffsetSlider" min="10" max="40" value="18" step="2">
                    </div>
                </div>

                <!-- Plot Order Control -->
                <div class="section-header canvas-global">Plot Order & Arrangement</div>
                <div class="control-row">
                    <div class="control-item" data-tooltip="Choose how to arrange residues on the circle: by angle (standard) or sequentially by value (1,2,3,...,m-1)">
                        <div class="control-label">
                            <span>Plot Order</span>
                        </div>
                        <select id="plotOrder" onchange="updatePlotOrder()" style="width: 100%; padding: 8px; margin-top: 8px; background: var(--bg-mid); color: var(--text); border: 1px solid var(--border); border-radius: 4px; font-family: 'Fira Code', monospace;">
                            <option value="angular">Angular Position (Standard: 2œÄk/m)</option>
                            <option value="sequential">Sequential Order (1,2,3,...,m-1)</option>
                        </select>
                        <div class="help-text" id="plotOrderHelp">Angular: positions by fraction of circle | Sequential: places in sorted order</div>
                    </div>
                </div>

                <!-- Toggles -->
                <div class="section-header canvas-global">Display Options</div>
                <div class="toggle-grid">
                    <input type="checkbox" id="toggleFarey" checked>
                    <label for="toggleFarey" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Farey Triangle</span>
                    </label>

                    <input type="checkbox" id="toggleGeodesic" checked>
                    <label for="toggleGeodesic" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Geodesic Arc</span>
                    </label>

                    <input type="checkbox" id="togglePrimes" checked>
                    <label for="togglePrimes" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Prime Distribution</span>
                    </label>

                    <input type="checkbox" id="toggleChannels" checked>
                    <label for="toggleChannels" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Residue Channels</span>
                    </label>

                    <input type="checkbox" id="toggleCusps" checked>
                    <label for="toggleCusps" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Cusp Points</span>
                    </label>

                    <input type="checkbox" id="toggleRings" checked>
                    <label for="toggleRings" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Ring Circles</span>
                    </label>

                    <input type="checkbox" id="toggleGCD" checked>
                    <label for="toggleGCD" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">GCD Coloring</span>
                    </label>

                    <input type="checkbox" id="toggleGrid" checked>
                    <label for="toggleGrid" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Grid Lines</span>
                    </label>

                    <input type="checkbox" id="toggleFundDomain">
                    <label for="toggleFundDomain" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Fundamental Domain</span>
                    </label>

                    <input type="checkbox" id="toggleVerticals">
                    <label for="toggleVerticals" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Vertical Geodesics</span>
                    </label>

                    <input type="checkbox" id="toggleDiskOutline">
                    <label for="toggleDiskOutline" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Unit Disk Outline</span>
                    </label>

                    <input type="checkbox" id="toggleFordCircles">
                    <label for="toggleFordCircles" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Ford Circles</span>
                    </label>

                    <input type="checkbox" id="toggleFullPlane" checked>
                    <label for="toggleFullPlane" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Full Complex Plane View</span>
                    </label>

                    <input type="checkbox" id="toggleReduction" checked>
                    <label for="toggleReduction" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Modular Reduction View</span>
                    </label>

                    <input type="checkbox" id="toggleReductionProjections" checked>
                    <label for="toggleReductionProjections" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Reduction: Projection Lines</span>
                    </label>

                    <input type="checkbox" id="toggleReductionChannels" checked>
                    <label for="toggleReductionChannels" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Reduction: Channel Rings</span>
                    </label>

                    <input type="checkbox" id="toggleReductionInvert">
                    <label for="toggleReductionInvert" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Reduction: Invert (Inner‚ÜîOuter)</span>
                    </label>

                    <input type="checkbox" id="toggleReductionStats" checked>
                    <label for="toggleReductionStats" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Reduction: Show Statistics Overlay</span>
                    </label>

                    <input type="checkbox" id="togglePrimitiveRoots" checked>
                    <label for="togglePrimitiveRoots" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Primitive Roots Power Sequence</span>
                    </label>

                    <input type="checkbox" id="togglePrimitiveStats" checked>
                    <label for="togglePrimitiveStats" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Primitive Roots: Show Statistics Overlay</span>
                    </label>

                    <input type="checkbox" id="toggleAnimate">
                    <label for="toggleAnimate" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Auto-Rotate</span>
                    </label>

                    <input type="checkbox" id="toggleInvertRings">
                    <label for="toggleInvertRings" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Invert Ring Order (Outer‚ÜîInner)</span>
                    </label>

                    <input type="checkbox" id="toggleInvertAll">
                    <label for="toggleInvertAll" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Invert All Canvases</span>
                    </label>

                    <input type="checkbox" id="toggleShowCoprimeOnly">
                    <label for="toggleShowCoprimeOnly" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Nested: Show Only GCD=1 (Coprime)</span>
                    </label>

                    <input type="checkbox" id="toggleShowNonCoprimeOnly">
                    <label for="toggleShowNonCoprimeOnly" class="toggle-item">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Nested: Show Only GCD‚â†1 (Non-Coprime)</span>
                    </label>
                </div>

                <!-- Global Connection Visualization -->
                <div class="section-header canvas-global">Global Connection Visualization (All Canvases)</div>
                <div class="toggle-grid">
                    <input type="checkbox" id="toggleShowRtoR">
                    <label for="toggleShowRtoR" class="toggle-item" data-tooltip="Connect residue r to itself across all rings. Shows vertical self-similarity in modular tower.">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Show r ‚Üí r Connections</span>
                    </label>

                    <input type="checkbox" id="toggleShowRtoRplus2n">
                    <label for="toggleShowRtoRplus2n" class="toggle-item" data-tooltip="Connect r to r+m√ó2‚Åø showing power-of-2 lifts in modular sequences. Reveals binary structure.">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Show r ‚Üí r+m√ó2‚Åø Connections</span>
                    </label>
                </div>

                <!-- Action Buttons -->
                <div class="action-bar">
                    <button class="btn btn-primary" onclick="updateAll()">
                        <span>Update All</span>
                    </button>
                    <button class="btn btn-secondary" onclick="regeneratePrimes()">
                        <span>Regenerate Primes</span>
                    </button>
                    <button class="btn btn-secondary" onclick="exportConfig()">
                        <span>Save Config</span>
                    </button>
                    <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()">
                        <span>Load Config</span>
                    </button>
                    <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importConfig(event)">
                    <button class="btn btn-accent" onclick="resetDefaults()">
                        <span>Reset to Defaults</span>
                    </button>
                    <button class="btn btn-secondary" onclick="exportVisualization()">
                        <span>Export PNG</span>
                    </button>
                    <button class="btn btn-secondary" onclick="printDiagnostics()">
                        <span>Print Diagnostics</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Export Button - Bottom of Page -->
        <div style="text-align: center; padding: 40px 20px; margin-top: 40px; border-top: 2px solid rgba(255, 215, 0, 0.2);">
            <button class="btn btn-primary" onclick="showExportDialog()" style="padding: 15px 40px; font-size: 1.2em; box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);">
                <span>EXPORT VISUALIZATION AS PNG</span>
            </button>
            <p style="margin-top: 15px; color: rgba(255, 255, 255, 0.5); font-size: 0.9em;">
                Export individual canvases or all four together in high resolution
            </p>
        </div>
    </div>

    <script>
        // ============================================================
        // GLOBAL STATE
        // ============================================================
        
        const CONFIG = {
            diskRadius: 0.38,
            halfPlaneScale: 0.22,
            colors: {
                disk: '#e74c3c',
                farey: '#ffd700',
                fareyFill: 'rgba(255, 215, 0, 0.08)',
                geodesic: '#1abc9c',
                cusp: '#e67e22',
                axes: 'rgba(255, 255, 255, 0.2)',
                grid: 'rgba(255, 255, 255, 0.05)',
                prime: '#3498db'
            }
        };

        // ============================================================
        // ADVANCED COLOR SCHEMES
        // ============================================================
        


        let state = {
            phase: 0,
            modulus: 101,
            generator: 3,
            numPrimes: 150,
            primeLimit: 10000,
            animSpeed: 1.0,
            minRing: 1,
            maxRing: 101,
            ringSpacing: 1.0,
            ringRotation: 0,
            angularLayoutMode: 'fractional', // 'fractional' or 'sequential'
            globalLineThickness: 1.0,
            connectionMode: 'none',
            gcdFilter: 'both',
            gapSize: 2,
            maxGap: 8,
            connectionThickness: 1.0,
            connectionOpacity: 0.3,
            labelMode: 'farey',
            labelSize: 10,
            labelFreq: 1,
            labelPosition: 'radial',
            labelOffset: 18,
            nestedColorScheme: 'gcd',
            cayleyHRange: 6,
            cayleyVRange: 4,
            cayleyVOffset: 0,
            cayleyGridDensity: 1,
            transformType: 'standard',
            mobiusA: 1,
            mobiusB: 0,
            mobiusC: 0,
            mobiusD: 1,
            diskZoom: 1.0,
            cayleyZoom: 1.0,
            nestedZoom: 1.0,
            reductionZoom: 1.0,
            fullPlaneZoom: 1.0,
            primitiveZoom: 1.0,
            ringGenerationMode: 'manual',
            baseMod: 30,
            scaleFactor: 2,
            startExp: 0,
            endExp: 10,
            ringSequence: null,
            customModuli: [],
            filters: {
                enabled: false,
                gcdValue: null,
                modRange: [null, null],
                residueClass: null
            },
            animation: {
                mode: 'rotate',
                fps: 30,
                duration: 5,
                recording: false,
                frames: []
            },
            advancedFilterEnabled: false,
            filterGCDValue: 1,
            filterModulusRange: [1, 100],
            filterResidueClass: null,
            plotOrder: 'angular',  // 'angular' or 'sequential'
            showConnections: false,  // For canvas 7 coprime connections
            fareyPoints: [
                {num: 1, den: 1},
                {num: 0, den: 1},
                {num: 1, den: 2},
                {num: 0, den: 2},
                {num: 1, den: 3},
                {num: 2, den: 3},
                {num: 0, den: 3},
                {num: 1, den: 4},
                {num: 3, den: 4},
                {num: 0, den: 4},
                {num: 1, den: 5},
                {num: 2, den: 5},
                {num: 3, den: 5},
                {num: 4, den: 5},
                {num: 0, den: 5}
            ],
            primes: [],
            animationId: null
        };

        // Interactive inspection state
        let inspectionState = {
            selectedPoint: null,
            hoveredPoint: null,
            propertyPanelVisible: false,
            tooltip: null
        };

        let canvases = {
            disk: null,
            cayley: null,
            nested: null,
            fullPlane: null,
            reduction: null,
            primitiveRoots: null,
            diskCtx: null,
            cayleyCtx: null,
            nestedCtx: null,
            fullPlaneCtx: null,
            reductionCtx: null,
            primitiveRootsCtx: null,
            pixiApp: null,
            pixiGraphics: null
        };

        // ============================================================
        // INITIALIZATION
        // ============================================================

        window.addEventListener('load', () => {
            initStarfield();
            initCanvases();
            initPixi();
            initFareyPointsUI();
            regeneratePrimes();
            setupEventListeners();
            setupInteractiveInspection(); // NEW: Set up click/hover handlers
            updateColorSchemePreview(); // Initialize color scheme preview
            populateOrderDropdown(); // Populate generator dropdown
            updateAll();
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 800);
        });

        function initStarfield() {
            const starfield = document.getElementById('starfield');
            for (let i = 0; i < 50; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 4 + 's';
                starfield.appendChild(star);
            }
        }

        function initCanvases() {
            // Original 6 canvases
            canvases.disk = document.getElementById('diskCanvas');
            canvases.cayley = document.getElementById('cayleyCanvas');
            canvases.nested = document.getElementById('nestedCanvas');
            canvases.reduction = document.getElementById('reductionCanvas');
            canvases.primitiveRoots = document.getElementById('primitiveRootsCanvas');
            canvases.fullPlane = document.getElementById('fullPlaneCanvas');
            
            // New 6 canvases
            canvases.canvas7 = document.getElementById('canvas7');
            canvases.canvas8 = document.getElementById('canvas8');
            canvases.canvas9 = document.getElementById('canvas9');
            canvases.canvas10 = document.getElementById('canvas10');
            canvases.canvas11 = document.getElementById('canvas11');
            canvases.canvas12 = document.getElementById('canvas12');
            
            const dpr = window.devicePixelRatio || 1;
            
            // Scale all 12 canvases
            const allCanvases = [
                canvases.disk, canvases.cayley, canvases.nested, canvases.reduction, 
                canvases.primitiveRoots, canvases.fullPlane,
                canvases.canvas7, canvases.canvas8, canvases.canvas9,
                canvases.canvas10, canvases.canvas11, canvases.canvas12
            ];
            
            allCanvases.forEach(canvas => {
                if (canvas) {
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = canvas.width * dpr;
                    canvas.height = canvas.height * dpr;
                    const ctx = canvas.getContext('2d');
                    ctx.scale(dpr, dpr);
                }
            });
            
            // Store contexts
            canvases.diskCtx = canvases.disk.getContext('2d');
            canvases.cayleyCtx = canvases.cayley.getContext('2d');
            canvases.nestedCtx = canvases.nested.getContext('2d');
            canvases.reductionCtx = canvases.reduction.getContext('2d');
            canvases.primitiveRootsCtx = canvases.primitiveRoots.getContext('2d');
            canvases.fullPlaneCtx = canvases.fullPlane.getContext('2d');
        }

        function initPixi() {
            const container = document.getElementById('pixiPrimitiveRootsContainer');
            if (!container) {
                console.error('Pixi container not found');
                return;
            }
            
            canvases.pixiApp = new PIXI.Application({
                width: 1000,
                height: 1000,
                backgroundColor: 0x0a0e27,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true
            });
            
            container.appendChild(canvases.pixiApp.view);
            canvases.pixiGraphics = new PIXI.Graphics();
            canvases.pixiApp.stage.addChild(canvases.pixiGraphics);
        }

        function drawPixiPrimitiveRoots() {
            if (!canvases.pixiApp || !canvases.pixiGraphics) {
                console.warn('Pixi not initialized');
                return;
            }

            const g = canvases.pixiGraphics;
            g.clear();
            
            // Remove all children except graphics
            while (canvases.pixiApp.stage.children.length > 1) {
                canvases.pixiApp.stage.removeChildAt(1);
            }
            
            const width = canvases.pixiApp.view.width / canvases.pixiApp.renderer.resolution;
            const height = canvases.pixiApp.view.height / canvases.pixiApp.renderer.resolution;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35 * state.primitiveZoom;
            
            const m = state.modulus;
            const gen = state.generator || 3;
            const phi = eulerPhi(m);
            const primitiveRoots = findAllPrimitiveRoots(m);
            const isPrimitiveRoot = primitiveRoots.includes(gen);
            const order = getOrderOfElement(gen, m);
            
            // Point and label size from global line thickness
            const pointSize = 8 * state.globalLineThickness;
            const labelSize = Math.max(10, 14 * state.globalLineThickness);
            const powerLabelSize = Math.max(8, 10 * state.globalLineThickness);
            
            // Draw background circle
            g.lineStyle(3 * state.globalLineThickness, 0xffffff, 0.4);
            g.drawCircle(centerX, centerY, radius);
            
            // Draw title
            const titleText = new PIXI.Text(`Power Sequence: g^n mod ${m}`, {
                fontFamily: 'Fira Code',
                fontSize: 28,
                fill: 0xffd700,
                fontWeight: 'bold',
                align: 'center'
            });
            titleText.anchor.set(0.5, 0);
            titleText.x = centerX;
            titleText.y = 20;
            canvases.pixiApp.stage.addChild(titleText);
            
            // Draw generator info
            const genColor = isPrimitiveRoot ? 0xff00ff : 0xff6666;
            const genStatus = isPrimitiveRoot ? '(Primitive Root)' : '(Not Primitive)';
            const infoText = new PIXI.Text(
                `Generator g = ${gen} ${genStatus}  |  ord(${gen}) = ${order}  |  œÜ(${m}) = ${phi}`,
                {
                    fontFamily: 'Fira Code',
                    fontSize: 16,
                    fill: genColor,
                    align: 'center'
                }
            );
            infoText.anchor.set(0.5, 0);
            infoText.x = centerX;
            infoText.y = 55;
            canvases.pixiApp.stage.addChild(infoText);
            
            // Draw cycle info
            const cycleText = isPrimitiveRoot 
                ? `Generates all ${phi} coprime residues (full cyclic group)`
                : `Generates only ${order} residues (subgroup of order ${order})`;
            
            const cycleLabel = new PIXI.Text(cycleText, {
                fontFamily: 'Fira Code',
                fontSize: 14,
                fill: 0x00ffff,
                align: 'center'
            });
            cycleLabel.anchor.set(0.5, 0);
            cycleLabel.x = centerX;
            cycleLabel.y = 82;
            canvases.pixiApp.stage.addChild(cycleLabel);
            
            // Calculate power sequence: g^0, g^1, g^2, ..., g^(order-1) mod m
            const powerSequence = [];
            const angleMap = new Map(); // Maps residue -> angle
            
            for (let n = 0; n < order; n++) {
                const value = modPow(gen, n, m);
                powerSequence.push({ n, value });
                
                // Apply per-ring rotation for this modulus
                let perRingOffset = 0;
                if (state.perRingRotations && state.perRingRotations[m] !== undefined) {
                    perRingOffset = state.perRingRotations[m] * Math.PI / 180;
                } else {
                    perRingOffset = state.ringRotation * Math.PI / 180;
                }
                
                // Calculate angle for this residue
                const angle = (2 * Math.PI * value / m) - Math.PI / 2 + (state.phase * Math.PI / 180) + perRingOffset;
                angleMap.set(value, angle);
            }
            
            // Draw all coprime residues (faded)
            for (let a = 1; a < m; a++) {
                if (gcd(a, m) !== 1) continue;
                
                // Apply per-ring rotation
                let perRingOffset = 0;
                if (state.perRingRotations && state.perRingRotations[m] !== undefined) {
                    perRingOffset = state.perRingRotations[m] * Math.PI / 180;
                } else {
                    perRingOffset = state.ringRotation * Math.PI / 180;
                }
                
                const angle = (2 * Math.PI * a / m) - Math.PI / 2 + (state.phase * Math.PI / 180) + perRingOffset;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                // Draw faded point for non-generated residues
                if (!angleMap.has(a)) {
                    g.lineStyle(1 * state.globalLineThickness, 0x666666, 0.3);
                    g.beginFill(0x333333, 0.2);
                    g.drawCircle(x, y, pointSize * 0.6);
                    g.endFill();
                    
                    // Tiny label
                    const label = new PIXI.Text(`${a}`, {
                        fontFamily: 'Fira Code',
                        fontSize: powerLabelSize,
                        fill: 0x666666,
                        alpha: 0.3
                    });
                    label.anchor.set(0.5, 0.5);
                    const labelDist = radius + 18;
                    label.x = centerX + labelDist * Math.cos(angle);
                    label.y = centerY + labelDist * Math.sin(angle);
                    canvases.pixiApp.stage.addChild(label);
                }
            }
            
            // Draw power sequence with connecting lines
            const colors = [
                0xff0000, 0xff6600, 0xffcc00, 0x66ff00, 0x00ff66,
                0x00ffcc, 0x0066ff, 0x6600ff, 0xcc00ff, 0xff0066
            ];
            
            for (let i = 0; i < powerSequence.length; i++) {
                const { n, value } = powerSequence[i];
                const angle = angleMap.get(value);
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                // Color based on position in sequence
                const color = colors[i % colors.length];
                
                // Draw connecting line to next point
                if (i < powerSequence.length - 1) {
                    const nextValue = powerSequence[i + 1].value;
                    const nextAngle = angleMap.get(nextValue);
                    const nextX = centerX + radius * Math.cos(nextAngle);
                    const nextY = centerY + radius * Math.sin(nextAngle);
                    
                    g.lineStyle(2 * state.globalLineThickness, color, 0.5);
                    g.moveTo(x, y);
                    g.lineTo(nextX, nextY);
                }
                
                // Draw line from center for first point (g^0 = 1)
                if (n === 0) {
                    g.lineStyle(2 * state.globalLineThickness, 0xffd700, 0.4);
                    g.moveTo(centerX, centerY);
                    g.lineTo(x, y);
                }
                
                // Draw point
                g.lineStyle(2 * state.globalLineThickness, 0xffffff, 0.9);
                g.beginFill(color, 0.9);
                g.drawCircle(x, y, pointSize * (n === 0 ? 1.5 : 1.2));
                g.endFill();
                
                // Draw residue value label (outside circle)
                const valueLabel = new PIXI.Text(`${value}`, {
                    fontFamily: 'Fira Code',
                    fontSize: labelSize,
                    fill: color,
                    fontWeight: 'bold'
                });
                valueLabel.anchor.set(0.5, 0.5);
                const labelDist = radius + 25;
                valueLabel.x = centerX + labelDist * Math.cos(angle);
                valueLabel.y = centerY + labelDist * Math.sin(angle);
                canvases.pixiApp.stage.addChild(valueLabel);
                
                // Draw power label (g^n) closer to circle
                const powerLabel = new PIXI.Text(`g^${n}`, {
                    fontFamily: 'Fira Code',
                    fontSize: powerLabelSize,
                    fill: 0xaaaaaa
                });
                powerLabel.anchor.set(0.5, 0.5);
                const powerDist = radius + 45;
                powerLabel.x = centerX + powerDist * Math.cos(angle);
                powerLabel.y = centerY + powerDist * Math.sin(angle);
                canvases.pixiApp.stage.addChild(powerLabel);
            }
            
            // Draw legend at bottom
            const legendY = height - 100;
            const legendText = new PIXI.Text(
                `Visualization: Points show g^n ‚â° ${powerSequence.map(p => p.value).join(' ‚Üí ')} (mod ${m})` +
                (powerSequence.length < 15 ? '' : '\nColors cycle through sequence'),
                {
                    fontFamily: 'Fira Code',
                    fontSize: 12,
                    fill: 0xcccccc,
                    align: 'center',
                    wordWrap: true,
                    wordWrapWidth: width - 100
                }
            );
            legendText.anchor.set(0.5, 0);
            legendText.x = centerX;
            legendText.y = legendY;
            canvases.pixiApp.stage.addChild(legendText);
            
            // Show primitive roots list if relevant
            if (primitiveRoots.length > 0 && primitiveRoots.length < 20) {
                const rootsText = new PIXI.Text(
                    `All primitive roots mod ${m}: {${primitiveRoots.join(', ')}}`,
                    {
                        fontFamily: 'Fira Code',
                        fontSize: 11,
                        fill: 0xff00ff,
                        align: 'center'
                    }
                );
                rootsText.anchor.set(0.5, 0);
                rootsText.x = centerX;
                rootsText.y = legendY + 35;
                canvases.pixiApp.stage.addChild(rootsText);
            }
        }

        // Generator control functions
        function updateGenerator(value) {
            const val = parseInt(value);
            const m = state.modulus;
            
            // Check if generator is valid (coprime to m)
            if (gcd(val, m) !== 1) {
                alert(`Error: ${val} is not coprime to ${m}. Generator must be coprime to the modulus.`);
                return;
            }
            
            state.generator = val;
            document.getElementById('generatorValue').textContent = val;
            document.getElementById('generatorInput').value = val;
            
            // Update help text
            const primitiveRoots = findAllPrimitiveRoots(m);
            const isPrimitive = primitiveRoots.includes(val);
            const order = getOrderOfElement(val, m);
            
            document.getElementById('generatorHelp').textContent = 
                isPrimitive 
                    ? `g=${val} is a primitive root (ord=${order}=œÜ(${m}))`
                    : `g=${val} has order ${order} (not primitive, ord<œÜ(${m}))`;
            
            updateAll();
        }

        function findSmallestPrimitiveRoot() {
            const m = state.modulus;
            const roots = findAllPrimitiveRoots(m);
            
            if (roots.length === 0) {
                alert(`No primitive roots exist for modulus ${m}.\n\nPrimitive roots only exist for m = 1, 2, 4, p^k, or 2p^k where p is an odd prime.`);
                return;
            }
            
            const smallest = roots[0];
            updateGenerator(smallest);
        }

        function showAllPrimitiveRoots() {
            const m = state.modulus;
            const roots = findAllPrimitiveRoots(m);
            
            if (roots.length === 0) {
                alert(`No primitive roots exist for modulus ${m}.\n\nPrimitive roots only exist for m = 1, 2, 4, p^k, or 2p^k where p is an odd prime.`);
                return;
            }
            
            alert(`All primitive roots mod ${m}:\n\n{${roots.join(', ')}}\n\nTotal: ${roots.length} primitive root(s)\nœÜ(${m}) = ${eulerPhi(m)}`);
        }

        // Populate order dropdown with all coprime elements
        function populateOrderDropdown() {
            const m = state.modulus;
            const select = document.getElementById('orderElementSelect');
            const phi = eulerPhi(m);
            
            // Clear existing options except first
            select.innerHTML = '<option value="">-- Select element by order --</option>';
            
            // Calculate orders for all coprime elements
            const orderGroups = {};
            for (let g = 1; g < m; g++) {
                if (gcd(g, m) !== 1) continue;
                
                const order = getOrderOfElement(g, m);
                if (!orderGroups[order]) {
                    orderGroups[order] = [];
                }
                orderGroups[order].push(g);
            }
            
            // Sort by order (ascending)
            const sortedOrders = Object.keys(orderGroups).map(Number).sort((a, b) => a - b);
            
            // Add options grouped by order
            sortedOrders.forEach(order => {
                const elements = orderGroups[order];
                const isPrimitive = (order === phi);
                
                elements.forEach(g => {
                    const option = document.createElement('option');
                    option.value = g;
                    option.textContent = isPrimitive 
                        ? `g=${g} (ord=${order}) ‚òÖ PRIMITIVE`
                        : `g=${g} (ord=${order})`;
                    option.style.color = isPrimitive ? '#ff00ff' : '#ffffff';
                    select.appendChild(option);
                });
            });
            
            // Update modulus display
            document.getElementById('orderTableModulus').textContent = m;
            
            // Update help text
            document.getElementById('orderSelectHelp').textContent = 
                `${phi} coprime elements | ${sortedOrders.length} distinct orders`;
        }

        // Select element from order dropdown
        function selectElementFromOrder(value) {
            if (!value) return;
            updateGenerator(parseInt(value));
        }

        // Update plot order mode
        function updatePlotOrder() {
            const mode = document.getElementById('plotOrder').value;
            state.plotOrder = mode;
            
            const helpText = mode === 'angular' 
                ? 'Angular: positions by fraction of circle (2œÄk/m)'
                : 'Sequential: places residues 1,2,3,...,m-1 in order around circle';
            document.getElementById('plotOrderHelp').textContent = helpText;
            
            updateAll();
        }

        // Calculate angle based on plot order mode
        function getPlotAngle(value, modulus, baseAngle, perRingOffset = 0) {
            const phase = state.phase * Math.PI / 180;
            
            if (state.plotOrder === 'sequential') {
                // Sequential: arrange coprime residues 1,2,3,...,m-1 in order
                // Find position in sorted list of coprime elements
                const coprimes = [];
                for (let k = 1; k < modulus; k++) {
                    if (gcd(k, modulus) === 1) coprimes.push(k);
                }
                const index = coprimes.indexOf(value);
                if (index === -1) {
                    // Non-coprime, place by standard position
                    return (2 * Math.PI * value / modulus) + phase + perRingOffset;
                }
                // Place sequentially around circle
                return (2 * Math.PI * index / coprimes.length) + phase + perRingOffset;
            } else {
                // Angular: standard positioning by 2œÄk/m
                return baseAngle + phase + perRingOffset;
            }
        }

        // Show detailed order table
        function showOrderTable() {
            const m = state.modulus;
            const phi = eulerPhi(m);
            
            // Calculate orders for all coprime elements
            const orderGroups = {};
            for (let g = 1; g < m; g++) {
                if (gcd(g, m) !== 1) continue;
                
                const order = getOrderOfElement(g, m);
                if (!orderGroups[order]) {
                    orderGroups[order] = [];
                }
                orderGroups[order].push(g);
            }
            
            // Sort by order
            const sortedOrders = Object.keys(orderGroups).map(Number).sort((a, b) => a - b);
            
            // Build table text
            let tableText = `ORDER TABLE FOR (‚Ñ§/${m}‚Ñ§)*\n`;
            tableText += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
            tableText += `œÜ(${m}) = ${phi} coprime elements\n`;
            tableText += `${sortedOrders.length} distinct orders\n\n`;
            
            // Check if cyclic
            const primitiveRoots = findAllPrimitiveRoots(m);
            if (primitiveRoots.length > 0) {
                tableText += `‚úì CYCLIC GROUP (${primitiveRoots.length} primitive root${primitiveRoots.length > 1 ? 's' : ''})\n`;
                tableText += `  Generators: {${primitiveRoots.join(', ')}}\n\n`;
            } else {
                tableText += `‚úó NOT CYCLIC (no primitive roots)\n\n`;
            }
            
            tableText += `ORDER DISTRIBUTION:\n`;
            tableText += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
            
            sortedOrders.forEach(order => {
                const elements = orderGroups[order];
                const count = elements.length;
                const isPrimitive = (order === phi);
                const symbol = isPrimitive ? ' ‚òÖ' : '';
                
                tableText += `\nOrder ${order}${symbol}: (${count} element${count > 1 ? 's' : ''})\n`;
                
                // Show elements in rows of 10
                for (let i = 0; i < elements.length; i += 10) {
                    const row = elements.slice(i, i + 10);
                    tableText += `  ${row.join(', ')}${i + 10 < elements.length ? ',' : ''}\n`;
                }
            });
            
            // Show in alert (or could create modal)
            alert(tableText);
            
            // Also populate the dropdown
            populateOrderDropdown();
        }

        function populateOrderDropdown() {
            const m = state.modulus;
            const phi = eulerPhi(m);
            const select = document.getElementById('orderElementSelect');
            
            // Clear existing options except first
            select.innerHTML = '<option value="">-- Select element by order --</option>';
            
            // Calculate orders for all coprime elements
            const orderGroups = {};
            for (let g = 1; g < m; g++) {
                if (gcd(g, m) !== 1) continue;
                
                const order = getOrderOfElement(g, m);
                if (!orderGroups[order]) {
                    orderGroups[order] = [];
                }
                orderGroups[order].push(g);
            }
            
            // Sort by order
            const sortedOrders = Object.keys(orderGroups).map(Number).sort((a, b) => a - b);
            
            // Add options grouped by order
            sortedOrders.forEach(order => {
                const elements = orderGroups[order];
                const isPrimitive = (order === phi);
                
                // Create optgroup for this order
                const optgroup = document.createElement('optgroup');
                optgroup.label = `Order ${order}${isPrimitive ? ' ‚òÖ (Primitive)' : ''} - ${elements.length} element${elements.length > 1 ? 's' : ''}`;
                
                elements.forEach(g => {
                    const option = document.createElement('option');
                    option.value = g;
                    option.textContent = `g=${g} (ord=${order})${isPrimitive ? ' ‚òÖ' : ''}`;
                    optgroup.appendChild(option);
                });
                
                select.appendChild(optgroup);
            });
            
            // Update help text
            const primitiveRoots = findAllPrimitiveRoots(m);
            document.getElementById('orderSelectHelp').textContent = 
                primitiveRoots.length > 0 
                    ? `Cyclic group: ${primitiveRoots.length} primitive root${primitiveRoots.length > 1 ? 's' : ''}`
                    : `Not cyclic: no primitive roots exist`;
        }

        function selectElementFromOrder(value) {
            if (!value) return;
            
            const g = parseInt(value);
            updateGenerator(g);
        }

        // Auto-populate dropdown when modulus changes
        function updateModulusWithDropdown(value) {
            updateModulus(value);
            populateOrderDropdown();
        }

        // Find all primitive roots for modulus m
        function findAllPrimitiveRoots(m) {
            const roots = [];
            if (m === 1) return [1];
            
            const phi = eulerPhi(m);
            for (let g = 1; g < m; g++) {
                if (isPrimitive(g, m, phi)) {
                    roots.push(g);
                }
            }
            return roots;
        }

        function isPrimitive(g, m, phi) {
            if (gcd(g, m) !== 1) return false;
            
            if (phi === undefined) {
                phi = eulerPhi(m);
            }
            
            const factors = primeFactors(phi);
            
            for (let factor of factors) {
                const exponent = phi / factor;
                if (modPow(g, exponent, m) === 1) {
                    return false;
                }
            }
            return true;
        }

        function primeFactors(n) {
            const factors = new Set();
            let d = 2;
            while (d * d <= n) {
                while (n % d === 0) {
                    factors.add(d);
                    n /= d;
                }
                d++;
            }
            if (n > 1) factors.add(n);
            return Array.from(factors);
        }

        function modPow(base, exp, mod) {
            let result = 1;
            base = base % mod;
            while (exp > 0) {
                if (exp % 2 === 1) {
                    result = (result * base) % mod;
                }
                exp = Math.floor(exp / 2);
                base = (base * base) % mod;
            }
            return result;
        }

        function getOrderOfElement(a, m) {
            if (gcd(a, m) !== 1) return 0;
            
            let order = 1;
            let current = a % m;
            
            while (current !== 1) {
                current = (current * a) % m;
                order++;
                if (order > m) break;
            }
            
            return order;
        }


        function initFareyPointsUI() {
            updateFareyPointsList();
        }

        function updateFareyPointsList() {
            const list = document.getElementById('fareyPointsList');
            list.innerHTML = '';
            
            state.fareyPoints.forEach((point, index) => {
                const item = document.createElement('div');
                item.className = 'farey-point-item';
                
                const input = document.createElement('input');
                input.type = 'text';
                input.value = `${point.num}/${point.den}`;
                input.onchange = (e) => updateFareyPointValue(index, e.target.value);
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.textContent = '‚úï';
                removeBtn.onclick = () => removeFareyPoint(index);
                
                item.appendChild(input);
                item.appendChild(removeBtn);
                list.appendChild(item);
            });
            
            // Update count display
            document.getElementById('fareyCountDisplay').textContent = `${state.fareyPoints.length} point${state.fareyPoints.length !== 1 ? 's' : ''}`;
        }

        function generateFareySequence(n) {
            // If called with a number argument, use it; otherwise read from input
            const order = n || parseInt(document.getElementById('fareyOrderInput').value);
            
            // Limit to current modulus
            const maxOrder = state.modulus;
            const actualOrder = Math.min(order, maxOrder);
            
            if (actualOrder < 1) {
                alert('Farey order must be at least 1');
                return;
            }
            
            if (order > maxOrder) {
                alert(`Farey order limited to current modulus m=${maxOrder}. Generating F_${actualOrder} instead.`);
            }
            
            // Ask if user wants to include 0/n for each n
            const includeZeroFractions = confirm('Include 0/n fractions for each denominator?\n\n(e.g., F_3 with 0/n: {1/1, 0/1, 1/2, 0/2, 1/3, 2/3, 0/3})\n(e.g., F_3 without 0/n: {0/1, 1/2, 1/3, 2/3, 1/1})\n\nClick OK to include all 0/n (placed at end of each sequence)\nClick Cancel for standard Farey (only coprime fractions)');
            
            // Generate Farey sequence F_n
            const fareySeq = [];
            
            if (includeZeroFractions) {
                // For each denominator, add coprime fractions first, then 0/n at the end
                for (let q = 1; q <= actualOrder; q++) {
                    // Add all coprime fractions p/q where gcd(p,q)=1 and p > 0
                    for (let p = 1; p <= q; p++) {
                        if (gcd(p, q) === 1) {
                            fareySeq.push({ num: p, den: q });
                        }
                    }
                    // Add 0/q at the end of this sequence
                    fareySeq.push({ num: 0, den: q });
                }
            } else {
                // Standard Farey sequence: only coprime fractions, sorted by value
                const tempSeq = [];
                for (let q = 1; q <= actualOrder; q++) {
                    for (let p = 0; p <= q; p++) {
                        if (gcd(p, q) === 1) {
                            tempSeq.push({ num: p, den: q });
                        }
                    }
                }
                // Sort by value for standard Farey
                tempSeq.sort((a, b) => (a.num / a.den) - (b.num / b.den));
                
                // Remove duplicates by value
                const seen = new Set();
                tempSeq.forEach(f => {
                    const val = f.num / f.den;
                    if (!seen.has(val)) {
                        seen.add(val);
                        fareySeq.push(f);
                    }
                });
            }
            
            state.fareyPoints = fareySeq;
            updateFareyPointsList();
            updateAll();
        }

        function addAllResidues(m) {
            // If called with a number argument, use it; otherwise read from input
            const modulus = m || parseInt(document.getElementById('residueModInput').value);
            
            if (modulus < 1) {
                alert('Modulus must be at least 1');
                return;
            }
            
            // Add all residues k/m for k = 0 to m-1
            const newPoints = [];
            for (let k = 0; k < modulus; k++) {
                newPoints.push({ num: k, den: modulus });
            }
            
            // Check if we should replace or append
            const shouldReplace = confirm(
                `Add all ${modulus} residues (0/${modulus} to ${modulus-1}/${modulus})?\n\n` +
                `Click OK to REPLACE current points\n` +
                `Click Cancel to ADD to current points`
            );
            
            if (shouldReplace) {
                state.fareyPoints = newPoints;
            } else {
                // Append and remove duplicates
                const combined = [...state.fareyPoints, ...newPoints];
                const unique = [];
                const seen = new Set();
                
                combined.forEach(f => {
                    const key = `${f.num}/${f.den}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        unique.push(f);
                    }
                });
                
                state.fareyPoints = unique;
            }
            
            updateFareyPointsList();
            updateAll();
        }

        function clearAllFareyPoints() {
            if (confirm('Clear all Farey points except 0/1?')) {
                state.fareyPoints = [{num: 0, den: 1}];
                updateFareyPointsList();
                updateAll();
            }
        }

        function addFareyPoint() {
            state.fareyPoints.push({num: 1, den: 4});
            updateFareyPointsList();
            updateAll();
        }

        function removeFareyPoint(index) {
            state.fareyPoints.splice(index, 1);
            updateFareyPointsList();
            updateAll();
        }

        function updateFareyPointValue(index, value) {
            const parts = value.split('/');
            if (parts.length === 2) {
                const num = parseInt(parts[0]);
                const den = parseInt(parts[1]);
                if (!isNaN(num) && !isNaN(den) && den > 0) {
                    state.fareyPoints[index] = {num, den};
                    updateAll();
                }
            }
        }

        function setupEventListeners() {
            // Phase slider
            document.getElementById('phaseSlider').addEventListener('input', e => {
                state.phase = parseFloat(e.target.value);
                document.getElementById('phaseValue').textContent = state.phase.toFixed(1) + ' degrees';
                document.getElementById('phaseInput').value = state.phase.toFixed(1);
                if (!state.animationId) updateAll();
            });

            // Phase input box
            document.getElementById('phaseInput').addEventListener('change', e => {
                let val = parseFloat(e.target.value);
                // Handle wraparound
                val = ((val % 360) + 360) % 360;
                state.phase = val;
                document.getElementById('phaseSlider').value = val;
                document.getElementById('phaseValue').textContent = val.toFixed(1) + ' degrees';
                document.getElementById('phaseInput').value = val.toFixed(1);
                if (!state.animationId) updateAll();
            });

            // Modulus input
            document.getElementById('modulusInput').addEventListener('change', e => {
                const val = parseInt(e.target.value);
                if (val > 0) {
                    state.modulus = val;
                    document.getElementById('modulusDisplay').textContent = val;
                    document.getElementById('maxFareyOrder').textContent = val;
                    document.getElementById('orderTableModulus').textContent = val;
                    
                    // Show divisors for Farey understanding
                    const divisors = [];
                    for (let i = 1; i <= val; i++) {
                        if (val % i === 0) divisors.push(i);
                    }
                    const helpText = divisors.length <= 10 
                        ? `Farey denominators: ${divisors.join(', ')}`
                        : `Farey: ${divisors.length} denominators (1,2,...,${val})`;
                    document.getElementById('modulusHelp').textContent = helpText;
                    
                    // Populate order dropdown
                    populateOrderDropdown();
                    
                    updateAll();
                }
            });

            // Prime inputs
            document.getElementById('primesInput').addEventListener('change', e => {
                const val = parseInt(e.target.value);
                if (val >= 0) {
                    state.numPrimes = val;
                    document.getElementById('primesDisplay').textContent = val;
                    updateAll();
                }
            });

            document.getElementById('primeLimitInput').addEventListener('change', e => {
                const val = parseInt(e.target.value);
                if (val >= 100) {
                    state.primeLimit = val;
                    document.getElementById('primeLimitDisplay').textContent = val;
                }
            });

            // Speed slider
            document.getElementById('speedSlider').addEventListener('input', e => {
                state.animSpeed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = state.animSpeed.toFixed(1) + '√ó';
            });

            // Zoom sliders - updated for percentage display
            document.getElementById('diskZoomSlider').addEventListener('input', e => {
                state.diskZoom = parseFloat(e.target.value) / 100;
                document.getElementById('diskZoomValue').textContent = e.target.value + '%';
                if (!state.animationId) updateAll();
            });

            document.getElementById('cayleyZoomSlider').addEventListener('input', e => {
                state.cayleyZoom = parseFloat(e.target.value) / 100;
                document.getElementById('cayleyZoomValue').textContent = e.target.value + '%';
                if (!state.animationId) updateAll();
            });

            document.getElementById('nestedZoomSlider').addEventListener('input', e => {
                state.nestedZoom = parseFloat(e.target.value) / 100;
                document.getElementById('nestedZoomValue').textContent = e.target.value + '%';
                if (!state.animationId) updateAll();
            });

            document.getElementById('reductionZoomSlider').addEventListener('input', e => {
                state.reductionZoom = parseFloat(e.target.value) / 100;
                document.getElementById('reductionZoomValue').textContent = e.target.value + '%';
                if (!state.animationId) updateAll();
            });

            document.getElementById('fullPlaneZoomSlider').addEventListener('input', e => {
                state.fullPlaneZoom = parseFloat(e.target.value) / 100;
                document.getElementById('fullPlaneZoomValue').textContent = e.target.value + '%';
                if (!state.animationId) updateAll();
            });

            document.getElementById('primitiveZoomSlider').addEventListener('input', e => {
                state.primitiveZoom = parseFloat(e.target.value) / 100;
                document.getElementById('primitiveZoomValue').textContent = e.target.value + '%';
                if (!state.animationId) updateAll();
            });

            // Master zoom slider
            document.getElementById('masterZoomSlider').addEventListener('input', e => {
                const zoomPercent = e.target.value;
                const zoomValue = parseFloat(zoomPercent) / 100;
                
                // Update all zoom values
                state.diskZoom = zoomValue;
                state.cayleyZoom = zoomValue;
                state.nestedZoom = zoomValue;
                state.reductionZoom = zoomValue;
                state.fullPlaneZoom = zoomValue;
                state.primitiveZoom = zoomValue;
                
                // Update all displays
                document.getElementById('diskZoomValue').textContent = zoomPercent + '%';
                document.getElementById('cayleyZoomValue').textContent = zoomPercent + '%';
                document.getElementById('nestedZoomValue').textContent = zoomPercent + '%';
                document.getElementById('reductionZoomValue').textContent = zoomPercent + '%';
                document.getElementById('fullPlaneZoomValue').textContent = zoomPercent + '%';
                document.getElementById('primitiveZoomValue').textContent = zoomPercent + '%';
                document.getElementById('masterZoomValue').textContent = zoomPercent + '%';
                
                // Update all sliders
                document.getElementById('diskZoomSlider').value = zoomPercent;
                document.getElementById('cayleyZoomSlider').value = zoomPercent;
                document.getElementById('nestedZoomSlider').value = zoomPercent;
                document.getElementById('reductionZoomSlider').value = zoomPercent;
                document.getElementById('fullPlaneZoomSlider').value = zoomPercent;
                document.getElementById('primitiveZoomSlider').value = zoomPercent;
                
                if (!state.animationId) updateAll();
            });

            // Ring inputs
            document.getElementById('ringGenerationMode').addEventListener('change', e => {
                state.ringGenerationMode = e.target.value;
                
                if (e.target.value === 'manual') {
                    document.getElementById('manualRingControls').style.display = 'grid';
                    document.getElementById('dyadicRingControls').style.display = 'none';
                    document.getElementById('customModuliControls').style.display = 'none';
                    state.ringSequence = null;
                    updateAll(); // Safe to update for manual mode
                } else if (e.target.value === 'customlist') {
                    document.getElementById('manualRingControls').style.display = 'none';
                    document.getElementById('dyadicRingControls').style.display = 'none';
                    document.getElementById('customModuliControls').style.display = 'grid';
                    updateCustomModuliList();
                } else {
                    document.getElementById('manualRingControls').style.display = 'none';
                    document.getElementById('dyadicRingControls').style.display = 'grid';
                    document.getElementById('customModuliControls').style.display = 'none';
                    updateRingSequencePreview(); // ONLY update preview, don't render!
                    // DON'T call updateAll() - wait for user to click APPLY button
                }
            });

            // Dyadic family inputs - UPDATE PREVIEW ONLY, don't apply yet
            document.getElementById('baseModInput').addEventListener('input', e => {
                const val = parseInt(e.target.value) || 1;
                document.getElementById('baseModDisplay').textContent = val;
                updateRingSequencePreview();
            });

            document.getElementById('scaleFactorInput').addEventListener('input', e => {
                const val = parseInt(e.target.value) || 2;
                document.getElementById('scaleFactorDisplay').textContent = val;
                updateRingSequencePreview();
            });

            document.getElementById('startExpInput').addEventListener('input', e => {
                const val = parseInt(e.target.value) || 0;
                document.getElementById('startExpDisplay').textContent = val;
                updateRingSequencePreview();
            });

            document.getElementById('endExpInput').addEventListener('input', e => {
                const val = parseInt(e.target.value) || 0;
                document.getElementById('endExpDisplay').textContent = val;
                updateRingSequencePreview();
            });

            document.getElementById('minRingInput').addEventListener('change', e => {
                const val = parseInt(e.target.value);
                if (val > 0) {
                    syncMinRing(val);
                }
            });

            document.getElementById('maxRingInput').addEventListener('change', e => {
                const val = parseInt(e.target.value);
                if (val >= state.minRing) {
                    syncMaxRing(val);
                }
            });

            // Spacing slider
            document.getElementById('spacingSlider').addEventListener('input', e => {
                syncSpacing(e.target.value);
            });

            // Ring rotation slider
            document.getElementById('ringRotationSlider').addEventListener('input', e => {
                syncRingRotation(e.target.value);
                document.getElementById('ringRotationValue').textContent = formatRotationValue(state.ringRotation) + '¬∞';
                document.getElementById('ringRotationInput').value = state.ringRotation.toFixed(0);
                if (!state.animationId) updateAll();
            });

            // Ring rotation input
            document.getElementById('ringRotationInput').addEventListener('change', e => {
                let val = parseFloat(e.target.value);
                val = ((val % 360) + 360) % 360;
                syncRingRotation(val);
            });

            // Cayley view controls
            document.getElementById('cayleyHRangeSlider').addEventListener('input', e => {
                state.cayleyHRange = parseFloat(e.target.value);
                document.getElementById('cayleyHRangeValue').textContent = state.cayleyHRange.toFixed(1);
                if (!state.animationId) updateAll();
            });

            document.getElementById('cayleyVRangeSlider').addEventListener('input', e => {
                state.cayleyVRange = parseFloat(e.target.value);
                document.getElementById('cayleyVRangeValue').textContent = state.cayleyVRange.toFixed(1);
                if (!state.animationId) updateAll();
            });

            document.getElementById('cayleyVOffsetSlider').addEventListener('input', e => {
                state.cayleyVOffset = parseFloat(e.target.value);
                document.getElementById('cayleyVOffsetValue').textContent = state.cayleyVOffset.toFixed(1);
                if (!state.animationId) updateAll();
            });

            document.getElementById('cayleyGridDensitySlider').addEventListener('input', e => {
                state.cayleyGridDensity = parseFloat(e.target.value);
                document.getElementById('cayleyGridDensityValue').textContent = state.cayleyGridDensity.toFixed(1);
                if (!state.animationId) updateAll();
            });

            // Cayley transform type
            document.getElementById('cayleyTransformType').addEventListener('change', e => {
                state.transformType = e.target.value;
                
                // Show/hide M√∂bius parameters
                const showMobius = (e.target.value === 'mobius');
                document.getElementById('mobiusParamsA').style.display = showMobius ? 'block' : 'none';
                document.getElementById('mobiusParamsB').style.display = showMobius ? 'block' : 'none';
                document.getElementById('mobiusParamsC').style.display = showMobius ? 'block' : 'none';
                document.getElementById('mobiusParamsD').style.display = showMobius ? 'block' : 'none';
                
                // Update description
                const descriptions = {
                    'standard': 'Standard Cayley: w = i(1+z)/(1-z) maps unit disk ‚Üí upper half-plane (conformal bijection for hyperbolic geometry)',
                    'alternate': 'Inverse Cayley: w = i(1-z)/(1+z) also maps disk ‚Üí upper half-plane but with reversed orientation',
                    'ftt': 'FTT Transform: w = (z-i)/(z+i) is the INVERSE of standard Cayley, maps upper half-plane ‚Üí unit disk',
                    'smith': 'Smith Chart: w = (z-1)/(z+1) maps unit disk ‚Üí unit disk, used in RF/microwave impedance visualization',
                    'mobius': 'M√∂bius: w = (az+b)/(cz+d) is the general linear fractional transformation (ad-bc‚â†0 required)'
                };
                document.getElementById('transformDescription').textContent = descriptions[e.target.value];
                
                updateAll();
            });

            // M√∂bius parameters
            ['mobiusA', 'mobiusB', 'mobiusC', 'mobiusD'].forEach(id => {
                document.getElementById(id).addEventListener('change', e => {
                    const param = id.replace('mobius', '').toLowerCase();
                    state['mobius' + id.charAt(6).toUpperCase()] = parseFloat(e.target.value);
                    updateAll();
                });
            });

            // Connection controls
            document.getElementById('connectionMode').addEventListener('change', e => {
                state.connectionMode = e.target.value;
                
                // Show/hide gap controls based on mode
                const singleGapControl = document.getElementById('singleGapControl');
                const multiGapControl = document.getElementById('multiGapControl');
                
                if (e.target.value === 'gap2n') {
                    singleGapControl.style.display = 'block';
                    multiGapControl.style.display = 'none';
                } else if (e.target.value === 'evengaps') {
                    singleGapControl.style.display = 'none';
                    multiGapControl.style.display = 'block';
                } else {
                    singleGapControl.style.display = 'none';
                    multiGapControl.style.display = 'none';
                }
                
                updateAll();
            });

            document.getElementById('gcdFilter').addEventListener('change', e => {
                state.gcdFilter = e.target.value;
                updateAll();
            });

            document.getElementById('nestedColorScheme').addEventListener('change', e => {
                state.nestedColorScheme = e.target.value;
                updateColorSchemePreview();
                updateAll();
            });

            document.getElementById('gapSizeInput').addEventListener('change', e => {
                const val = parseInt(e.target.value);
                if (val > 0) {
                    state.gapSize = val;
                    document.getElementById('gapSizeDisplay').textContent = val;
                    updateAll();
                }
            });

            document.getElementById('maxGapInput').addEventListener('change', e => {
                let val = parseInt(e.target.value);
                if (val < 2) val = 2;
                // Ensure even
                if (val % 2 !== 0) val += 1;
                state.maxGap = val;
                document.getElementById('maxGapInput').value = val;
                document.getElementById('maxGapDisplay').textContent = val;
                updateAll();
            });

            document.getElementById('connectionThicknessSlider').addEventListener('input', e => {
                state.connectionThickness = parseFloat(e.target.value);
                document.getElementById('connectionThicknessValue').textContent = state.connectionThickness.toFixed(1);
                if (!state.animationId) updateAll();
            });

            document.getElementById('connectionOpacitySlider').addEventListener('input', e => {
                state.connectionOpacity = parseFloat(e.target.value);
                document.getElementById('connectionOpacityValue').textContent = state.connectionOpacity.toFixed(2);
                if (!state.animationId) updateAll();
            });

            // Label controls
            document.getElementById('labelMode').addEventListener('change', e => {
                state.labelMode = e.target.value;
                updateAll();
            });

            document.getElementById('labelPosition').addEventListener('change', e => {
                state.labelPosition = e.target.value;
                updateAll();
            });

            document.getElementById('labelOffsetSlider').addEventListener('input', e => {
                state.labelOffset = parseInt(e.target.value);
                document.getElementById('labelOffsetValue').textContent = state.labelOffset;
                if (!state.animationId) updateAll();
            });

            document.getElementById('labelSizeSlider').addEventListener('input', e => {
                state.labelSize = parseInt(e.target.value);
                document.getElementById('labelSizeValue').textContent = state.labelSize;
                if (!state.animationId) updateAll();
            });

            document.getElementById('labelFreqInput').addEventListener('change', e => {
                const val = parseInt(e.target.value);
                if (val > 0) {
                    state.labelFreq = val;
                    document.getElementById('labelFreqValue').textContent = val;
                    updateAll();
                }
            });

            // Animation toggle
            document.getElementById('toggleAnimate').addEventListener('change', e => {
                if (e.target.checked) {
                    startAnimation();
                } else {
                    stopAnimation();
                }
            });

            // Advanced Point Filtering controls
            document.getElementById('filterGCD').addEventListener('change', e => {
                const value = e.target.value;
                state.filters.gcdValue = value === '' ? null : parseInt(value);
                state.filters.enabled = state.filters.gcdValue !== null || 
                                       state.filters.modRange[0] !== null || 
                                       state.filters.modRange[1] !== null;
                updateAll();
            });

            document.getElementById('filterModMin').addEventListener('change', e => {
                const value = e.target.value;
                state.filters.modRange[0] = value === '' ? null : parseInt(value);
                state.filters.enabled = state.filters.gcdValue !== null || 
                                       state.filters.modRange[0] !== null || 
                                       state.filters.modRange[1] !== null;
                updateAll();
            });

            document.getElementById('filterModMax').addEventListener('change', e => {
                const value = e.target.value;
                state.filters.modRange[1] = value === '' ? null : parseInt(value);
                state.filters.enabled = state.filters.gcdValue !== null || 
                                       state.filters.modRange[0] !== null || 
                                       state.filters.modRange[1] !== null;
                updateAll();
            });

            // Animation & Recording controls
            document.getElementById('fpsSlider').addEventListener('input', e => {
                state.animation.fps = parseInt(e.target.value);
                document.getElementById('fpsValue').textContent = state.animation.fps + ' fps';
            });

            document.getElementById('durationSlider').addEventListener('input', e => {
                state.animation.duration = parseInt(e.target.value);
                document.getElementById('durationValue').textContent = state.animation.duration;
            });

            document.getElementById('animationMode').addEventListener('change', e => {
                state.animation.mode = e.target.value;
            });

            // Display toggles
            ['toggleFarey', 'toggleGeodesic', 'togglePrimes', 'toggleChannels', 
             'toggleCusps', 'toggleRings', 'toggleGCD', 'toggleGrid',
             'toggleFundDomain', 'toggleVerticals', 'toggleDiskOutline', 
             'toggleInvertRings', 'toggleInvertAll', 'toggleFordCircles',
             'toggleShowCoprimeOnly', 'toggleShowNonCoprimeOnly',
             'toggleShowRtoR', 'toggleShowRtoRplus2n'].forEach(id => {
                document.getElementById(id).addEventListener('change', e => {
                    // Handle mutual exclusivity for coprime/non-coprime filters
                    if (id === 'toggleShowCoprimeOnly' && e.target.checked) {
                        document.getElementById('toggleShowNonCoprimeOnly').checked = false;
                    } else if (id === 'toggleShowNonCoprimeOnly' && e.target.checked) {
                        document.getElementById('toggleShowCoprimeOnly').checked = false;
                    }
                    updateAll();
                });
            });
            
            // Full plane toggle - now checked by default
            document.getElementById('toggleFullPlane').addEventListener('change', e => {
                const panel = document.getElementById('fullPlanePanel');
                const vizGrid = document.getElementById('vizGrid');
                
                if (e.target.checked) {
                    panel.style.display = 'block';
                    vizGrid.classList.add('four-panel');
                } else {
                    panel.style.display = 'none';
                    vizGrid.classList.remove('four-panel');
                }
                
                updateAll();
            });
            
            document.getElementById('togglePrimitiveRoots').addEventListener('change', e => {
                const panel = document.getElementById('primitiveRootsPanel');
                if (e.target.checked) {
                    panel.style.display = 'block';
                } else {
                    panel.style.display = 'none';
                }
                updateAll();
            });
            
            document.getElementById('toggleReduction').addEventListener('change', e => {
                const panel = document.getElementById('reductionPanel');
                if (e.target.checked) {
                    panel.style.display = 'block';
                } else {
                    panel.style.display = 'none';
                }
                updateAll();
            });
            
            // Reduction canvas toggles
            ['toggleReductionProjections', 'toggleReductionChannels', 'toggleReductionInvert', 'toggleReductionStats'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', updateAll);
                }
            });
            
            // Initialize full plane view on load since toggle is checked by default
            const fullPlanePanel = document.getElementById('fullPlanePanel');
            const reductionPanel = document.getElementById('reductionPanel');
            const vizGrid = document.getElementById('vizGrid');
            fullPlanePanel.style.display = 'block';
            reductionPanel.style.display = 'block';
            vizGrid.classList.add('four-panel');
            
            // Update max Farey order display when modulus changes
            document.getElementById('modulusInput').addEventListener('change', () => {
                document.getElementById('maxFareyOrder').textContent = state.modulus;
            });
        }

        // ============================================================
        // INTERACTIVE INSPECTION SYSTEM
        // ============================================================

        function setupInteractiveInspection() {
            const canvasElements = [
                { canvas: canvases.disk, type: 'disk' },
                { canvas: canvases.cayley, type: 'cayley' },
                { canvas: canvases.nested, type: 'nested' },
                { canvas: canvases.fullPlane, type: 'fullPlane' }
            ];

            canvasElements.forEach(({ canvas, type }) => {
                // Click handler
                canvas.addEventListener('click', (e) => handleCanvasClick(e, canvas, type));
                
                // Hover handler
                canvas.addEventListener('mousemove', (e) => handleCanvasHover(e, canvas, type));
                
                // Mouse leave handler
                canvas.addEventListener('mouseleave', () => {
                    hideTooltip();
                    canvas.style.cursor = 'default';
                });
            });
        }

        function handleCanvasClick(e, canvas, canvasType) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const point = findNearestPoint(canvas, x, y, canvasType);
            
            if (point && point.distance < 15) {
                inspectionState.selectedPoint = point;
                showPropertyPanel(point, e.clientX, e.clientY);
                updateAll(); // Redraw with highlight
            } else {
                closePropertyPanel();
            }
        }

        function handleCanvasHover(e, canvas, canvasType) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const point = findNearestPoint(canvas, x, y, canvasType);
            
            if (point && point.distance < 15) {
                canvas.style.cursor = 'pointer';
                inspectionState.hoveredPoint = point;
                showTooltip(e.clientX, e.clientY, point);
            } else {
                canvas.style.cursor = 'default';
                inspectionState.hoveredPoint = null;
                hideTooltip();
            }
        }

        function findNearestPoint(canvas, x, y, canvasType) {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            let nearestPoint = null;
            let minDistance = Infinity;
            
            if (canvasType === 'disk') {
                const cx = w / 2;
                const cy = h / 2;
                const r = Math.min(w, h) * CONFIG.diskRadius * state.diskZoom;
                const phase = state.phase * Math.PI / 180;
                
                // Check Farey points
                state.fareyPoints.forEach(fp => {
                    const frac = fp.num / fp.den;
                    const angle = 2 * Math.PI * frac + phase;
                    const px = cx + r * Math.cos(angle);
                    const py = cy + r * Math.sin(angle);
                    const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
                    
                    if (dist < minDistance) {
                        minDistance = dist;
                        nearestPoint = {
                            type: 'farey',
                            canvasType: 'disk',
                            num: fp.num,
                            den: fp.den,
                            frac: frac,
                            angle: angle,
                            x: px,
                            y: py,
                            distance: dist
                        };
                    }
                });
                
                // Check primes
                if (document.getElementById('togglePrimes').checked) {
                    const displayPrimes = state.primes.slice(0, state.numPrimes);
                    displayPrimes.forEach(p => {
                        const angle = 2 * Math.PI * p / state.modulus + phase;
                        const px = cx + r * Math.cos(angle);
                        const py = cy + r * Math.sin(angle);
                        const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
                        
                        if (dist < minDistance) {
                            minDistance = dist;
                            nearestPoint = {
                                type: 'prime',
                                canvasType: 'disk',
                                value: p,
                                residue: p % state.modulus,
                                gcd: gcd(p, state.modulus),
                                angle: angle,
                                x: px,
                                y: py,
                                distance: dist
                            };
                        }
                    });
                }
            } else if (canvasType === 'cayley') {
                const phase = state.phase * Math.PI / 180;
                
                function mathToScreen(wp) {
                    const reMin = -state.cayleyHRange / (2 * state.cayleyZoom);
                    const reMax = state.cayleyHRange / (2 * state.cayleyZoom);
                    const imMin = state.cayleyVOffset;
                    const imMax = (state.cayleyVRange / state.cayleyZoom) + state.cayleyVOffset;
                    
                    const sx = ((wp.re - reMin) / (reMax - reMin)) * w;
                    const sy = (1 - (wp.im - imMin) / (imMax - imMin)) * h;
                    
                    return { x: sx, y: sy };
                }
                
                // Check transformed Farey points
                state.fareyPoints.forEach(fp => {
                    const frac = fp.num / fp.den;
                    const angle = 2 * Math.PI * frac + phase;
                    const z = { re: Math.cos(angle), im: Math.sin(angle) };
                    const wp = cayleyTransform(z, state.transformType);
                    const p = mathToScreen(wp);
                    const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
                    
                    if (dist < minDistance) {
                        minDistance = dist;
                        nearestPoint = {
                            type: 'farey',
                            canvasType: 'cayley',
                            num: fp.num,
                            den: fp.den,
                            frac: frac,
                            diskZ: z,
                            cayleyW: wp,
                            x: p.x,
                            y: p.y,
                            distance: dist
                        };
                    }
                });
                
                // Check cusps (Farey points on real axis)
                if (document.getElementById('toggleCusps').checked) {
                    state.fareyPoints.forEach(fp => {
                        const frac = fp.num / fp.den;
                        const angle = 2 * Math.PI * frac + phase;
                        const z = { re: Math.cos(angle), im: Math.sin(angle) };
                        const wp = cayleyTransform(z, state.transformType);
                        const cuspP = mathToScreen({ re: wp.re, im: 0 });
                        const dist = Math.sqrt((x - cuspP.x) ** 2 + (y - cuspP.y) ** 2);
                        
                        if (dist < minDistance) {
                            minDistance = dist;
                            nearestPoint = {
                                type: 'cusp',
                                canvasType: 'cayley',
                                num: fp.num,
                                den: fp.den,
                                frac: frac,
                                position: wp.re,
                                x: cuspP.x,
                                y: cuspP.y,
                                distance: dist
                            };
                        }
                    });
                }
            } else if (canvasType === 'nested') {
                const cx = w / 2;
                const cy = h / 2;
                const maxRadius = Math.min(w, h) * 0.42 * state.nestedZoom;
                const baseRadius = maxRadius * 0.15;
                const numRings = state.maxRing - state.minRing + 1;
                const phase = state.phase * Math.PI / 180;
                const invertRings = document.getElementById('toggleInvertRings').checked;
                
                // Check all ring points
                for (let m = state.minRing; m <= state.maxRing; m++) {
                    let ringIndex;
                    if (invertRings) {
                        ringIndex = (state.maxRing - m);
                    } else {
                        ringIndex = m - state.minRing;
                    }
                    
                    const ringRadius = baseRadius + ringIndex * (maxRadius - baseRadius) / Math.max(1, numRings - 1) * state.ringSpacing;
                    const ringRotationOffset = (state.ringRotation * Math.PI / 180) * ringIndex;
                    
                    for (let k = 0; k < m; k++) {
                        const g = gcd(k, m);
                        const angle = 2 * Math.PI * k / m + phase + ringRotationOffset;
                        const px = cx + ringRadius * Math.cos(angle);
                        const py = cy + ringRadius * Math.sin(angle);
                        const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
                        
                        if (dist < minDistance) {
                            minDistance = dist;
                            nearestPoint = {
                                type: 'ringPoint',
                                canvasType: 'nested',
                                k: k,
                                m: m,
                                frac: k / m,
                                gcd: g,
                                phi: eulerPhi(m),
                                isCoprime: g === 1,
                                ringIndex: ringIndex,
                                x: px,
                                y: py,
                                distance: dist
                            };
                        }
                    }
                }
            }
            
            return nearestPoint;
        }

        function showTooltip(x, y, point) {
            const tooltip = document.getElementById('tooltip');
            let content = '';
            
            if (point.type === 'farey') {
                content = `<div class="tooltip-label">${point.num}/${point.den}</div>`;
                content += `<div class="tooltip-value">${point.frac.toFixed(4)}</div>`;
            } else if (point.type === 'prime') {
                content = `<div class="tooltip-label">Prime: ${point.value}</div>`;
                content += `<div class="tooltip-value">‚â° ${point.residue} (mod ${state.modulus})</div>`;
            } else if (point.type === 'ringPoint') {
                content = `<div class="tooltip-label">${point.k}/${point.m}</div>`;
                content += `<div class="tooltip-value">gcd = ${point.gcd}</div>`;
            } else if (point.type === 'cusp') {
                content = `<div class="tooltip-label">Cusp ${point.num}/${point.den}</div>`;
                content += `<div class="tooltip-value">Re(w) = ${point.position.toFixed(4)}</div>`;
            }
            
            tooltip.innerHTML = content;
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y - 10) + 'px';
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function showPropertyPanel(point, x, y) {
            const panel = document.getElementById('propertyPanel');
            const content = document.getElementById('propertyPanelContent');
            const title = document.getElementById('propertyPanelTitle');
            
            let html = '';
            
            if (point.type === 'farey') {
                title.textContent = `Farey Point: ${point.num}/${point.den}`;
                
                html += `<div class="property-item property-highlight">
                    <div class="property-label">Fraction</div>
                    <div class="property-value">${point.num}/${point.den} = ${point.frac.toFixed(8)}</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">GCD</div>
                    <div class="property-value">gcd(${point.num}, ${point.den}) = ${gcd(point.num, point.den)}</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">Angle (Œ∏)</div>
                    <div class="property-value">${((point.angle * 180 / Math.PI) % 360).toFixed(2)}¬∞</div>
                </div>`;
                
                if (point.canvasType === 'disk') {
                    const z = { re: Math.cos(point.angle), im: Math.sin(point.angle) };
                    html += `<div class="property-item">
                        <div class="property-label">Unit Disk (z)</div>
                        <div class="property-value">z = ${z.re.toFixed(6)} + ${z.im.toFixed(6)}i</div>
                    </div>`;
                    
                    html += `<div class="property-item">
                        <div class="property-label">Magnitude</div>
                        <div class="property-value">|z| = ${Math.sqrt(z.re*z.re + z.im*z.im).toFixed(6)}</div>
                    </div>`;
                } else if (point.canvasType === 'cayley') {
                    html += `<div class="property-item">
                        <div class="property-label">Unit Disk (z)</div>
                        <div class="property-value">z = ${point.diskZ.re.toFixed(6)} + ${point.diskZ.im.toFixed(6)}i</div>
                    </div>`;
                    
                    html += `<div class="property-item property-highlight">
                        <div class="property-label">Cayley Transform (w)</div>
                        <div class="property-value">w = ${point.cayleyW.re.toFixed(6)} + ${point.cayleyW.im.toFixed(6)}i</div>
                    </div>`;
                    
                    html += `<div class="property-item">
                        <div class="property-label">Upper Half-Plane Check</div>
                        <div class="property-value">Im(w) = ${point.cayleyW.im.toFixed(6)} ${point.cayleyW.im > 0 ? '‚úì > 0' : '‚úó ‚â§ 0'}</div>
                    </div>`;
                }
                
                // Mediant property for adjacent Farey fractions
                html += `<div class="property-item">
                    <div class="property-label">Mediant Property</div>
                    <div class="property-value">Part of Farey sequence F<sub>${point.den}</sub></div>
                </div>`;
                
            } else if (point.type === 'prime') {
                title.textContent = `Prime: ${point.value}`;
                
                html += `<div class="property-item property-highlight">
                    <div class="property-label">Prime Number</div>
                    <div class="property-value">${point.value}</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">Residue Class (mod ${state.modulus})</div>
                    <div class="property-value">${point.value} ‚â° ${point.residue} (mod ${state.modulus})</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">GCD with Modulus</div>
                    <div class="property-value">gcd(${point.value}, ${state.modulus}) = ${point.gcd}</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">Coprime Status</div>
                    <div class="property-value">${point.gcd === 1 ? '‚úì Coprime to ' + state.modulus : '‚úó Not coprime to ' + state.modulus}</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">Position on Circle</div>
                    <div class="property-value">Œ∏ = ${((point.angle * 180 / Math.PI) % 360).toFixed(2)}¬∞</div>
                </div>`;
                
                // Prime index
                const primeIndex = state.primes.indexOf(point.value) + 1;
                html += `<div class="property-item">
                    <div class="property-label">Prime Index</div>
                    <div class="property-value">œÄ(${point.value}) = ${primeIndex}</div>
                </div>`;
                
            } else if (point.type === 'ringPoint') {
                title.textContent = `Ring Point: ${point.k}/${point.m}`;
                
                html += `<div class="property-item property-highlight">
                    <div class="property-label">Residue Class</div>
                    <div class="property-value">${point.k}/${point.m} = ${point.frac.toFixed(6)}</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">Modulus</div>
                    <div class="property-value">m = ${point.m}</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">Residue</div>
                    <div class="property-value">k = ${point.k}</div>
                </div>`;
                
                html += `<div class="property-item property-highlight">
                    <div class="property-label">GCD</div>
                    <div class="property-value">gcd(${point.k}, ${point.m}) = ${point.gcd}</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">Coprime Status</div>
                    <div class="property-value">${point.isCoprime ? '‚úì Unit in (‚Ñ§/' + point.m + '‚Ñ§)√ó' : '‚úó Not a unit'}</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">Euler's Totient</div>
                    <div class="property-value">œÜ(${point.m}) = ${point.phi}</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">Ring Index</div>
                    <div class="property-value">Ring #${point.ringIndex + 1} of ${state.maxRing - state.minRing + 1}</div>
                </div>`;
                
                // Count coprimes in this ring
                let coprimeCount = 0;
                for (let k = 0; k < point.m; k++) {
                    if (gcd(k, point.m) === 1) coprimeCount++;
                }
                html += `<div class="property-item">
                    <div class="property-label">Coprimes in Ring</div>
                    <div class="property-value">${coprimeCount} / ${point.m}</div>
                </div>`;
                
            } else if (point.type === 'cusp') {
                title.textContent = `Cusp: ${point.num}/${point.den}`;
                
                html += `<div class="property-item property-highlight">
                    <div class="property-label">Farey Fraction</div>
                    <div class="property-value">${point.num}/${point.den} = ${point.frac.toFixed(8)}</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">Position on Real Axis</div>
                    <div class="property-value">Re(w) = ${point.position.toFixed(6)}</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">Type</div>
                    <div class="property-value">Cusp of modular curve</div>
                </div>`;
                
                html += `<div class="property-item">
                    <div class="property-label">Boundary Point</div>
                    <div class="property-value">Im(w) = 0 (on ‚àÇ‚Ñç)</div>
                </div>`;
            }
            
            content.innerHTML = html;
            
            // Position panel near click but keep it on screen
            let panelX = x + 20;
            let panelY = y + 20;
            
            // Adjust if would go off screen
            if (panelX + 400 > window.innerWidth) {
                panelX = x - 420;
            }
            if (panelY + 500 > window.innerHeight) {
                panelY = window.innerHeight - 520;
            }
            if (panelX < 10) panelX = 10;
            if (panelY < 10) panelY = 10;
            
            panel.style.left = panelX + 'px';
            panel.style.top = panelY + 'px';
            panel.classList.add('visible');
            inspectionState.propertyPanelVisible = true;
        }

        function closePropertyPanel() {
            const panel = document.getElementById('propertyPanel');
            panel.classList.remove('visible');
            inspectionState.propertyPanelVisible = false;
            inspectionState.selectedPoint = null;
            updateAll(); // Redraw without highlight
        }

        // Add highlight rendering for selected points
        function drawSelectionHighlight(ctx, x, y, type = 'default') {
            if (!inspectionState.selectedPoint) return;
            
            ctx.save();
            
            // Pulsing glow effect
            const time = Date.now() / 1000;
            const pulse = 0.7 + 0.3 * Math.sin(time * 3);
            
            // Outer glow
            ctx.strokeStyle = type === 'farey' ? CONFIG.colors.farey : 
                             type === 'prime' ? CONFIG.colors.prime :
                             type === 'cusp' ? CONFIG.colors.cusp : 
                             CONFIG.colors.farey;
            ctx.lineWidth = 3;
            ctx.shadowBlur = 20 * pulse;
            ctx.shadowColor = ctx.strokeStyle;
            ctx.globalAlpha = pulse;
            
            ctx.beginPath();
            ctx.arc(x, y, 12, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Inner ring
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10;
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, 2 * Math.PI);
            ctx.stroke();
            
            ctx.restore();
        }

        // ============================================================
        // SAVE/LOAD CONFIGURATION SYSTEM
        // ============================================================

        function exportConfiguration() {
            const toggleStates = {};
            ['toggleFarey', 'toggleGeodesic', 'togglePrimes', 'toggleChannels',
             'toggleCusps', 'toggleRings', 'toggleGCD', 'toggleGrid',
             'toggleFundDomain', 'toggleVerticals', 'toggleDiskOutline', 
             'toggleFordCircles', 'toggleFullPlane', 'toggleAnimate',
             'toggleInvertRings', 'toggleInvertAll', 'toggleShowCoprimeOnly',
             'toggleShowNonCoprimeOnly', 'toggleShowRtoR', 'toggleShowRtoRplus2n'].forEach(id => {
                const elem = document.getElementById(id);
                if (elem) toggleStates[id] = elem.checked;
            });

            const config = {
                version: '21.0',
                timestamp: new Date().toISOString(),
                state: {
                    phase: state.phase,
                    modulus: state.modulus,
                    numPrimes: state.numPrimes,
                    primeLimit: state.primeLimit,
                    animSpeed: state.animSpeed,
                    minRing: state.minRing,
                    maxRing: state.maxRing,
                    ringSpacing: state.ringSpacing,
                    ringRotation: state.ringRotation,
                    connectionMode: state.connectionMode,
                    gcdFilter: state.gcdFilter,
                    gapSize: state.gapSize,
                    maxGap: state.maxGap,
                    connectionThickness: state.connectionThickness,
                    connectionOpacity: state.connectionOpacity,
                    labelMode: state.labelMode,
                    labelSize: state.labelSize,
                    labelFreq: state.labelFreq,
                    labelPosition: state.labelPosition,
                    labelOffset: state.labelOffset,
                    nestedColorScheme: state.nestedColorScheme,
                    cayleyHRange: state.cayleyHRange,
                    cayleyVRange: state.cayleyVRange,
                    cayleyVOffset: state.cayleyVOffset,
                    cayleyGridDensity: state.cayleyGridDensity,
                    transformType: state.transformType,
                    mobiusA: state.mobiusA,
                    mobiusB: state.mobiusB,
                    mobiusC: state.mobiusC,
                    mobiusD: state.mobiusD,
                    diskZoom: state.diskZoom,
                    cayleyZoom: state.cayleyZoom,
                    nestedZoom: state.nestedZoom,
                    ringGenerationMode: state.ringGenerationMode,
                    baseMod: state.baseMod,
                    scaleFactor: state.scaleFactor,
                    startExp: state.startExp,
                    endExp: state.endExp,
                    advancedFilterEnabled: state.advancedFilterEnabled,
                    filterGCDValue: state.filterGCDValue,
                    filterModulusRange: state.filterModulusRange,
                    filterResidueClass: state.filterResidueClass
                },
                fareyPoints: state.fareyPoints,
                toggleStates: toggleStates
            };

            const dataStr = JSON.stringify(config, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `farey-config-${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
            
            console.log('‚úì Configuration exported successfully');
        }

        function importConfiguration(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const config = JSON.parse(e.target.result);
                    
                    // Restore state
                    Object.keys(config.state).forEach(key => {
                        if (state.hasOwnProperty(key)) {
                            state[key] = config.state[key];
                        }
                    });

                    // Restore Farey points
                    if (config.fareyPoints) {
                        state.fareyPoints = config.fareyPoints;
                    }

                    // Restore toggle states
                    if (config.toggleStates) {
                        Object.keys(config.toggleStates).forEach(id => {
                            const elem = document.getElementById(id);
                            if (elem) elem.checked = config.toggleStates[id];
                        });
                    }

                    // Update all UI elements
                    syncUIWithState();
                    updateFareyPointsList();
                    regeneratePrimes();
                    updateAll();
                    
                    console.log('‚úì Configuration imported successfully');
                    alert('Configuration loaded successfully!');
                } catch (error) {
                    console.error('Error importing configuration:', error);
                    alert('Error loading configuration file. Please check the file format.');
                }
            };
            reader.readAsText(file);
        }

        function syncUIWithState() {
            document.getElementById('phaseSlider').value = state.phase;
            document.getElementById('phaseInput').value = state.phase;
            document.getElementById('phaseValue').textContent = state.phase.toFixed(1) + '¬∞';
            
            document.getElementById('modulusInput').value = state.modulus;
            document.getElementById('modulusDisplay').textContent = state.modulus;
            
            document.getElementById('primesInput').value = state.numPrimes;
            document.getElementById('primesDisplay').textContent = state.numPrimes;
            
            document.getElementById('primeLimitInput').value = state.primeLimit;
            document.getElementById('primeLimitDisplay').textContent = state.primeLimit;
            
            document.getElementById('speedSlider').value = state.animSpeed;
            document.getElementById('speedValue').textContent = state.animSpeed.toFixed(1) + '√ó';
            
            document.getElementById('minRingInput').value = state.minRing;
            document.getElementById('minRingDisplay').textContent = state.minRing;
            
            document.getElementById('maxRingInput').value = state.maxRing;
            document.getElementById('maxRingDisplay').textContent = state.maxRing;
            
            document.getElementById('spacingSlider').value = state.ringSpacing;
            document.getElementById('spacingValue').textContent = state.ringSpacing.toFixed(1);
            
            document.getElementById('ringRotationSlider').value = state.ringRotation;
            document.getElementById('ringRotationInput').value = state.ringRotation;
            document.getElementById('ringRotationValue').textContent = formatRotationValue(state.ringRotation) + '¬∞';
            
            document.getElementById('connectionMode').value = state.connectionMode;
            document.getElementById('gcdFilter').value = state.gcdFilter;
            document.getElementById('nestedColorScheme').value = state.nestedColorScheme;
            
            document.getElementById('gapSizeInput').value = state.gapSize;
            document.getElementById('gapSizeDisplay').textContent = state.gapSize;
            
            document.getElementById('maxGapInput').value = state.maxGap;
            document.getElementById('maxGapDisplay').textContent = state.maxGap;
            
            document.getElementById('connectionThicknessSlider').value = state.connectionThickness;
            document.getElementById('connectionThicknessValue').textContent = state.connectionThickness.toFixed(1);
            
            document.getElementById('connectionOpacitySlider').value = state.connectionOpacity;
            document.getElementById('connectionOpacityValue').textContent = state.connectionOpacity.toFixed(2);
            
            document.getElementById('labelMode').value = state.labelMode;
            document.getElementById('labelSizeSlider').value = state.labelSize;
            document.getElementById('labelSizeValue').textContent = state.labelSize;
            
            document.getElementById('labelFreqInput').value = state.labelFreq;
            document.getElementById('labelFreqValue').textContent = state.labelFreq;
            
            document.getElementById('labelPosition').value = state.labelPosition;
            document.getElementById('labelOffsetSlider').value = state.labelOffset;
            document.getElementById('labelOffsetValue').textContent = state.labelOffset;
            
            document.getElementById('cayleyHRangeSlider').value = state.cayleyHRange;
            document.getElementById('cayleyHRangeValue').textContent = state.cayleyHRange.toFixed(1);
            
            document.getElementById('cayleyVRangeSlider').value = state.cayleyVRange;
            document.getElementById('cayleyVRangeValue').textContent = state.cayleyVRange.toFixed(1);
            
            document.getElementById('cayleyVOffsetSlider').value = state.cayleyVOffset;
            document.getElementById('cayleyVOffsetValue').textContent = state.cayleyVOffset.toFixed(1);
            
            document.getElementById('cayleyGridDensitySlider').value = state.cayleyGridDensity;
            document.getElementById('cayleyGridDensityValue').textContent = state.cayleyGridDensity.toFixed(1);
            
            document.getElementById('cayleyTransformType').value = state.transformType;
            
            document.getElementById('mobiusA').value = state.mobiusA;
            document.getElementById('mobiusB').value = state.mobiusB;
            document.getElementById('mobiusC').value = state.mobiusC;
            document.getElementById('mobiusD').value = state.mobiusD;
            
            document.getElementById('diskZoomSlider').value = state.diskZoom;
            document.getElementById('diskZoomValue').textContent = state.diskZoom.toFixed(2) + '√ó';
            
            document.getElementById('cayleyZoomSlider').value = state.cayleyZoom;
            document.getElementById('cayleyZoomValue').textContent = state.cayleyZoom.toFixed(2) + '√ó';
            
            document.getElementById('nestedZoomSlider').value = state.nestedZoom;
            document.getElementById('nestedZoomValue').textContent = state.nestedZoom.toFixed(2) + '√ó';
            
            // Ring generation mode
            document.getElementById('ringGenerationMode').value = state.ringGenerationMode;
            if (state.ringGenerationMode === 'manual') {
                document.getElementById('manualRingControls').style.display = 'grid';
                document.getElementById('dyadicRingControls').style.display = 'none';
            } else {
                document.getElementById('manualRingControls').style.display = 'none';
                document.getElementById('dyadicRingControls').style.display = 'grid';
                
                document.getElementById('baseModInput').value = state.baseMod;
                document.getElementById('baseModDisplay').textContent = state.baseMod;
                document.getElementById('scaleFactorInput').value = state.scaleFactor;
                document.getElementById('scaleFactorDisplay').textContent = state.scaleFactor;
                document.getElementById('startExpInput').value = state.startExp;
                document.getElementById('startExpDisplay').textContent = state.startExp;
                document.getElementById('endExpInput').value = state.endExp;
                document.getElementById('endExpDisplay').textContent = state.endExp;
                
                updateRingSequence();
            }
        }

        function generateShareableURL() {
            const config = {
                p: state.phase,
                m: state.modulus,
                r: [state.minRing, state.maxRing],
                t: state.transformType,
                c: state.nestedColorScheme,
                f: state.fareyPoints.map(fp => `${fp.num}/${fp.den}`).join(',')
            };
            
            const encoded = btoa(JSON.stringify(config));
            const url = window.location.origin + window.location.pathname + '?config=' + encoded;
            
            // Copy to clipboard
            navigator.clipboard.writeText(url).then(() => {
                alert('Shareable URL copied to clipboard!\n\nAnyone can use this link to view your exact configuration.');
                console.log('Shareable URL:', url);
            }).catch(() => {
                prompt('Copy this shareable URL:', url);
            });
        }

        function loadFromURL() {
            const params = new URLSearchParams(window.location.search);
            const configParam = params.get('config');
            
            if (configParam) {
                try {
                    const config = JSON.parse(atob(configParam));
                    
                    if (config.p !== undefined) state.phase = config.p;
                    if (config.m !== undefined) state.modulus = config.m;
                    if (config.r !== undefined) {
                        state.minRing = config.r[0];
                        state.maxRing = config.r[1];
                    }
                    if (config.t !== undefined) state.transformType = config.t;
                    if (config.c !== undefined) state.nestedColorScheme = config.c;
                    if (config.f !== undefined) {
                        state.fareyPoints = config.f.split(',').map(f => {
                            const [num, den] = f.split('/').map(Number);
                            return { num, den };
                        });
                    }
                    
                    syncUIWithState();
                    updateFareyPointsList();
                    console.log('‚úì Configuration loaded from URL');
                } catch (error) {
                    console.error('Error loading configuration from URL:', error);
                }
            }
        }

        // ============================================================
        // MATHEMATICAL ANALYSIS PANEL
        // ============================================================

        function updateAnalysisPanel() {
            const panel = document.getElementById('analysisPanel');
            if (!panel || !document.getElementById('toggleAnalysis').checked) return;

            const rings = getRingSequence();
            let totalPoints = 0;
            let coprimePoints = 0;
            let gcdDistribution = {};
            
            rings.forEach(m => {
                totalPoints += m;
                const phi = eulerPhi(m);
                coprimePoints += phi;
                
                for (let k = 0; k < m; k++) {
                    const g = gcd(k, m);
                    gcdDistribution[g] = (gcdDistribution[g] || 0) + 1;
                }
            });

            // Prime statistics
            const displayedPrimes = Math.min(state.numPrimes, state.primes.length);
            let primesInClasses = 0;
            if (state.primes.length > 0) {
                primesInClasses = state.primes.slice(0, displayedPrimes)
                    .filter(p => gcd(p, state.modulus) === 1).length;
            }

            // Farey statistics
            const fareyInRange = state.fareyPoints.filter(fp => 
                fp.den >= state.minRing && fp.den <= state.maxRing
            ).length;

            const html = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div class="analysis-stat">
                        <div class="stat-label">Total Points</div>
                        <div class="stat-value">${totalPoints.toLocaleString()}</div>
                    </div>
                    <div class="analysis-stat">
                        <div class="stat-label">Coprime (GCD=1)</div>
                        <div class="stat-value">${coprimePoints.toLocaleString()}</div>
                        <div class="stat-percent">${((coprimePoints/totalPoints)*100).toFixed(1)}%</div>
                    </div>
                    <div class="analysis-stat">
                        <div class="stat-label">Total Rings</div>
                        <div class="stat-value">${rings.length}</div>
                    </div>
                    <div class="analysis-stat">
                        <div class="stat-label">Primes Shown</div>
                        <div class="stat-value">${displayedPrimes.toLocaleString()}</div>
                    </div>
                    <div class="analysis-stat">
                        <div class="stat-label">Primes Coprime to m</div>
                        <div class="stat-value">${primesInClasses}</div>
                        <div class="stat-percent">${displayedPrimes > 0 ? ((primesInClasses/displayedPrimes)*100).toFixed(1) : 0}%</div>
                    </div>
                    <div class="analysis-stat">
                        <div class="stat-label">Farey Points in Range</div>
                        <div class="stat-value">${fareyInRange}</div>
                    </div>
                    <div class="analysis-stat">
                        <div class="stat-label">œÜ(${state.modulus})</div>
                        <div class="stat-value">${eulerPhi(state.modulus)}</div>
                    </div>
                    <div class="analysis-stat">
                        <div class="stat-label">Unique GCD Values</div>
                        <div class="stat-value">${Object.keys(gcdDistribution).length}</div>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.3); border-left: 3px solid var(--cyan); border-radius: 4px;">
                    <div style="font-weight: bold; color: var(--cyan); margin-bottom: 10px;">GCD Distribution</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 10px; font-size: 0.85em;">
                        ${Object.entries(gcdDistribution)
                            .sort((a, b) => parseInt(a[0]) - parseInt(b[0]))
                            .slice(0, 10)
                            .map(([g, count]) => `
                                <span style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 3px;">
                                    GCD=${g}: ${count}
                                </span>
                            `).join('')}
                        ${Object.keys(gcdDistribution).length > 10 ? '<span>...</span>' : ''}
                    </div>
                </div>

                <div style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-left: 3px solid var(--gold); border-radius: 4px;">
                    <div style="font-weight: bold; color: var(--gold); margin-bottom: 10px;">Ring Sequence</div>
                    <div style="font-size: 0.85em; font-family: 'Fira Code', monospace; color: rgba(255,255,255,0.8);">
                        ${rings.slice(0, 20).join(', ')}${rings.length > 20 ? `, ... (${rings.length} total)` : ''}
                    </div>
                </div>
            `;

            panel.innerHTML = html;
        }

        // ============================================================
        // ADVANCED FILTER SYSTEM
        // ============================================================

        function applyAdvancedFilters(points) {
            if (!state.advancedFilterEnabled) return points;

            return points.filter(p => {
                // GCD filter
                if (state.filterGCDValue !== null && p.g !== state.filterGCDValue) {
                    return false;
                }

                // Modulus range filter
                if (p.m < state.filterModulusRange[0] || p.m > state.filterModulusRange[1]) {
                    return false;
                }

                // Residue class filter (k ‚â° r mod d)
                if (state.filterResidueClass !== null) {
                    const [r, d] = state.filterResidueClass;
                    if (p.k % d !== r % d) {
                        return false;
                    }
                }

                return true;
            });
        }

        function toggleAdvancedFilters() {
            state.advancedFilterEnabled = document.getElementById('toggleAdvancedFilters').checked;
            document.getElementById('advancedFilterPanel').style.display = 
                state.advancedFilterEnabled ? 'block' : 'none';
            updateAll();
        }

        function setFilterGCD(value) {
            state.filterGCDValue = value === '' ? null : parseInt(value);
            updateAll();
        }

        function setFilterModulusRange(min, max) {
            state.filterModulusRange = [parseInt(min), parseInt(max)];
            updateAll();
        }

        function setFilterResidueClass(r, d) {
            if (r === '' || d === '') {
                state.filterResidueClass = null;
            } else {
                state.filterResidueClass = [parseInt(r), parseInt(d)];
            }
            updateAll();
        }

        // ============================================================
        // CUSTOM MODULI LIST FUNCTIONS
        // ============================================================

        function updateCustomModuliList() {
            const list = document.getElementById('customModuliList');
            list.innerHTML = '';
            
            state.customModuli.forEach((modulus, index) => {
                const item = document.createElement('div');
                item.className = 'farey-point-item';
                
                const input = document.createElement('input');
                input.type = 'text';
                input.value = modulus;
                input.onchange = (e) => {
                    const val = parseInt(e.target.value);
                    if (!isNaN(val) && val > 0) {
                        state.customModuli[index] = val;
                        updateCustomModuliPreview();
                    }
                };
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.textContent = '‚úï';
                removeBtn.onclick = () => {
                    state.customModuli.splice(index, 1);
                    updateCustomModuliList();
                };
                
                item.appendChild(input);
                item.appendChild(removeBtn);
                list.appendChild(item);
            });
            
            document.getElementById('customCountDisplay').textContent = `${state.customModuli.length} moduli`;
            updateCustomModuliPreview();
        }

        function updateCustomModuliPreview() {
            const preview = document.getElementById('customModuliPreview');
            if (state.customModuli.length === 0) {
                preview.textContent = 'No moduli added yet';
                return;
            }
            
            const sorted = [...state.customModuli].sort((a, b) => a - b);
            const display = sorted.slice(0, 15);
            const more = sorted.length > 15 ? `, ... (${sorted.length} total)` : '';
            preview.textContent = `Sequence: [${display.join(', ')}${more}]`;
        }

        function addCustomModulus() {
            let newMod = 30;
            if (state.customModuli.length > 0) {
                const sorted = [...state.customModuli].sort((a, b) => a - b);
                newMod = sorted[sorted.length - 1] * 2;
            }
            state.customModuli.push(newMod);
            updateCustomModuliList();
        }

        function clearAllCustomModuli() {
            if (confirm('Clear all moduli?')) {
                state.customModuli = [];
                updateCustomModuliList();
            }
        }

        function loadCustomPreset(name) {
            const presets = {
                '2x2n': [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048],
                '3x2n': [3, 6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072],
                '6x2n': [6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072, 6144],
                '30x2n': [30, 60, 120, 240, 480, 960, 1920, 3840, 7680, 15360, 30720],
                '5x5n': [5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125],
                'fibonacci': [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610],
                'primes': [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47],
                'squares': [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225],
                'factorials': [1, 2, 6, 24, 120, 720, 5040]
            };
            
            if (presets[name]) {
                state.customModuli = [...presets[name]];
                updateCustomModuliList();
            }
        }

        function applyCustomModuli() {
            if (state.customModuli.length === 0) {
                alert('Please add at least one modulus');
                return;
            }
            
            // Sort and apply the custom sequence
            state.ringSequence = [...state.customModuli].sort((a, b) => a - b);
            state.minRing = Math.min(...state.ringSequence);
            state.maxRing = Math.max(...state.ringSequence);
            
            // Precompute GCDs for all moduli
            console.log('Applying custom moduli sequence:', state.ringSequence);
            state.ringSequence.forEach(m => {
                eulerPhi(m);
                for (let k = 0; k < m; k++) {
                    gcd(k, m);
                }
            });
            
            updateAll();
        }

        // ============================================================
        // RING SEQUENCE MANAGEMENT (DYADIC/P-ADIC FAMILIES)
        // ============================================================

        function updateRingSequencePreview() {
            const M0 = parseInt(document.getElementById('baseModInput').value) || 1;
            const b = parseInt(document.getElementById('scaleFactorInput').value) || 2;
            const n0 = parseInt(document.getElementById('startExpInput').value) || 0;
            const nMax = parseInt(document.getElementById('endExpInput').value) || 0;
            
            const sequence = [];
            for (let n = n0; n <= nMax; n++) {
                const modulus = M0 * Math.pow(b, n);
                sequence.push(modulus);
            }
            
            const preview = document.getElementById('ringSequencePreview');
            if (preview) {
                const displaySeq = sequence.slice(0, 15);
                const moreText = sequence.length > 15 ? `, ... (${sequence.length} total)` : '';
                const modeName = b === 2 ? 'Dyadic' : 
                               (b === 3 || b === 5) ? `${b}-adic` : 'Custom';
                preview.textContent = `${modeName}: M‚ÇÄ=${M0}, b=${b}, n=${n0}‚Üí${nMax}: [${displaySeq.join(', ')}${moreText}]`;
            }
        }

        function applyDyadicFamily() {
            // Get values from inputs
            const M0 = parseInt(document.getElementById('baseModInput').value) || 1;
            const b = parseInt(document.getElementById('scaleFactorInput').value) || 2;
            const n0 = parseInt(document.getElementById('startExpInput').value) || 0;
            const nMax = parseInt(document.getElementById('endExpInput').value) || 0;
            
            // Update state
            state.baseMod = M0;
            state.scaleFactor = b;
            state.startExp = n0;
            state.endExp = nMax;
            
            // Generate sequence
            updateRingSequence();
            
            // PRECOMPUTE all GCDs and totients for this family (FAST!)
            precomputeDyadicFamily(M0, b, n0, nMax);
            
            // NOW update the visualization (using cached values)
            console.log('Applying dyadic family:', {M0, b, n0, nMax, sequence: state.ringSequence});
            updateAll();
        }

        function setDyadicPreset(M0, b, n0, nMax) {
            // Set the input values
            document.getElementById('baseModInput').value = M0;
            document.getElementById('baseModDisplay').textContent = M0;
            document.getElementById('scaleFactorInput').value = b;
            document.getElementById('scaleFactorDisplay').textContent = b;
            document.getElementById('startExpInput').value = n0;
            document.getElementById('startExpDisplay').textContent = n0;
            document.getElementById('endExpInput').value = nMax;
            document.getElementById('endExpDisplay').textContent = nMax;
            
            // Update preview
            updateRingSequencePreview();
            
            // DON'T apply yet - let user click the APPLY button
        }

        function getRingSequence() {
            if (state.ringGenerationMode === 'manual' || !state.ringSequence) {
                const rings = [];
                for (let m = state.minRing; m <= state.maxRing; m++) {
                    rings.push(m);
                }
                return rings;
            } else if (state.ringGenerationMode === 'customlist') {
                // Return sorted custom moduli
                return state.ringSequence || [];
            } else {
                return state.ringSequence;
            }
        }

        function updateRingSequence() {
            if (state.ringGenerationMode === 'manual') {
                state.ringSequence = null;
                return;
            }
            
            const M0 = state.baseMod;
            const b = state.scaleFactor;
            const n0 = state.startExp;
            const nMax = state.endExp;
            
            const sequence = [];
            for (let n = n0; n <= nMax; n++) {
                const modulus = M0 * Math.pow(b, n);
                sequence.push(modulus);
            }
            
            state.ringSequence = sequence;
            
            // Update min and max ring to match sequence
            if (sequence.length > 0) {
                state.minRing = Math.min(...sequence);
                state.maxRing = Math.max(...sequence);
                document.getElementById('minRingDisplay').textContent = state.minRing;
                document.getElementById('maxRingDisplay').textContent = state.maxRing;
            }
        }

        // ============================================================
        // ADVANCED FILTERING SYSTEM
        // ============================================================

        function toggleAdvancedFilter() {
            const panel = document.getElementById('filterPanel');
            const toggle = document.getElementById('filterToggle');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                panel.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        function applyFilters() {
            state.filters.enabled = true;
            updateAll();
        }

        function clearFilters() {
            state.filters = {
                enabled: false,
                gcdValue: null,
                modRange: [null, null],
                residueClass: null
            };
            
            document.getElementById('filterGCD').value = '';
            document.getElementById('filterModMin').value = '';
            document.getElementById('filterModMax').value = '';
            document.getElementById('filterResClass').value = '';
            document.getElementById('filterResMod').value = '';
            
            updateAll();
        }

        function passesFilter(k, m, g) {
            if (!state.filters.enabled) return true;
            
            // GCD filter
            if (state.filters.gcdValue !== null && g !== state.filters.gcdValue) {
                return false;
            }
            
            // Modulus range filter
            const [minMod, maxMod] = state.filters.modRange;
            if (minMod !== null && m < minMod) return false;
            if (maxMod !== null && m > maxMod) return false;
            
            // Residue class filter
            if (state.filters.residueClass) {
                const [r, d] = state.filters.residueClass;
                if (r !== null && d !== null && d > 0) {
                    if (k % d !== r % d) return false;
                }
            }
            
            return true;
        }

        // ============================================================
        // ANIMATION & RECORDING SYSTEM
        // ============================================================

        function toggleAnimationPanel() {
            const panel = document.getElementById('animationPanel');
            const toggle = document.getElementById('animToggle');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                panel.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        function startRecording() {
            if (state.animation.recording) {
                stopRecording();
                return;
            }
            
            state.animation.recording = true;
            state.animation.frames = [];
            
            const btn = document.getElementById('recordBtn');
            btn.querySelector('span').textContent = 'Stop Recording';
            btn.classList.add('btn-accent');
            
            const status = document.getElementById('recordingStatus');
            status.style.display = 'block';
            
            const totalFrames = state.animation.fps * state.animation.duration;
            let currentFrame = 0;
            
            const recordFrame = () => {
                if (!state.animation.recording || currentFrame >= totalFrames) {
                    stopRecording();
                    return;
                }
                
                // Apply animation transformation
                switch(state.animation.mode) {
                    case 'rotate':
                        state.phase = (state.phase + 360 / totalFrames) % 360;
                        break;
                    case 'zoom':
                        const zoomPhase = currentFrame / totalFrames;
                        state.nestedZoom = 1 + Math.sin(zoomPhase * Math.PI * 2) * 0.5;
                        break;
                    case 'pulse':
                        const pulsePhase = currentFrame / totalFrames;
                        state.ringSpacing = 1 + Math.sin(pulsePhase * Math.PI * 4) * 0.3;
                        break;
                    case 'spiral':
                        state.phase = (state.phase + 360 / totalFrames) % 360;
                        state.ringRotation = (state.ringRotation + 10) % 360;
                        break;
                }
                
                updateAll();
                
                // Capture frame from selected canvas with optional legend
                const canvasSelection = document.getElementById('recordCanvas').value;
                const includeLegend = document.getElementById('recordWithLegend').checked;
                
                let dataURL;
                
                if (canvasSelection === 'all') {
                    // Create composite frame with all 5 canvases
                    dataURL = captureCompositeFrame(includeLegend);
                } else {
                    // Single canvas capture
                    let sourceCanvas;
                    let canvasType;
                    switch(canvasSelection) {
                        case 'disk':
                            sourceCanvas = canvases.disk;
                            canvasType = 'disk';
                            break;
                        case 'cayley':
                            sourceCanvas = canvases.cayley;
                            canvasType = 'cayley';
                            break;
                        case 'nested':
                            sourceCanvas = canvases.nested;
                            canvasType = 'nested';
                            break;
                        case 'reduction':
                            sourceCanvas = canvases.reduction;
                            canvasType = 'reduction';
                            break;
                        case 'fullplane':
                            sourceCanvas = canvases.fullPlane;
                            canvasType = 'fullplane';
                            break;
                        default:
                            sourceCanvas = canvases.nested;
                            canvasType = 'nested';
                    }
                    
                    if (includeLegend) {
                        dataURL = captureSingleFrameWithLegend(sourceCanvas, canvasType);
                    } else {
                        dataURL = sourceCanvas.toDataURL('image/png');
                    }
                }
                
                state.animation.frames.push(dataURL);
                
                currentFrame++;
                document.getElementById('frameCount').textContent = currentFrame;
                
                setTimeout(recordFrame, 1000 / state.animation.fps);
            };
            
            recordFrame();
        }

        function stopRecording() {
            state.animation.recording = false;
            
            const btn = document.getElementById('recordBtn');
            btn.querySelector('span').textContent = 'Start Recording Frames';
            btn.classList.remove('btn-accent');
            
            if (state.animation.frames.length > 0) {
                downloadFrames();
            }
        }

        function captureSingleFrameWithLegend(sourceCanvas, canvasType) {
            // Create temporary canvas for composite
            const baseSize = Math.max(sourceCanvas.width, sourceCanvas.height);
            const legendSpace = 250;
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCanvas.width = baseSize + legendSpace;
            tempCanvas.height = baseSize;
            
            // Background
            tempCtx.fillStyle = '#0a0e27';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Draw source canvas on left (square)
            tempCtx.drawImage(sourceCanvas, 0, 0, baseSize, baseSize);
            
            // Draw legend on right
            drawLegendRight(tempCtx, tempCanvas.width, tempCanvas.height, baseSize, canvasType);
            
            return tempCanvas.toDataURL('image/png');
        }

        function captureCompositeFrame(includeLegend) {
            // Create 2√ó3 grid layout for all 5 canvases
            const maxDim = Math.max(
                canvases.disk.width, canvases.disk.height,
                canvases.cayley.width, canvases.cayley.height,
                canvases.nested.width, canvases.nested.height,
                canvases.reduction.width, canvases.reduction.height,
                canvases.fullPlane.width, canvases.fullPlane.height
            );
            
            // 2 rows √ó 3 columns layout
            const cols = 3;
            const rows = 2;
            const baseWidth = maxDim * cols;
            const baseHeight = maxDim * rows;
            const legendSpace = includeLegend ? 300 : 0;
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCanvas.width = baseWidth + legendSpace;
            tempCanvas.height = baseHeight;
            
            // Background
            tempCtx.fillStyle = '#0a0e27';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            const canvasSize = maxDim;
            
            // Draw 5 canvases in 2√ó3 grid layout:
            // Row 1: Disk | Cayley | Nested
            // Row 2: Reduction | Full Plane | (empty)
            const sources = [
                { canvas: canvases.disk, title: 'Unit Disk ùîª', x: 0, y: 0 },
                { canvas: canvases.cayley, title: 'Upper Half-Plane ‚Ñç', x: canvasSize, y: 0 },
                { canvas: canvases.nested, title: 'Nested Rings ‚äö', x: canvasSize * 2, y: 0 },
                { canvas: canvases.reduction, title: 'Modular Reduction ‚äó', x: 0, y: canvasSize },
                { canvas: canvases.fullPlane, title: 'Full Complex Plane ‚ÑÇ', x: canvasSize, y: canvasSize }
            ];
            
            sources.forEach(item => {
                tempCtx.drawImage(item.canvas, 
                    0, 0, item.canvas.width, item.canvas.height,
                    item.x, item.y, canvasSize, canvasSize);
                
                // Draw title
                const scale = baseWidth / 2880; // Adjusted for 3 columns
                const fontSize = 18 * scale;
                const titleY = item.y + 20 * scale;
                const titleX = item.x + canvasSize / 2;
                
                tempCtx.fillStyle = '#ffd700';
                tempCtx.font = `bold ${fontSize}px "Fira Code"`;
                tempCtx.textAlign = 'center';
                tempCtx.textBaseline = 'top';
                tempCtx.shadowBlur = 8 * scale;
                tempCtx.shadowColor = 'rgba(255, 215, 0, 0.4)';
                tempCtx.fillText(item.title, titleX, titleY);
                tempCtx.shadowBlur = 0;
            });
            
            // Draw legend on right if enabled
            if (includeLegend) {
                drawLegendRight(tempCtx, tempCanvas.width, tempCanvas.height, baseWidth, 'all');
            }
            
            return tempCanvas.toDataURL('image/png');
        }

        function downloadFrames() {
            const frameCount = state.animation.frames.length;
            
            if (frameCount === 0) {
                alert('No frames to download!');
                return;
            }
            
            // Show progress
            const status = document.getElementById('recordingStatus');
            status.innerHTML = `Creating zip file with ${frameCount} frames...`;
            
            // Use JSZip to create a zip file
            // Load JSZip from CDN if not already loaded
            if (typeof JSZip === 'undefined') {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                script.onload = () => createZipFile(frameCount);
                document.head.appendChild(script);
            } else {
                createZipFile(frameCount);
            }
        }
        
        function createZipFile(frameCount) {
            const zip = new JSZip();
            
            // Add manifest file
            const manifest = {
                frameCount: state.animation.frames.length,
                fps: state.animation.fps,
                duration: state.animation.duration,
                mode: state.animation.mode,
                canvas: document.getElementById('recordCanvas').value,
                timestamp: new Date().toISOString(),
                instructions: 'Use ffmpeg to create video: ffmpeg -framerate [fps] -i frame_%04d.png -c:v libx264 -pix_fmt yuv420p output.mp4'
            };
            
            zip.file('manifest.json', JSON.stringify(manifest, null, 2));
            
            // Add README
            const readme = `Animation Frames Export
========================

Frame Count: ${state.animation.frames.length}
FPS: ${state.animation.fps}
Duration: ${state.animation.duration} seconds
Mode: ${state.animation.mode}
Canvas: ${document.getElementById('recordCanvas').value}

To create a video with ffmpeg:
------------------------------
ffmpeg -framerate ${state.animation.fps} -i frame_%04d.png -c:v libx264 -pix_fmt yuv420p -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" output.mp4

Or for GIF:
-----------
ffmpeg -framerate ${state.animation.fps} -i frame_%04d.png -vf "fps=${state.animation.fps},scale=800:-1:flags=lanczos" output.gif

Generated: ${new Date().toLocaleString()}
`;
            
            zip.file('README.txt', readme);
            
            // Add all frames
            state.animation.frames.forEach((dataURL, index) => {
                // Convert data URL to blob
                const base64Data = dataURL.split(',')[1];
                const frameNumber = String(index + 1).padStart(4, '0');
                zip.file(`frame_${frameNumber}.png`, base64Data, {base64: true});
            });
            
            // Generate and download zip
            const status = document.getElementById('recordingStatus');
            status.innerHTML = `Generating zip file...`;
            
            zip.generateAsync({
                type: 'blob',
                compression: 'DEFLATE',
                compressionOptions: { level: 6 }
            }).then(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `animation-${state.animation.mode}-${frameCount}frames-${Date.now()}.zip`;
                a.click();
                URL.revokeObjectURL(url);
                
                status.innerHTML = `‚úì Downloaded ${frameCount} frames in zip file!`;
                setTimeout(() => {
                    status.style.display = 'none';
                    status.innerHTML = 'Recording: <span id="frameCount">0</span> frames captured';
                }, 3000);
                
                // Reset
                state.animation.frames = [];
            }).catch(function(error) {
                console.error('Error creating zip:', error);
                alert('Error creating zip file. Check console for details.');
                status.innerHTML = 'Error creating zip file';
            });
        }

        function downloadFrame(dataURL, filename) {
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = filename;
            a.click();
        }

        // ============================================================
        // STATISTICAL ANALYSIS
        // ============================================================

        function toggleStats() {
            const panel = document.getElementById('statsPanel');
            const toggle = document.getElementById('statsToggle');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                toggle.textContent = '‚ñº';
                updateStats();
            } else {
                panel.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        function updateStats() {
            const rings = getRingSequence();
            let totalPoints = 0;
            let coprimePoints = 0;
            const gcdDist = {};
            
            rings.forEach(m => {
                totalPoints += m;
                const phi = eulerPhi(m);
                coprimePoints += phi;
                
                for (let k = 0; k < m; k++) {
                    const g = gcd(k, m);
                    gcdDist[g] = (gcdDist[g] || 0) + 1;
                }
            });

            const primeCount = Math.min(state.numPrimes, state.primes.length);
            const coprimePrimes = state.primes.slice(0, primeCount).filter(p => gcd(p, state.modulus) === 1).length;
            const fareyInRange = state.fareyPoints.filter(fp => fp.den >= state.minRing && fp.den <= state.maxRing).length;

            const html = `
                <div class="stat-card">
                    <div class="stat-label">Total Points</div>
                    <div class="stat-value">${totalPoints.toLocaleString()}</div>
                    <div class="stat-subtext">${rings.length} rings</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Coprime (GCD=1)</div>
                    <div class="stat-value">${coprimePoints.toLocaleString()}</div>
                    <div class="stat-subtext">${((coprimePoints/totalPoints)*100).toFixed(1)}%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Primes Shown</div>
                    <div class="stat-value">${primeCount}</div>
                    <div class="stat-subtext">${coprimePrimes} coprime to m</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">œÜ(${state.modulus})</div>
                    <div class="stat-value">${eulerPhi(state.modulus)}</div>
                    <div class="stat-subtext">Euler totient</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Farey Points</div>
                    <div class="stat-value">${state.fareyPoints.length}</div>
                    <div class="stat-subtext">${fareyInRange} in range</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">GCD Values</div>
                    <div class="stat-value">${Object.keys(gcdDist).length}</div>
                    <div class="stat-subtext">unique divisors</div>
                </div>
            `;
            
            document.getElementById('statsContent').innerHTML = html;
        }

        // ============================================================
        // SAVE/LOAD CONFIGURATION
        // ============================================================

        function exportConfig() {
            const config = {
                version: '3.0',
                timestamp: new Date().toISOString(),
                metadata: {
                    totalPoints: 0,
                    coprimePoints: 0,
                    ringCount: 0,
                    fareyCount: state.fareyPoints.length,
                    primeCount: Math.min(state.numPrimes, state.primes.length)
                },
                state: {
                    phase: state.phase,
                    modulus: state.modulus,
                    numPrimes: state.numPrimes,
                    primeLimit: state.primeLimit,
                    minRing: state.minRing,
                    maxRing: state.maxRing,
                    ringSpacing: state.ringSpacing,
                    ringRotation: state.ringRotation,
                    connectionMode: state.connectionMode,
                    gcdFilter: state.gcdFilter,
                    gapSize: state.gapSize,
                    connectionThickness: state.connectionThickness,
                    connectionOpacity: state.connectionOpacity,
                    labelMode: state.labelMode,
                    labelSize: state.labelSize,
                    labelFreq: state.labelFreq,
                    labelPosition: state.labelPosition,
                    labelOffset: state.labelOffset,
                    nestedColorScheme: state.nestedColorScheme,
                    cayleyHRange: state.cayleyHRange,
                    cayleyVRange: state.cayleyVRange,
                    cayleyVOffset: state.cayleyVOffset,
                    cayleyGridDensity: state.cayleyGridDensity,
                    transformType: state.transformType,
                    diskZoom: state.diskZoom,
                    cayleyZoom: state.cayleyZoom,
                    nestedZoom: state.nestedZoom,
                    ringGenerationMode: state.ringGenerationMode,
                    baseMod: state.baseMod,
                    scaleFactor: state.scaleFactor,
                    startExp: state.startExp,
                    endExp: state.endExp,
                    customModuli: state.customModuli
                },
                filters: state.filters,
                animation: {
                    mode: state.animation.mode,
                    fps: state.animation.fps,
                    duration: state.animation.duration
                },
                fareyPoints: state.fareyPoints,
                toggles: {
                    farey: document.getElementById('toggleFarey').checked,
                    geodesic: document.getElementById('toggleGeodesic').checked,
                    primes: document.getElementById('togglePrimes').checked,
                    channels: document.getElementById('toggleChannels').checked,
                    cusps: document.getElementById('toggleCusps').checked,
                    rings: document.getElementById('toggleRings').checked,
                    gcd: document.getElementById('toggleGCD').checked,
                    grid: document.getElementById('toggleGrid').checked,
                    fundDomain: document.getElementById('toggleFundDomain').checked,
                    verticals: document.getElementById('toggleVerticals').checked,
                    diskOutline: document.getElementById('toggleDiskOutline').checked,
                    fordCircles: document.getElementById('toggleFordCircles').checked,
                    fullPlane: document.getElementById('toggleFullPlane').checked,
                    invertRings: document.getElementById('toggleInvertRings').checked,
                    invertAll: document.getElementById('toggleInvertAll').checked,
                    showCoprimeOnly: document.getElementById('toggleShowCoprimeOnly').checked,
                    showNonCoprimeOnly: document.getElementById('toggleShowNonCoprimeOnly').checked,
                    showRtoR: document.getElementById('toggleShowRtoR').checked,
                    showRtoRplus2n: document.getElementById('toggleShowRtoRplus2n').checked
                }
            };

            // Calculate metadata
            const rings = getRingSequence();
            rings.forEach(m => {
                config.metadata.totalPoints += m;
                config.metadata.coprimePoints += eulerPhi(m);
            });
            config.metadata.ringCount = rings.length;

            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `farey-config-v3-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importConfig(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const config = JSON.parse(e.target.result);
                    
                    // Import state
                    if (config.state) {
                        Object.assign(state, config.state);
                    }
                    
                    // Import filters
                    if (config.filters) {
                        state.filters = config.filters;
                    }
                    
                    // Import animation settings
                    if (config.animation) {
                        Object.assign(state.animation, config.animation);
                    }
                    
                    // Import Farey points
                    if (config.fareyPoints) {
                        state.fareyPoints = config.fareyPoints;
                    }
                    
                    // Import toggles
                    if (config.toggles) {
                        Object.entries(config.toggles).forEach(([key, val]) => {
                            const el = document.getElementById('toggle' + key.charAt(0).toUpperCase() + key.slice(1));
                            if (el) el.checked = val;
                        });
                    }
                    
                    syncUIFromState();
                    regeneratePrimes();
                    updateAll();
                    
                    // Show metadata if available
                    if (config.metadata) {
                        console.log('Loaded configuration metadata:', config.metadata);
                    }
                    
                    alert('Configuration loaded successfully!');
                } catch (err) {
                    alert('Error loading config: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function syncUIFromState() {
            document.getElementById('phaseSlider').value = state.phase;
            document.getElementById('phaseInput').value = state.phase;
            document.getElementById('modulusInput').value = state.modulus;
            document.getElementById('minRingInput').value = state.minRing;
            document.getElementById('maxRingInput').value = state.maxRing;
            document.getElementById('connectionMode').value = state.connectionMode;
            document.getElementById('labelMode').value = state.labelMode;
            document.getElementById('nestedColorScheme').value = state.nestedColorScheme;
            document.getElementById('cayleyTransformType').value = state.transformType;
            document.getElementById('ringGenerationMode').value = state.ringGenerationMode;
            
            updateFareyPointsList();
            if (state.customModuli.length > 0) {
                updateCustomModuliList();
            }
        }

        // ============================================================
        // MATHEMATICAL FUNCTIONS WITH CACHING
        // ============================================================

        // Cache for GCD computations
        const gcdCache = new Map();
        const phiCache = new Map();

        function sieve(limit) {
            const isPrime = new Array(limit + 1).fill(true);
            isPrime[0] = isPrime[1] = false;
            
            for (let i = 2; i * i <= limit; i++) {
                if (isPrime[i]) {
                    for (let j = i * i; j <= limit; j += i) {
                        isPrime[j] = false;
                    }
                }
            }
            
            return isPrime.map((v, i) => v ? i : null).filter(v => v !== null);
        }

        function regeneratePrimes() {
            state.primes = sieve(state.primeLimit);
            updateAll();
        }

        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            
            // Use cache for repeated computations
            const key = `${a},${b}`;
            if (gcdCache.has(key)) {
                return gcdCache.get(key);
            }
            
            let origA = a, origB = b;
            while (b) [a, b] = [b, a % b];
            
            gcdCache.set(key, a);
            gcdCache.set(`${origB},${origA}`, a); // Symmetric cache
            
            return a;
        }

        function primeFactorization(n) {
            const factors = {};
            let temp = n;
            for (let i = 2; i <= temp; i++) {
                while (temp % i === 0) {
                    factors[i] = (factors[i] || 0) + 1;
                    temp /= i;
                }
            }
            return factors;
        }

        function formatPrimeFactorization(n) {
            if (n === 1) return '1';
            const factors = primeFactorization(n);
            const parts = [];
            const superscripts = ['‚Å∞','¬π','¬≤','¬≥','‚Å¥','‚Åµ','‚Å∂','‚Å∑','‚Å∏','‚Åπ'];
            
            for (const [prime, power] of Object.entries(factors)) {
                if (power === 1) {
                    parts.push(prime);
                } else {
                    let powerStr = '';
                    String(power).split('').forEach(digit => {
                        powerStr += superscripts[parseInt(digit)];
                    });
                    parts.push(`${prime}${powerStr}`);
                }
            }
            return parts.join('√ó') || '1';
        }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i * i <= n; i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }

        function updateGlobalLineThickness(value) {
            state.globalLineThickness = parseFloat(value);
            document.getElementById('globalLineThicknessValue').textContent = parseFloat(value).toFixed(2);
            updateAll();
        }

        function applyAnglePreset(value) {
            if (!value) return; // Empty selection
            
            const angle = parseFloat(value);
            state.phase = angle;
            
            // Update all controls
            document.getElementById('phaseSlider').value = angle;
            document.getElementById('phaseInput').value = angle;
            document.getElementById('phaseValue').textContent = angle.toFixed(17) + '¬∞';
            
            // Reset dropdown to placeholder
            document.getElementById('anglePresets').value = '';
            
            updateAll();
        }

        // Check if a point passes the advanced filters
        function passesFilters(num, den) {
            if (!state.filters.enabled) return true;
            
            // GCD filter
            if (state.filters.gcdValue !== null) {
                const g = gcd(num, den);
                if (g !== state.filters.gcdValue) return false;
            }
            
            // Modulus range filter
            if (state.filters.modRange[0] !== null && den < state.filters.modRange[0]) {
                return false;
            }
            if (state.filters.modRange[1] !== null && den > state.filters.modRange[1]) {
                return false;
            }
            
            return true;
        }

        function eulerPhi(n) {
            // Check cache first
            if (phiCache.has(n)) {
                return phiCache.get(n);
            }
            
            let result = n;
            let temp = n;
            for (let p = 2; p * p <= temp; p++) {
                if (temp % p === 0) {
                    while (temp % p === 0) temp /= p;
                    result -= result / p;
                }
            }
            if (temp > 1) result -= result / temp;
            
            const phi = Math.round(result);
            phiCache.set(n, phi);
            
            return phi;
        }

        // Alias for eulerPhi - used by new canvases 7-12
        const phi = eulerPhi;

        // Pre-compute GCDs and Phi for dyadic families
        function precomputeDyadicFamily(M0, b, n0, nMax) {
            console.log('Precomputing GCDs and totients for dyadic family...');
            const startTime = performance.now();
            
            for (let n = n0; n <= nMax; n++) {
                const m = M0 * Math.pow(b, n);
                
                // Precompute phi(m)
                eulerPhi(m);
                
                // Precompute gcd(k, m) for all k in [0, m)
                for (let k = 0; k < m; k++) {
                    gcd(k, m);
                }
            }
            
            const endTime = performance.now();
            console.log(`Precomputation complete in ${(endTime - startTime).toFixed(2)}ms`);
            console.log(`Cache size - GCD: ${gcdCache.size}, Phi: ${phiCache.size}`);
        }

        function cayleyTransform(z, transformType = 'standard') {
            if (transformType === 'alternate') {
                // Alternate (inverse form): w = i(1-z)/(1+z)
                // Maps unit disk to upper half-plane with different orientation
                const numRe = 1 - z.re;   // Real part of (1-z)
                const numIm = -z.im;      // Imaginary part of (1-z)
                const denRe = 1 + z.re;   // Real part of (1+z)
                const denIm = z.im;       // Imaginary part of (1+z)
                
                const denMagSq = denRe * denRe + denIm * denIm;
                
                if (denMagSq < 1e-10) {
                    return { re: 0, im: 1e10 };
                }
                
                // Compute (1-z)/(1+z)
                const quotRe = (numRe * denRe + numIm * denIm) / denMagSq;
                const quotIm = (numIm * denRe - numRe * denIm) / denMagSq;
                
                // Multiply by i: i*(a+bi) = -b + ai
                return { re: -quotIm, im: quotRe };
            }
            
            if (transformType === 'ftt') {
                // FTT Transform: w = (z-i)/(z+i)
                // This is the INVERSE of the standard Cayley transform
                // Maps upper half-plane ‚Üí unit disk
                const numRe = z.re;       // Real part of (z-i)
                const numIm = z.im - 1;   // Imaginary part of (z-i)
                const denRe = z.re;       // Real part of (z+i)
                const denIm = z.im + 1;   // Imaginary part of (z+i)
                
                const denMagSq = denRe * denRe + denIm * denIm;
                
                if (denMagSq < 1e-10) {
                    return { re: 1e10, im: 0 };
                }
                
                const quotRe = (numRe * denRe + numIm * denIm) / denMagSq;
                const quotIm = (numIm * denRe - numRe * denIm) / denMagSq;
                
                return { re: quotRe, im: quotIm };
            }
            
            if (transformType === 'smith') {
                // Smith Chart mapping: w = (z-1)/(z+1)
                // Used in RF/microwave engineering for impedance
                const numRe = z.re - 1;
                const numIm = z.im;
                const denRe = z.re + 1;
                const denIm = z.im;
                
                const denMagSq = denRe * denRe + denIm * denIm;
                
                if (denMagSq < 1e-10) {
                    return { re: 1e10, im: 0 };
                }
                
                const quotRe = (numRe * denRe + numIm * denIm) / denMagSq;
                const quotIm = (numIm * denRe - numRe * denIm) / denMagSq;
                
                return { re: quotRe, im: quotIm };
            }
            
            if (transformType === 'mobius') {
                // General M√∂bius transform: w = (az+b)/(cz+d)
                const a = state.mobiusA;
                const b = state.mobiusB;
                const c = state.mobiusC;
                const d = state.mobiusD;
                
                // Check constraint: ad - bc ‚â† 0
                const det = a * d - b * c;
                if (Math.abs(det) < 1e-10) {
                    console.warn('M√∂bius determinant too small, using identity');
                    return z;
                }
                
                // Numerator: az + b
                const numRe = a * z.re + b;
                const numIm = a * z.im;
                
                // Denominator: cz + d
                const denRe = c * z.re + d;
                const denIm = c * z.im;
                
                const denMagSq = denRe * denRe + denIm * denIm;
                
                if (denMagSq < 1e-10) {
                    return { re: 1e10 * Math.sign(numRe), im: 1e10 * Math.sign(numIm) };
                }
                
                const quotRe = (numRe * denRe + numIm * denIm) / denMagSq;
                const quotIm = (numIm * denRe - numRe * denIm) / denMagSq;
                
                return { re: quotRe, im: quotIm };
            }
            
            // Standard Cayley transform: w = i(1+z)/(1-z)
            // Maps unit disk to upper half-plane
            const numRe = 1 + z.re;   // Real part of (1+z)
            const numIm = z.im;       // Imaginary part of (1+z)
            const denRe = 1 - z.re;   // Real part of (1-z)
            const denIm = -z.im;      // Imaginary part of (1-z)
            
            const denMagSq = denRe * denRe + denIm * denIm;
            
            if (denMagSq < 1e-10) {
                return { re: 0, im: 1e10 };
            }
            
            // Compute (1-z)/(1+z)
            const quotRe = (numRe * denRe + numIm * denIm) / denMagSq;
            const quotIm = (numIm * denRe - numRe * denIm) / denMagSq;
            
            // Multiply by i: i*(a+bi) = -b + ai
            return { re: -quotIm, im: quotRe };
        }

        function generateColors(n) {
            const colors = [];
            const goldenRatio = 0.618033988749895;
            for (let i = 0; i < n; i++) {
                const hue = (i * goldenRatio * 360) % 360;
                colors.push(`hsla(${hue}, 85%, 65%, 0.9)`);
            }
            return colors;
        }

        function getGCDColor(g, m) {
            if (g === 1) return CONFIG.colors.farey;
            if (g === m) return '#e74c3c';
            if (g === 2) return '#00ffff';
            if (g === 3) return '#9b59b6';
            
            const hue = (g * 60) % 360;
            return `hsla(${hue}, 70%, 60%, 0.85)`;
        }

        function getNestedPointColor(k, m, g, angle) {
            const scheme = state.nestedColorScheme;
            
            switch(scheme) {
                case 'gcd':
                    // Default: Color by GCD value
                    return getGCDColor(g, m);
                
                case 'coprime':
                    // Binary: Gold for coprime, Gray for non-coprime
                    return g === 1 ? CONFIG.colors.farey : 'rgba(150, 150, 150, 0.7)';
                
                case 'rainbow':
                    // Rainbow based on angle position
                    const hue = (angle * 180 / Math.PI) % 360;
                    return `hsla(${hue}, 85%, ${g === 1 ? '65%' : '45%'}, 0.9)`;
                
                case 'ring':
                    // Color by which ring (modulus)
                    const ringHue = (m * 137.508) % 360; // Golden angle for distribution
                    return `hsla(${ringHue}, 75%, ${g === 1 ? '65%' : '50%'}, 0.85)`;
                
                case 'prime':
                    // Color by prime factorization of k
                    if (k === 0) return 'rgba(100, 100, 100, 0.7)';
                    if (isPrime(k)) return '#3498db'; // Blue for primes
                    
                    // Color by smallest prime factor
                    const smallestPrime = getSmallestPrimeFactor(k);
                    const primeHue = (smallestPrime * 73) % 360;
                    return `hsla(${primeHue}, 80%, 60%, 0.85)`;
                
                case 'totient':
                    // Color by totient class - how many coprimes
                    const phi = eulerPhi(m);
                    const ratio = phi / m;
                    const totientHue = ratio * 120; // 0-120 (red to green)
                    return g === 1 ? 
                        `hsla(${totientHue}, 80%, 65%, 0.9)` : 
                        `hsla(${totientHue}, 40%, 40%, 0.6)`;
                
                case 'monochrome':
                    // All gold with varying opacity
                    const opacity = g === 1 ? 0.9 : 0.3;
                    return `rgba(255, 215, 0, ${opacity})`;
                
                // Advanced gradient schemes
                case 'default':
                case 'fire':
                case 'plasma':
                case 'viridis':
                case 'cool':
                case 'thermal':
                case 'ocean':
                case 'sunset':
                case 'forest':
                case 'rainbow':
                case 'grayscale':
                    // Use angle position normalized to 0-1 for gradient
                    const t = (angle / (2 * Math.PI) + 1) % 1;
                    const color = getColorFromScheme(scheme, t);
                    // Adjust opacity based on GCD
                    const gradientOpacity = g === 1 ? 0.95 : 0.5;
                    return `rgba(${color.r}, ${color.g}, ${color.b}, ${gradientOpacity})`;
                
                default:
                    return getGCDColor(g, m);
            }
        }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i * i <= n; i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }

        function getSmallestPrimeFactor(n) {
            if (n < 2) return n;
            if (n % 2 === 0) return 2;
            for (let i = 3; i * i <= n; i += 2) {
                if (n % i === 0) return i;
            }
            return n; // n is prime
        }

        // ============================================================
        // DRAWING FUNCTIONS
        // ============================================================

        function drawDisk() {
            const canvas = canvases.disk;
            const ctx = canvases.diskCtx;
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            const cx = w / 2;
            const cy = h / 2;
            const r = Math.min(w, h) * CONFIG.diskRadius * state.diskZoom;

            ctx.clearRect(0, 0, w, h);

            // Apply inversion if enabled
            const invertAll = document.getElementById('toggleInvertAll').checked;
            if (invertAll) {
                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(-1, -1);
                ctx.translate(-cx, -cy);
            }

            // Grid
            if (document.getElementById('toggleGrid').checked) {
                ctx.strokeStyle = CONFIG.colors.grid;
                ctx.lineWidth = 0.5;
                for (let i = -10; i <= 10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(cx + i * r / 5, 0);
                    ctx.lineTo(cx + i * r / 5, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, cy + i * r / 5);
                    ctx.lineTo(w, cy + i * r / 5);
                    ctx.stroke();
                }
            }

            // Axes
            ctx.strokeStyle = CONFIG.colors.axes;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(w, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, h);
            ctx.stroke();

            // Unit circle
            ctx.strokeStyle = CONFIG.colors.disk;
            ctx.lineWidth = 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = CONFIG.colors.disk;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.shadowBlur = 0;

            const phase = state.phase * Math.PI / 180;
            const showPrimes = document.getElementById('togglePrimes').checked;
            const showChannels = document.getElementById('toggleChannels').checked;
            const showFarey = document.getElementById('toggleFarey').checked;

            // Primes
            if (showPrimes) {
                const colors = generateColors(state.modulus);
                const displayPrimes = state.primes.slice(0, state.numPrimes);

                displayPrimes.forEach(p => {
                    if (showChannels && gcd(p, state.modulus) !== 1) return;

                    // Apply per-ring rotation if presets are set
                    let perRingOffset = 0;
                    const m = state.modulus;
                    if (state.perRingRotations && state.perRingRotations[m] !== undefined) {
                        perRingOffset = state.perRingRotations[m] * Math.PI / 180;
                    } else {
                        perRingOffset = state.ringRotation * Math.PI / 180;
                    }

                    // Use sequential or angular plotting
                    const baseAngle = 2 * Math.PI * p / state.modulus;
                    const angle = getPlotAngle(p, state.modulus, baseAngle, perRingOffset);
                    const x = cx + r * Math.cos(angle);
                    const y = cy + r * Math.sin(angle);

                    const color = showChannels ? colors[p % state.modulus] : CONFIG.colors.prime;
                    
                    ctx.fillStyle = color;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = color;
                    ctx.beginPath();
                    ctx.arc(x, y, 3.5, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });
            }

            // Farey triangle
            if (showFarey && state.fareyPoints.length >= 2) {
                const fareyPoints = state.fareyPoints
                    .filter(fp => passesFilters(fp.num, fp.den))  // Apply advanced filters
                    .map(fp => {
                        const frac = fp.num / fp.den;
                        
                        // Apply per-ring rotation for this denominator
                        let perRingOffset = 0;
                        const m = fp.den;
                        if (state.perRingRotations && state.perRingRotations[m] !== undefined) {
                            perRingOffset = state.perRingRotations[m] * Math.PI / 180;
                        } else {
                            perRingOffset = state.ringRotation * Math.PI / 180;
                        }
                        
                        // Use sequential or angular plotting
                        const baseAngle = 2 * Math.PI * frac;
                        const angle = getPlotAngle(Math.round(frac * m), m, baseAngle, perRingOffset);
                        return {
                            x: cx + r * Math.cos(angle),
                            y: cy + r * Math.sin(angle),
                            frac: frac,
                            label: `${fp.num}/${fp.den}`,
                            num: fp.num,
                            den: fp.den,
                            angle: angle
                        };
                    });

                // Global r‚Üír connections on unit disk (same denominator)
                if (document.getElementById('toggleShowRtoR').checked) {
                    ctx.globalAlpha = 0.4;
                    ctx.strokeStyle = CONFIG.colors.cyan;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([4, 4]);
                    
                    // Group by denominator
                    const denGroups = {};
                    fareyPoints.forEach(p => {
                        if (!denGroups[p.den]) denGroups[p.den] = [];
                        denGroups[p.den].push(p);
                    });
                    
                    // Connect points with same denominator
                    Object.values(denGroups).forEach(group => {
                        if (group.length >= 2) {
                            for (let i = 0; i < group.length - 1; i++) {
                                ctx.beginPath();
                                ctx.moveTo(group[i].x, group[i].y);
                                ctx.lineTo(group[i + 1].x, group[i + 1].y);
                                ctx.stroke();
                            }
                        }
                    });
                    
                    ctx.setLineDash([]);
                    ctx.globalAlpha = 1.0;
                }

                // Global r‚Üír+2‚Åø connections on unit disk (mediant paths)
                if (document.getElementById('toggleShowRtoRplus2n').checked) {
                    ctx.globalAlpha = 0.35;
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.7)';
                    ctx.lineWidth = 1.2;
                    ctx.setLineDash([2, 2]);
                    
                    // For each point, try to connect to its "lift" (mediant-related points)
                    fareyPoints.forEach(p1 => {
                        fareyPoints.forEach(p2 => {
                            if (p1 === p2) return;
                            
                            // Check if p2.den = 2*p1.den (doubling relationship)
                            if (p2.den === 2 * p1.den || p2.den === p1.den * 3) {
                                ctx.beginPath();
                                ctx.moveTo(p1.x, p1.y);
                                ctx.lineTo(p2.x, p2.y);
                                ctx.stroke();
                            }
                        });
                    });
                    
                    ctx.setLineDash([]);
                    ctx.globalAlpha = 1.0;
                }

                // Fill
                if (fareyPoints.length >= 3) {
                    ctx.fillStyle = CONFIG.colors.fareyFill;
                    ctx.beginPath();
                    ctx.moveTo(fareyPoints[0].x, fareyPoints[0].y);
                    for (let i = 1; i < fareyPoints.length; i++) {
                        ctx.lineTo(fareyPoints[i].x, fareyPoints[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // Edges
                ctx.strokeStyle = CONFIG.colors.farey;
                ctx.lineWidth = 2.5;
                ctx.shadowBlur = 15;
                ctx.shadowColor = CONFIG.colors.farey;
                ctx.beginPath();
                ctx.moveTo(fareyPoints[0].x, fareyPoints[0].y);
                for (let i = 1; i < fareyPoints.length; i++) {
                    ctx.lineTo(fareyPoints[i].x, fareyPoints[i].y);
                }
                if (fareyPoints.length >= 3) ctx.closePath();
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Vertices
                fareyPoints.forEach(p => {
                    ctx.fillStyle = CONFIG.colors.farey;
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = CONFIG.colors.farey;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Labels
                    if (state.labelMode !== 'none') {
                        const angle = 2 * Math.PI * p.frac + phase;
                        const labelR = r + 35;
                        const lx = cx + labelR * Math.cos(angle);
                        const ly = cy + labelR * Math.sin(angle);

                        ctx.fillStyle = CONFIG.colors.farey;
                        ctx.font = `bold ${state.labelSize + 6}px "Fira Code"`;
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillText(p.label, lx, ly);
                        ctx.shadowBlur = 0;
                    }
                });
            }

            // Title
            // Title removed to avoid duplication on export
            // ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            // ctx.font = 'bold 20px "Fira Code"';
            // ctx.textAlign = 'center';
            // ctx.shadowBlur = 10;
            // ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            // ctx.fillText('Unit Disk ùîª', cx, 35);
            // ctx.shadowBlur = 0;

            // Draw selection highlight if point is selected on this canvas
            if (inspectionState.selectedPoint && inspectionState.selectedPoint.canvasType === 'disk') {
                const sp = inspectionState.selectedPoint;
                drawSelectionHighlight(ctx, sp.x, sp.y, sp.type);
            }

            // Restore context if inverted
            if (invertAll) {
                ctx.restore();
            }
        }

        function drawCayley() {
            const canvas = canvases.cayley;
            const ctx = canvases.cayleyCtx;
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.clearRect(0, 0, w, h);

            // Apply inversion if enabled
            const invertAll = document.getElementById('toggleInvertAll').checked;
            if (invertAll) {
                ctx.save();
                ctx.translate(w / 2, h / 2);
                ctx.scale(-1, -1);
                ctx.translate(-w / 2, -h / 2);
            }

            // Coordinate conversion functions for Cayley plane
            function mathToScreen(wp) {
                const reMin = -state.cayleyHRange / (2 * state.cayleyZoom);
                const reMax = state.cayleyHRange / (2 * state.cayleyZoom);
                const imMin = state.cayleyVOffset;
                const imMax = (state.cayleyVRange / state.cayleyZoom) + state.cayleyVOffset;
                
                const x = ((wp.re - reMin) / (reMax - reMin)) * w;
                const y = (1 - (wp.im - imMin) / (imMax - imMin)) * h;
                
                return { x, y };
            }

            const phase = state.phase * Math.PI / 180;
            const showGeodesic = document.getElementById('toggleGeodesic').checked;
            const showCusps = document.getElementById('toggleCusps').checked;
            const showPrimes = document.getElementById('togglePrimes').checked;
            const showChannels = document.getElementById('toggleChannels').checked;
            const showFarey = document.getElementById('toggleFarey').checked;
            const showGrid = document.getElementById('toggleGrid').checked;
            const showFundDomain = document.getElementById('toggleFundDomain').checked;
            const showVerticals = document.getElementById('toggleVerticals').checked;
            const showDiskOutline = document.getElementById('toggleDiskOutline').checked;
            const showFordCircles = document.getElementById('toggleFordCircles').checked;

            // Draw grid
            if (showGrid) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                ctx.lineWidth = 1;

                const spacing = 0.5 / state.cayleyGridDensity;
                const reMin = -state.cayleyHRange / (2 * state.cayleyZoom);
                const reMax = state.cayleyHRange / (2 * state.cayleyZoom);
                const imMin = state.cayleyVOffset;
                const imMax = (state.cayleyVRange / state.cayleyZoom) + state.cayleyVOffset;

                // Vertical lines
                for (let re = Math.ceil(reMin / spacing) * spacing; re <= reMax; re += spacing) {
                    const p1 = mathToScreen({ re, im: imMin });
                    const p2 = mathToScreen({ re, im: imMax });
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();

                    // Labels for major gridlines
                    if (Math.abs(re) > 0.01 && Math.abs(re % 1) < 0.01) {
                        const p = mathToScreen({ re, im: imMin });
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.font = '10px Fira Code';
                        ctx.textAlign = 'center';
                        ctx.fillText(re.toFixed(0), p.x, p.y - 5);
                    }
                }

                // Horizontal lines
                for (let im = Math.ceil(imMin / spacing) * spacing; im <= imMax; im += spacing) {
                    if (im < 0.01) continue;
                    
                    const p1 = mathToScreen({ re: reMin, im });
                    const p2 = mathToScreen({ re: reMax, im });
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();

                    // Labels for major gridlines
                    if (im > 0.1 && Math.abs(im % 1) < 0.01) {
                        const p = mathToScreen({ re: reMin, im });
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.font = '10px Fira Code';
                        ctx.textAlign = 'right';
                        ctx.fillText(im.toFixed(0) + 'i', p.x + w - 5, p.y);
                    }
                }
            }

            // Real axis (boundary of ‚Ñç)
            const axisP1 = mathToScreen({ re: -state.cayleyHRange / (2 * state.cayleyZoom), im: 0 });
            const axisP2 = mathToScreen({ re: state.cayleyHRange / (2 * state.cayleyZoom), im: 0 });
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(axisP1.x, axisP1.y);
            ctx.lineTo(axisP2.x, axisP2.y);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Imaginary axis
            const iAxisP1 = mathToScreen({ re: 0, im: state.cayleyVOffset });
            const iAxisP2 = mathToScreen({ re: 0, im: (state.cayleyVRange / state.cayleyZoom) + state.cayleyVOffset });
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(iAxisP1.x, iAxisP1.y);
            ctx.lineTo(iAxisP2.x, iAxisP2.y);
            ctx.stroke();

            // Fundamental domain
            if (showFundDomain) {
                ctx.strokeStyle = 'rgba(230, 126, 34, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);

                // Left boundary: Re = -1/2
                const leftTop = mathToScreen({ re: -0.5, im: (state.cayleyVRange / state.cayleyZoom) + state.cayleyVOffset });
                const leftBot = mathToScreen({ re: -0.5, im: Math.max(0, Math.sqrt(1 - 0.25)) });
                ctx.beginPath();
                ctx.moveTo(leftBot.x, leftBot.y);
                ctx.lineTo(leftTop.x, leftTop.y);
                ctx.stroke();

                // Right boundary: Re = 1/2
                const rightTop = mathToScreen({ re: 0.5, im: (state.cayleyVRange / state.cayleyZoom) + state.cayleyVOffset });
                const rightBot = mathToScreen({ re: 0.5, im: Math.max(0, Math.sqrt(1 - 0.25)) });
                ctx.beginPath();
                ctx.moveTo(rightBot.x, rightBot.y);
                ctx.lineTo(rightTop.x, rightTop.y);
                ctx.stroke();

                // Bottom arc: |z| = 1
                ctx.beginPath();
                let firstArc = true;
                for (let i = 0; i <= 50; i++) {
                    const angle = Math.PI * i / 50;
                    const re = Math.cos(angle);
                    const im = Math.sin(angle);
                    if (Math.abs(re) <= 0.5 && im >= 0) {
                        const p = mathToScreen({ re, im });
                        if (firstArc) {
                            ctx.moveTo(p.x, p.y);
                            firstArc = false;
                        } else {
                            ctx.lineTo(p.x, p.y);
                        }
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Unit disk outline (where |z|=1 on disk maps under Cayley)
            if (showDiskOutline) {
                ctx.strokeStyle = 'rgba(231, 76, 60, 0.4)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([3, 3]);

                ctx.beginPath();
                let firstDisk = true;
                for (let i = 0; i <= 100; i++) {
                    const angle = 2 * Math.PI * i / 100;
                    const z = { re: Math.cos(angle), im: Math.sin(angle) };
                    const wp = cayleyTransform(z);
                    
                    const p = mathToScreen(wp);
                    if (firstDisk) {
                        ctx.moveTo(p.x, p.y);
                        firstDisk = false;
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Vertical geodesics
            if (showVerticals) {
                ctx.strokeStyle = 'rgba(155, 89, 182, 0.3)';
                ctx.lineWidth = 1;
                
                const reMin = -state.cayleyHRange / (2 * state.cayleyZoom);
                const reMax = state.cayleyHRange / (2 * state.cayleyZoom);
                
                for (let re = Math.ceil(reMin); re <= reMax; re++) {
                    const p1 = mathToScreen({ re, im: state.cayleyVOffset });
                    const p2 = mathToScreen({ re, im: (state.cayleyVRange / state.cayleyZoom) + state.cayleyVOffset });
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }

            // Geodesic
            if (showGeodesic && state.fareyPoints.length >= 2) {
                // Draw all geodesics between all pairs of Farey points
                for (let i = 0; i < state.fareyPoints.length; i++) {
                    for (let j = i + 1; j < state.fareyPoints.length; j++) {
                        const fp1 = state.fareyPoints[i];
                        const fp2 = state.fareyPoints[j];
                        
                        const frac1 = fp1.num / fp1.den;
                        const frac2 = fp2.num / fp2.den;
                        
                        // Apply per-ring rotation for each point
                        let perRingOffset1 = 0;
                        if (state.perRingRotations && state.perRingRotations[fp1.den] !== undefined) {
                            perRingOffset1 = state.perRingRotations[fp1.den] * Math.PI / 180;
                        } else {
                            perRingOffset1 = state.ringRotation * Math.PI / 180;
                        }
                        
                        let perRingOffset2 = 0;
                        if (state.perRingRotations && state.perRingRotations[fp2.den] !== undefined) {
                            perRingOffset2 = state.perRingRotations[fp2.den] * Math.PI / 180;
                        } else {
                            perRingOffset2 = state.ringRotation * Math.PI / 180;
                        }
                        
                        const angle1 = 2 * Math.PI * frac1 + phase + perRingOffset1;
                        const angle2 = 2 * Math.PI * frac2 + phase + perRingOffset2;
                        
                        const z1 = { re: Math.cos(angle1), im: Math.sin(angle1) };
                        const z2 = { re: Math.cos(angle2), im: Math.sin(angle2) };
                        
                        const w1 = cayleyTransform(z1, state.transformType);
                        const w2 = cayleyTransform(z2, state.transformType);

                        const centerRe = (w1.re + w2.re) / 2;
                        const radius = Math.sqrt((w1.re - centerRe) ** 2 + w1.im ** 2);

                        // Highlight first geodesic
                        const isFirst = (i === 0 && j === 1);
                        ctx.strokeStyle = isFirst ? CONFIG.colors.geodesic : 'rgba(26, 188, 156, 0.3)';
                        ctx.lineWidth = isFirst ? 4 : 2;
                        if (isFirst) {
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = CONFIG.colors.geodesic;
                        }
                        
                        ctx.beginPath();
                        let firstGeo = true;
                        for (let k = 0; k <= 100; k++) {
                            const angle = Math.PI * k / 100;
                            const re = centerRe + radius * Math.cos(angle);
                            const im = radius * Math.sin(angle);
                            
                            const p = mathToScreen({ re, im });
                            if (firstGeo) {
                                ctx.moveTo(p.x, p.y);
                                firstGeo = false;
                            } else {
                                ctx.lineTo(p.x, p.y);
                            }
                        }
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                }
                
                // Global r‚Üír connections on Cayley plane (same denominator)
                if (document.getElementById('toggleShowRtoR').checked) {
                    ctx.globalAlpha = 0.4;
                    ctx.strokeStyle = CONFIG.colors.cyan;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([4, 4]);
                    
                    // Group by denominator
                    const denGroups = {};
                    state.fareyPoints.forEach(fp => {
                        if (!denGroups[fp.den]) denGroups[fp.den] = [];
                        denGroups[fp.den].push(fp);
                    });
                    
                    // Connect transformed points with same denominator
                    Object.values(denGroups).forEach(group => {
                        if (group.length >= 2) {
                            const transformedGroup = group.map(fp => {
                                const frac = fp.num / fp.den;
                                const angle = 2 * Math.PI * frac + phase;
                                const z = { re: Math.cos(angle), im: Math.sin(angle) };
                                const wp = cayleyTransform(z, state.transformType);
                                return mathToScreen(wp);
                            });
                            
                            for (let i = 0; i < transformedGroup.length - 1; i++) {
                                ctx.beginPath();
                                ctx.moveTo(transformedGroup[i].x, transformedGroup[i].y);
                                ctx.lineTo(transformedGroup[i + 1].x, transformedGroup[i + 1].y);
                                ctx.stroke();
                            }
                        }
                    });
                    
                    ctx.setLineDash([]);
                    ctx.globalAlpha = 1.0;
                }

                // Global r‚Üír+2‚Åø on Cayley plane
                if (document.getElementById('toggleShowRtoRplus2n').checked) {
                    ctx.globalAlpha = 0.35;
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.7)';
                    ctx.lineWidth = 1.2;
                    ctx.setLineDash([2, 2]);
                    
                    state.fareyPoints.forEach(fp1 => {
                        state.fareyPoints.forEach(fp2 => {
                            if (fp1 === fp2) return;
                            
                            if (fp2.den === 2 * fp1.den || fp2.den === fp1.den * 3) {
                                const frac1 = fp1.num / fp1.den;
                                const frac2 = fp2.num / fp2.den;
                                const angle1 = 2 * Math.PI * frac1 + phase;
                                const angle2 = 2 * Math.PI * frac2 + phase;
                                const z1 = { re: Math.cos(angle1), im: Math.sin(angle1) };
                                const z2 = { re: Math.cos(angle2), im: Math.sin(angle2) };
                                const w1 = cayleyTransform(z1, state.transformType);
                                const w2 = cayleyTransform(z2, state.transformType);
                                const p1 = mathToScreen(w1);
                                const p2 = mathToScreen(w2);
                                
                                ctx.beginPath();
                                ctx.moveTo(p1.x, p1.y);
                                ctx.lineTo(p2.x, p2.y);
                                ctx.stroke();
                            }
                        });
                    });
                    
                    ctx.setLineDash([]);
                    ctx.globalAlpha = 1.0;
                }
            }

            // Transformed primes
            if (showPrimes) {
                const colors = generateColors(state.modulus);
                const displayPrimes = state.primes.slice(0, state.numPrimes);

                const reMin = -state.cayleyHRange / (2 * state.cayleyZoom);
                const reMax = state.cayleyHRange / (2 * state.cayleyZoom);
                const imMin = state.cayleyVOffset;
                const imMax = (state.cayleyVRange / state.cayleyZoom) + state.cayleyVOffset;

                displayPrimes.forEach(p => {
                    if (showChannels && gcd(p, state.modulus) !== 1) return;

                    const angle = 2 * Math.PI * p / state.modulus + phase;
                    const z = { re: Math.cos(angle), im: Math.sin(angle) };
                    const wp = cayleyTransform(z, state.transformType);

                    // Only draw if in visible range
                    if (wp.re >= reMin && wp.re <= reMax && wp.im >= imMin && wp.im <= imMax && wp.im > 0.01) {
                        const p_screen = mathToScreen(wp);
                        const color = showChannels ? colors[p % state.modulus] : CONFIG.colors.prime;
                        
                        ctx.fillStyle = color;
                        ctx.shadowBlur = 6;
                        ctx.shadowColor = color;
                        ctx.beginPath();
                        ctx.arc(p_screen.x, p_screen.y, 3.5, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                });
            }

            // Cusps on real axis
            if (showCusps && state.fareyPoints.length > 0) {
                state.fareyPoints.forEach(fp => {
                    // Apply advanced filters
                    if (!passesFilters(fp.num, fp.den)) return;
                    
                    const frac = fp.num / fp.den;
                    const angle = 2 * Math.PI * frac + phase;
                    const z = { re: Math.cos(angle), im: Math.sin(angle) };
                    const wp = cayleyTransform(z, state.transformType);
                    const cuspP = mathToScreen({ re: wp.re, im: 0 });

                    ctx.fillStyle = CONFIG.colors.cusp;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = CONFIG.colors.cusp;
                    ctx.beginPath();
                    ctx.arc(cuspP.x, cuspP.y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    if (state.labelMode !== 'none') {
                        ctx.fillStyle = CONFIG.colors.cusp;
                        ctx.font = `${state.labelSize + 3}px "Fira Code"`;
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillText(`${fp.num}/${fp.den}`, cuspP.x, cuspP.y + 22);
                        ctx.shadowBlur = 0;
                    }
                });
            }

            // Ford circles
            if (showFordCircles && state.fareyPoints.length > 0) {
                state.fareyPoints.forEach(fp => {
                    // Apply advanced filters
                    if (!passesFilters(fp.num, fp.den)) return;
                    
                    const p = fp.num;
                    const q = fp.den;
                    if (q === 0) return;
                    
                    // Ford circle for p/q has center at (p/q, 1/(2q¬≤)) and radius 1/(2q¬≤)
                    const centerRe = p / q;
                    const radius = 1 / (2 * q * q);
                    const centerIm = radius;
                    
                    // Check if visible
                    const reMin = -state.cayleyHRange / (2 * state.cayleyZoom);
                    const reMax = state.cayleyHRange / (2 * state.cayleyZoom);
                    const imMin = state.cayleyVOffset;
                    const imMax = (state.cayleyVRange / state.cayleyZoom) + state.cayleyVOffset;
                    
                    if (centerRe + radius >= reMin && centerRe - radius <= reMax && 
                        centerIm + radius >= imMin && centerIm - radius <= imMax) {
                        
                        const centerP = mathToScreen({ re: centerRe, im: centerIm });
                        const radiusP = mathToScreen({ re: centerRe + radius, im: centerIm });
                        const radiusPixels = Math.abs(radiusP.x - centerP.x);
                        
                        ctx.strokeStyle = 'rgba(230, 126, 34, 0.6)';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = 'rgba(230, 126, 34, 0.4)';
                        ctx.beginPath();
                        ctx.arc(centerP.x, centerP.y, radiusPixels, 0, 2 * Math.PI);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        
                        // Label
                        if (state.labelMode !== 'none' && radiusPixels > 10) {
                            ctx.fillStyle = CONFIG.colors.cusp;
                            ctx.font = `${Math.max(8, state.labelSize - 2)}px "Fira Code"`;
                            ctx.textAlign = 'center';
                            ctx.fillText(`${p}/${q}`, centerP.x, centerP.y);
                        }
                    }
                });
            }

            // Farey triangle (transformed)
            if (showFarey && state.fareyPoints.length >= 2) {
                const transformedPoints = state.fareyPoints.map(fp => {
                    const frac = fp.num / fp.den;
                    
                    // Apply per-ring rotation for this denominator
                    let perRingOffset = 0;
                    const m = fp.den;
                    if (state.perRingRotations && state.perRingRotations[m] !== undefined) {
                        perRingOffset = state.perRingRotations[m] * Math.PI / 180;
                    } else {
                        perRingOffset = state.ringRotation * Math.PI / 180;
                    }
                    
                    const angle = 2 * Math.PI * frac + phase + perRingOffset;
                    const z = { re: Math.cos(angle), im: Math.sin(angle) };
                    const wp = cayleyTransform(z, state.transformType);
                    return {
                        ...mathToScreen(wp),
                        wp: wp,
                        label: `${fp.num}/${fp.den}`
                    };
                });

                // Edges
                ctx.strokeStyle = CONFIG.colors.farey;
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.shadowBlur = 10;
                ctx.shadowColor = CONFIG.colors.farey;
                ctx.beginPath();
                ctx.moveTo(transformedPoints[0].x, transformedPoints[0].y);
                for (let i = 1; i < transformedPoints.length; i++) {
                    ctx.lineTo(transformedPoints[i].x, transformedPoints[i].y);
                }
                if (transformedPoints.length >= 3) ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.shadowBlur = 0;

                // Vertices
                transformedPoints.forEach(p => {
                    ctx.fillStyle = CONFIG.colors.farey;
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = CONFIG.colors.farey;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    if (state.labelMode !== 'none') {
                        ctx.fillStyle = CONFIG.colors.farey;
                        ctx.font = `bold ${state.labelSize + 3}px "Fira Code"`;
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillText(p.label, p.x, p.y - 20);
                        ctx.shadowBlur = 0;
                    }
                });
            }

            // Title removed to avoid duplication on export
            // ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            // ctx.font = 'bold 20px "Fira Code"';
            // ctx.textAlign = 'center';
            // ctx.shadowBlur = 10;
            // ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            // ctx.fillText('Upper Half-Plane ‚Ñç', w/2, 35);
            // ctx.shadowBlur = 0;

            // Draw selection highlight if point is selected on this canvas
            if (inspectionState.selectedPoint && inspectionState.selectedPoint.canvasType === 'cayley') {
                const sp = inspectionState.selectedPoint;
                drawSelectionHighlight(ctx, sp.x, sp.y, sp.type);
            }

            // Restore context if inverted
            if (invertAll) {
                ctx.restore();
            }
        }

        // ============================================================
        // MODULAR REDUCTION PROJECTION VISUALIZATION
        // ============================================================
        
        function drawReduction() {
            const canvas = canvases.reduction;
            const ctx = canvases.reductionCtx;
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.clearRect(0, 0, w, h);

            const showProjections = document.getElementById('toggleReductionProjections')?.checked ?? true;
            const showChannels = document.getElementById('toggleReductionChannels')?.checked ?? true;
            const invertMode = document.getElementById('toggleReductionInvert')?.checked ?? false;

            const M = state.modulus;
            const centerX = w / 2;
            const centerY = h / 2;
            const maxRadius = Math.min(w, h) * 0.42 * state.reductionZoom;
            const lineThickness = state.globalLineThickness || 1.0;

            // Update panel title dynamically
            const panelTitle = document.querySelector('#reductionPanel .panel-title');
            const panelSubtitle = document.querySelector('#reductionPanel .panel-subtitle');
            if (panelTitle && panelSubtitle) {
                panelTitle.textContent = `Modular Reduction Projection (M = ${M})`;
                const factorization = formatPrimeFactorization(M);
                const primeStatus = isPrime(M) ? 'Prime' : factorization;
                panelSubtitle.textContent = `Prime Factorization: ${primeStatus} ‚Ä¢ Farey Channels: r/M ‚Üí r'/M' where M' = M/gcd(r,M)`;
            }

            // Get all divisors of M (these are the Farey channels)
            const divisors = [];
            for (let d = 1; d <= M; d++) {
                if (M % d === 0) divisors.push(d);
            }
            
            const sortedDivisors = invertMode ? [...divisors].sort((a, b) => b - a) : [...divisors].sort((a, b) => a - b);
            const ringIndexMap = {};
            sortedDivisors.forEach((d, idx) => {
                ringIndexMap[d] = idx;
            });

            // Draw channel rings
            if (showChannels) {
                sortedDivisors.forEach((divisor, ringIndex) => {
                    const radius = invertMode ? 
                        maxRadius * (M / divisor) : 
                        maxRadius * (divisor / M);
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = (divisor === M ? 2.5 : 1.5) * lineThickness;
                    ctx.globalAlpha = divisor === M ? 0.8 : 0.4;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    
                    // Label the ring
                    if (divisor === M || divisor === 1 || ringIndex % 3 === 0) {
                        ctx.save();
                        ctx.translate(centerX + radius + 15, centerY);
                        ctx.fillStyle = '#ffd700';
                        ctx.font = '11px Fira Code';
                        ctx.textAlign = 'left';
                        ctx.fillText(`M'=${divisor}`, 0, 0);
                        ctx.restore();
                    }
                });
            }

            // Calculate all points on all rings with per-ring rotation
            const perRingRot = (state.ringRotation || 0) * Math.PI / 180;
            const allRingPoints = [];
            
            sortedDivisors.forEach((divisor, ringIndex) => {
                const radius = invertMode ? 
                    maxRadius * (M / divisor) : 
                    maxRadius * (divisor / M);
                const ringRotationAngle = perRingRot * ringIndex;
                
                for (let k = 0; k < divisor; k++) {
                    const baseAngle = (2 * Math.PI * k / divisor);
                    const angle = baseAngle + ringRotationAngle;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    
                    const g = gcd(k, divisor);
                    const coprime = g === 1;
                    const channel = divisor / g;
                    
                    allRingPoints.push({
                        ring: divisor,
                        ringIndex,
                        r: k,
                        x, y,
                        angle,
                        baseAngle,
                        radius,
                        gcd: g,
                        coprime,
                        channel
                    });
                }
            });

            // Draw Farey projection lines (from reducible residues to their reduced forms)
            if (showProjections) {
                allRingPoints.forEach(point => {
                    if (point.ring === M && point.gcd > 1) {
                        // This is a reducible residue on the outer ring
                        const targetRing = point.channel;
                        const targetRingIndex = ringIndexMap[targetRing];
                        
                        if (targetRingIndex !== undefined) {
                            const targetRadius = invertMode ? 
                                maxRadius * (M / targetRing) : 
                                maxRadius * (targetRing / M);
                            const targetRotation = perRingRot * targetRingIndex;
                            
                            // The reduced residue r' = r/gcd on the target ring
                            const reducedR = point.r / point.gcd;
                            const targetAngle = (2 * Math.PI * reducedR / targetRing) + targetRotation;
                            const targetX = centerX + targetRadius * Math.cos(targetAngle);
                            const targetY = centerY + targetRadius * Math.sin(targetAngle);
                            
                            // Draw projection line
                            ctx.beginPath();
                            ctx.moveTo(point.x, point.y);
                            ctx.lineTo(targetX, targetY);
                            ctx.strokeStyle = '#ff0000';
                            ctx.lineWidth = 0.8 * lineThickness;
                            ctx.globalAlpha = 0.4;
                            ctx.stroke();
                            ctx.globalAlpha = 1;
                        }
                    }
                });
            }

            // Draw all points
            allRingPoints.forEach(point => {
                const isOuterRing = point.ring === M;
                const color = point.coprime ? '#00ffff' : '#ff1493';
                const size = isOuterRing ? (point.coprime ? 5 : 4) : (point.coprime ? 3.5 : 2.5);
                
                ctx.beginPath();
                ctx.arc(point.x, point.y, size, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.globalAlpha = isOuterRing ? 0.95 : 0.7;
                ctx.fill();
                ctx.globalAlpha = 1;
            });

            // Draw statistics overlay
            const showStats = document.getElementById('toggleReductionStats')?.checked ?? true;
            if (showStats) {
                // Calculate statistics
                let coprimeCount = 0;
                let nonCoprimeCount = 0;
                for (let r = 0; r < M; r++) {
                    if (gcd(r, M) === 1) coprimeCount++;
                    else nonCoprimeCount++;
                }
                const coprimePct = ((coprimeCount / M) * 100).toFixed(1);
                const factorization = formatPrimeFactorization(M);
                const primeStatus = isPrime(M) ? 'Prime' : 'Composite';
                
                // Stats box in top-right corner
                const boxW = 280;
                const boxH = 220;
                const boxX = w - boxW - 20;
                const boxY = 20;
                
                ctx.save();
                
                // Background with border
                ctx.fillStyle = 'rgba(10, 14, 39, 0.92)';
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.7)';
                ctx.lineWidth = 2;
                ctx.fillRect(boxX, boxY, boxW, boxH);
                ctx.strokeRect(boxX, boxY, boxW, boxH);
                
                // Title
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 16px Fira Code';
                ctx.textAlign = 'left';
                ctx.fillText('MODULAR REDUCTION', boxX + 15, boxY + 25);
                
                // Separator line
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(boxX + 15, boxY + 35);
                ctx.lineTo(boxX + boxW - 15, boxY + 35);
                ctx.stroke();
                
                // Statistics
                ctx.font = '13px Fira Code';
                ctx.fillStyle = '#c9d1d9';
                let yPos = boxY + 55;
                const lineHeight = 18;
                
                ctx.fillText(`M = ${M}`, boxX + 15, yPos);
                yPos += lineHeight;
                
                ctx.fillStyle = '#8b949e';
                ctx.fillText(`Type: ${primeStatus}`, boxX + 15, yPos);
                yPos += lineHeight;
                
                ctx.fillText(`${factorization}`, boxX + 15, yPos);
                yPos += lineHeight + 5;
                
                // Coprime section
                ctx.fillStyle = '#00ffff';
                ctx.fillText(`œÜ(M) = ${coprimeCount}`, boxX + 15, yPos);
                yPos += lineHeight;
                
                ctx.fillStyle = '#8b949e';
                ctx.fillText(`Coprime: ${coprimePct}%`, boxX + 15, yPos);
                yPos += lineHeight + 5;
                
                // Reducible section
                ctx.fillStyle = '#ff1493';
                ctx.fillText(`Reducible: ${nonCoprimeCount}`, boxX + 15, yPos);
                yPos += lineHeight;
                
                ctx.fillStyle = '#8b949e';
                ctx.fillText(`Non-coprime: ${(100-parseFloat(coprimePct)).toFixed(1)}%`, boxX + 15, yPos);
                yPos += lineHeight + 5;
                
                // Channels
                ctx.fillStyle = '#ffd700';
                ctx.fillText(`Channels: ${divisors.length}`, boxX + 15, yPos);
                yPos += lineHeight;
                
                ctx.fillStyle = '#8b949e';
                ctx.font = '11px Fira Code';
                ctx.fillText(`(divisors of M)`, boxX + 15, yPos);
                
                ctx.restore();
            }

            // Draw watermark
            ctx.save();
            ctx.translate(w - 10, h - 10);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = 'rgba(200, 200, 200, 0.15)';
            ctx.font = '10px Fira Code';
            ctx.textAlign = 'right';
            ctx.fillText('Wessen Getachew (@7dview) ‚Ä¢ Modular Reduction Explorer', 0, 0);
            ctx.restore();
        }

        function drawFullPlane() {
            const canvas = canvases.fullPlane;
            const ctx = canvases.fullPlaneCtx;
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.clearRect(0, 0, w, h);

            // Apply inversion if enabled
            const invertAll = document.getElementById('toggleInvertAll').checked;
            if (invertAll) {
                ctx.save();
                ctx.translate(w / 2, h / 2);
                ctx.scale(-1, -1);
                ctx.translate(-w / 2, -h / 2);
            }

            // Coordinate conversion - full complex plane view
            function mathToScreen(wp) {
                const scale = Math.min(w, h) * 0.15 * state.fullPlaneZoom;
                const x = w / 2 + wp.re * scale;
                const y = h / 2 - wp.im * scale;
                return { x, y };
            }

            const phase = state.phase * Math.PI / 180;

            // Grid
            if (document.getElementById('toggleGrid').checked) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                ctx.lineWidth = 1;

                const gridSpacing = 1;
                const maxGrid = 10;

                for (let i = -maxGrid; i <= maxGrid; i++) {
                    // Vertical lines
                    const p1 = mathToScreen({ re: i * gridSpacing, im: -maxGrid * gridSpacing });
                    const p2 = mathToScreen({ re: i * gridSpacing, im: maxGrid * gridSpacing });
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();

                    // Horizontal lines
                    const p3 = mathToScreen({ re: -maxGrid * gridSpacing, im: i * gridSpacing });
                    const p4 = mathToScreen({ re: maxGrid * gridSpacing, im: i * gridSpacing });
                    ctx.beginPath();
                    ctx.moveTo(p3.x, p3.y);
                    ctx.lineTo(p4.x, p4.y);
                    ctx.stroke();
                }
            }

            // Axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            
            // Real axis
            const realStart = mathToScreen({ re: -10, im: 0 });
            const realEnd = mathToScreen({ re: 10, im: 0 });
            ctx.beginPath();
            ctx.moveTo(realStart.x, realStart.y);
            ctx.lineTo(realEnd.x, realEnd.y);
            ctx.stroke();

            // Imaginary axis
            const imStart = mathToScreen({ re: 0, im: -10 });
            const imEnd = mathToScreen({ re: 0, im: 10 });
            ctx.beginPath();
            ctx.moveTo(imStart.x, imStart.y);
            ctx.lineTo(imEnd.x, imEnd.y);
            ctx.stroke();

            // Draw unit circle (boundary between disk and exterior)
            ctx.strokeStyle = 'rgba(231, 76, 60, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const angle = 2 * Math.PI * i / 100;
                const z = { re: Math.cos(angle), im: Math.sin(angle) };
                const wp = cayleyTransform(z, state.transformType);
                const p = mathToScreen(wp);
                if (i === 0) {
                    ctx.moveTo(p.x, p.y);
                } else {
                    ctx.lineTo(p.x, p.y);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw real axis (maps from unit circle |z|=1)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            const realAxisStart = mathToScreen({ re: -10, im: 0 });
            const realAxisEnd = mathToScreen({ re: 10, im: 0 });
            ctx.beginPath();
            ctx.moveTo(realAxisStart.x, realAxisStart.y);
            ctx.lineTo(realAxisEnd.x, realAxisEnd.y);
            ctx.stroke();

            // Label the regions
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.font = 'italic 14px "Fira Code"';
            ctx.textAlign = 'center';
            
            const upperLabel = mathToScreen({ re: 0, im: 4 });
            ctx.fillText('Upper Half-Plane', upperLabel.x, upperLabel.y);
            ctx.fillText('(|z| < 1 interior)', upperLabel.x, upperLabel.y + 20);
            
            const lowerLabel = mathToScreen({ re: 0, im: -4 });
            ctx.fillText('Lower Half-Plane', lowerLabel.x, lowerLabel.y);
            ctx.fillText('(|z| > 1 exterior)', lowerLabel.x, lowerLabel.y + 20);
            
            const axisLabel = mathToScreen({ re: 7, im: 0 });
            ctx.fillText('Real Axis (|z| = 1)', axisLabel.x, axisLabel.y - 10);

            // Transformed Farey points
            if (document.getElementById('toggleFarey').checked && state.fareyPoints.length > 0) {
                state.fareyPoints.forEach(fp => {
                    // Apply advanced filters
                    if (!passesFilters(fp.num, fp.den)) return;
                    
                    const frac = fp.num / fp.den;
                    
                    // Apply per-ring rotation for this denominator
                    let perRingOffset = 0;
                    const m = fp.den;
                    if (state.perRingRotations && state.perRingRotations[m] !== undefined) {
                        perRingOffset = state.perRingRotations[m] * Math.PI / 180;
                    } else {
                        perRingOffset = state.ringRotation * Math.PI / 180;
                    }
                    
                    const angle = 2 * Math.PI * frac + phase + perRingOffset;
                    const z = { re: Math.cos(angle), im: Math.sin(angle) };
                    const wp = cayleyTransform(z, state.transformType);
                    const p = mathToScreen(wp);

                    ctx.fillStyle = CONFIG.colors.farey;
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = CONFIG.colors.farey;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    if (state.labelMode !== 'none') {
                        ctx.fillStyle = CONFIG.colors.farey;
                        ctx.font = `bold ${state.labelSize + 3}px "Fira Code"`;
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillText(`${fp.num}/${fp.den}`, p.x, p.y - 20);
                        ctx.shadowBlur = 0;
                    }
                });
            }

            // Geodesics
            if (document.getElementById('toggleGeodesic').checked && state.fareyPoints.length >= 2) {
                for (let i = 0; i < state.fareyPoints.length; i++) {
                    for (let j = i + 1; j < state.fareyPoints.length; j++) {
                        const fp1 = state.fareyPoints[i];
                        const fp2 = state.fareyPoints[j];
                        
                        const frac1 = fp1.num / fp1.den;
                        const frac2 = fp2.num / fp2.den;
                        
                        // Apply per-ring rotation for each point
                        let perRingOffset1 = 0;
                        if (state.perRingRotations && state.perRingRotations[fp1.den] !== undefined) {
                            perRingOffset1 = state.perRingRotations[fp1.den] * Math.PI / 180;
                        } else {
                            perRingOffset1 = state.ringRotation * Math.PI / 180;
                        }
                        
                        let perRingOffset2 = 0;
                        if (state.perRingRotations && state.perRingRotations[fp2.den] !== undefined) {
                            perRingOffset2 = state.perRingRotations[fp2.den] * Math.PI / 180;
                        } else {
                            perRingOffset2 = state.ringRotation * Math.PI / 180;
                        }
                        
                        const angle1 = 2 * Math.PI * frac1 + phase + perRingOffset1;
                        const angle2 = 2 * Math.PI * frac2 + phase + perRingOffset2;
                        
                        const z1 = { re: Math.cos(angle1), im: Math.sin(angle1) };
                        const z2 = { re: Math.cos(angle2), im: Math.sin(angle2) };
                        
                        const w1 = cayleyTransform(z1, state.transformType);
                        const w2 = cayleyTransform(z2, state.transformType);

                        const centerRe = (w1.re + w2.re) / 2;
                        const radius = Math.sqrt((w1.re - centerRe) ** 2 + w1.im ** 2);

                        const isFirst = (i === 0 && j === 1);
                        ctx.strokeStyle = isFirst ? CONFIG.colors.geodesic : 'rgba(26, 188, 156, 0.3)';
                        ctx.lineWidth = isFirst ? 4 : 2;
                        if (isFirst) {
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = CONFIG.colors.geodesic;
                        }
                        
                        ctx.beginPath();
                        let firstGeo = true;
                        for (let k = 0; k <= 100; k++) {
                            const angle = Math.PI * k / 100;
                            const re = centerRe + radius * Math.cos(angle);
                            const im = radius * Math.sin(angle);
                            
                            const p = mathToScreen({ re, im });
                            if (firstGeo) {
                                ctx.moveTo(p.x, p.y);
                                firstGeo = false;
                            } else {
                                ctx.lineTo(p.x, p.y);
                            }
                        }
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                }
            }

            // Primes
            if (document.getElementById('togglePrimes').checked) {
                const colors = generateColors(state.modulus);
                const displayPrimes = state.primes.slice(0, state.numPrimes);
                const showChannels = document.getElementById('toggleChannels').checked;

                displayPrimes.forEach(p => {
                    if (showChannels && gcd(p, state.modulus) !== 1) return;

                    const angle = 2 * Math.PI * p / state.modulus + phase;
                    const z = { re: Math.cos(angle), im: Math.sin(angle) };
                    const wp = cayleyTransform(z, state.transformType);
                    const p_screen = mathToScreen(wp);

                    const color = showChannels ? colors[p % state.modulus] : CONFIG.colors.prime;
                    
                    ctx.fillStyle = color;
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = color;
                    ctx.beginPath();
                    ctx.arc(p_screen.x, p_screen.y, 3.5, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });
            }

            // Title removed to avoid duplication on export
            // ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            // ctx.font = 'bold 20px "Fira Code"';
            // ctx.textAlign = 'center';
            // ctx.shadowBlur = 10;
            // ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            // ctx.fillText('Full Complex Plane ‚ÑÇ', w/2, 35);
            // ctx.shadowBlur = 0;

            // Restore context if inverted
            if (invertAll) {
                ctx.restore();
            }
        }

        function drawNested() {
            const canvas = canvases.nested;
            const ctx = canvases.nestedCtx;
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            const cx = w / 2;
            const cy = h / 2;
            const maxRadius = Math.min(w, h) * 0.42 * state.nestedZoom;
            const baseRadius = maxRadius * 0.15;

            ctx.clearRect(0, 0, w, h);

            // Check display mode
            const displayMode = document.getElementById('nestedDisplayMode').value;
            const isSequential = displayMode === 'sequential';

            // Apply inversion if enabled
            const invertAll = document.getElementById('toggleInvertAll').checked;
            if (invertAll) {
                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(-1, -1);
                ctx.translate(-cx, -cy);
            }

            // Grid
            if (document.getElementById('toggleGrid').checked) {
                ctx.strokeStyle = CONFIG.colors.grid;
                ctx.lineWidth = 0.5;
                for (let i = -10; i <= 10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(cx + i * maxRadius / 5, 0);
                    ctx.lineTo(cx + i * maxRadius / 5, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, cy + i * maxRadius / 5);
                    ctx.lineTo(w, cy + i * maxRadius / 5);
                    ctx.stroke();
                }
            }

            // Axes
            ctx.strokeStyle = CONFIG.colors.axes;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(w, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, h);
            ctx.stroke();

            // SEQUENTIAL MODE: Show moduli 1 to N with angular mappings and GCD colors
            if (isSequential) {
                const n = state.maxRing;
                const mapping = document.getElementById('angularMapping').value;
                const colorByGCD = document.getElementById('colorByGCD').checked;
                const showConnections = document.getElementById('showCoprimeConnections').checked;
                
                // Draw each ring from 1 to n
                for (let m = 1; m <= n; m++) {
                    const t = (m - 1) / Math.max(1, n - 1);
                    const ringRadius = baseRadius + t * (maxRadius - baseRadius) * state.ringSpacing;

                    // Ring circle
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(cx, cy, ringRadius, 0, 2 * Math.PI);
                    ctx.stroke();

                    // Ring label
                    if (m % Math.max(1, Math.floor(n / 10)) === 0 || m === 1 || m === n) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.font = `${Math.max(8, 10 * state.nestedZoom)}px "Fira Code"`;
                        ctx.textAlign = 'left';
                        ctx.fillText(`m=${m}`, cx + ringRadius + 5, cy);
                    }

                    // Draw residues for this modulus
                    for (let r = 0; r < m; r++) {
                        const g = gcd(r, m);
                        const angle = getAngleForMapping(r, m, mapping);
                        const x = cx + ringRadius * Math.cos(angle);
                        const y = cy + ringRadius * Math.sin(angle);

                        // Determine color
                        let color;
                        if (colorByGCD) {
                            color = GCD_COLORS[g] || GCD_COLORS.default;
                        } else {
                            color = g === 1 ? CONFIG.colors.gold : 'rgba(255, 255, 255, 0.3)';
                        }

                        // Draw point
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(x, y, 2.5 * state.globalLineThickness, 0, 2 * Math.PI);
                        ctx.fill();

                        // Draw connection to center for coprime points on outer ring
                        if (showConnections && m === n && g === 1 && n <= 30) {
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 0.5 * state.globalLineThickness;
                            ctx.globalAlpha = 0.2;
                            ctx.beginPath();
                            ctx.moveTo(cx, cy);
                            ctx.lineTo(x, y);
                            ctx.stroke();
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }

                // Draw GCD legend
                if (colorByGCD) {
                    const legendX = 15;
                    const legendY = h - 140;
                    
                    ctx.fillStyle = 'rgba(10, 14, 39, 0.85)';
                    ctx.fillRect(legendX, legendY, 130, 130);
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(legendX, legendY, 130, 130);

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = 'bold 11px "Fira Code"';
                    ctx.textAlign = 'left';
                    ctx.fillText('GCD Colors', legendX + 10, legendY + 20);

                    const legendItems = [
                        { gcd: 1, label: 'GCD = 1' },
                        { gcd: 2, label: 'GCD = 2' },
                        { gcd: 3, label: 'GCD = 3' },
                        { gcd: 4, label: 'GCD = 4' },
                        { gcd: 5, label: 'GCD = 5' },
                        { gcd: 'default', label: 'GCD ‚â• 6' }
                    ];

                    let ly = legendY + 35;
                    legendItems.forEach(item => {
                        const color = item.gcd === 'default' ? GCD_COLORS.default : GCD_COLORS[item.gcd];
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(legendX + 15, ly, 4, 0, 2 * Math.PI);
                        ctx.fill();

                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.font = '10px "Fira Code"';
                        ctx.fillText(item.label, legendX + 25, ly + 3);
                        ly += 15;
                    });
                }

                // Restore and return
                if (invertAll) {
                    ctx.restore();
                }
                return;
            }

            // ORIGINAL RANGE MODE: Continue with existing code
            const phase = state.phase * Math.PI / 180;
            const showRings = document.getElementById('toggleRings').checked;
            const showGCD = document.getElementById('toggleGCD').checked;
            const invertRings = document.getElementById('toggleInvertRings').checked;
            const showCoprimeOnly = document.getElementById('toggleShowCoprimeOnly').checked;
            const showNonCoprimeOnly = document.getElementById('toggleShowNonCoprimeOnly').checked;

            const allPoints = [];
            const numRings = state.maxRing - state.minRing + 1;

            for (let m = state.minRing; m <= state.maxRing; m++) {
                // Calculate ring index - invert if toggle is on
                let ringIndex;
                if (invertRings) {
                    ringIndex = (state.maxRing - m);
                } else {
                    ringIndex = m - state.minRing;
                }
                
                const ringRadius = baseRadius + ringIndex * (maxRadius - baseRadius) / Math.max(1, numRings - 1) * state.ringSpacing;

                // Calculate per-ring rotation (use preset if available, otherwise use global rotation)
                let ringRotationOffset;
                if (state.perRingRotations && state.perRingRotations[m] !== undefined) {
                    // Use preset rotation for this specific ring
                    ringRotationOffset = state.perRingRotations[m] * Math.PI / 180;
                } else {
                    // Use global rotation
                    ringRotationOffset = (state.ringRotation * Math.PI / 180) * ringIndex;
                }

                // Ring circle
                if (showRings) {
                    ctx.strokeStyle = `rgba(255, 255, 255, 0.15)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(cx, cy, ringRadius, 0, 2 * Math.PI);
                    ctx.stroke();

                    // Ring label
                    if ((state.labelMode === 'rings' || state.labelMode === 'everything') && m % state.labelFreq === 0) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.font = `${state.labelSize}px "Fira Code"`;
                        ctx.textAlign = 'left';
                        ctx.fillText(`m=${m}`, cx + ringRadius + 10, cy);
                    }
                }

                // Points for each k
                for (let k = 0; k < m; k++) {
                    const g = gcd(k, m);
                    
                    // Apply GCD filter
                    if (showCoprimeOnly && g !== 1) continue;
                    if (showNonCoprimeOnly && g === 1) continue;
                    
                    // Apply advanced filters
                    if (!passesFilter(k, m, g)) continue;
                    
                    const angle = 2 * Math.PI * k / m + phase + ringRotationOffset;
                    const x = cx + ringRadius * Math.cos(angle);
                    const y = cy + ringRadius * Math.sin(angle);

                    allPoints.push({ x, y, k, m, g, angle, radius: ringRadius, frac: k/m });

                    // Draw point
                    if (showGCD) {
                        const color = getNestedPointColor(k, m, g, angle);
                        const size = g === 1 ? 4 : 3;
                        
                        ctx.fillStyle = color;
                        ctx.shadowBlur = g === 1 ? 8 : 4;
                        ctx.shadowColor = color;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }

                    // Labels with radial positioning
                    const shouldLabel = 
                        (state.labelMode === 'all') ||
                        (state.labelMode === 'integers') ||
                        (state.labelMode === 'coprime' && g === 1) ||
                        (state.labelMode === 'everything');

                    if (shouldLabel && m % state.labelFreq === 0) {
                        // Store label info for later rendering (after all points and connections)
                        allPoints[allPoints.length - 1].shouldLabel = true;
                        allPoints[allPoints.length - 1].labelText = state.labelMode === 'integers' ? `${k}` : `${k}/${m}`;
                    }
                }
            }

            // Connections
            if (state.connectionMode !== 'none') {
                ctx.globalAlpha = state.connectionOpacity;
                ctx.lineWidth = state.connectionThickness;

                // Helper function to check if point passes GCD filter
                const passesGCDFilter = (point) => {
                    if (state.gcdFilter === 'both') return true;
                    if (state.gcdFilter === 'coprime') return point.g === 1;
                    if (state.gcdFilter === 'noncoprime') return point.g !== 1;
                    return true;
                };

                // Filter points based on GCD selection
                const filteredPoints = allPoints.filter(passesGCDFilter);

                switch (state.connectionMode) {
                    case 'farey':
                        // Connect all Farey points (gcd=1) - respect GCD filter
                        const fareyPts = filteredPoints.filter(p => p.g === 1);
                        ctx.strokeStyle = CONFIG.colors.farey;
                        for (let i = 0; i < fareyPts.length - 1; i++) {
                            for (let j = i + 1; j < fareyPts.length; j++) {
                                ctx.beginPath();
                                ctx.moveTo(fareyPts[i].x, fareyPts[i].y);
                                ctx.lineTo(fareyPts[j].x, fareyPts[j].y);
                                ctx.stroke();
                            }
                        }
                        break;

                    case 'mod':
                        // Connect points on same ring - respect GCD filter
                        for (let m = state.minRing; m <= state.maxRing; m++) {
                            const ringPts = filteredPoints.filter(p => p.m === m);
                            ctx.strokeStyle = getGCDColor(2, m);
                            for (let i = 0; i < ringPts.length; i++) {
                                const next = ringPts[(i + 1) % ringPts.length];
                                ctx.beginPath();
                                ctx.moveTo(ringPts[i].x, ringPts[i].y);
                                ctx.lineTo(next.x, next.y);
                                ctx.stroke();
                            }
                        }
                        break;

                    case 'angle':
                        // Connect points with similar angles - respect GCD filter
                        const angleGroups = {};
                        filteredPoints.forEach(p => {
                            const key = Math.floor(p.angle * 100);
                            if (!angleGroups[key]) angleGroups[key] = [];
                            angleGroups[key].push(p);
                        });

                        ctx.strokeStyle = CONFIG.colors.cyan;
                        Object.values(angleGroups).forEach(group => {
                            if (group.length >= 2) {
                                group.sort((a, b) => a.radius - b.radius);
                                for (let i = 0; i < group.length - 1; i++) {
                                    ctx.beginPath();
                                    ctx.moveTo(group[i].x, group[i].y);
                                    ctx.lineTo(group[i + 1].x, group[i + 1].y);
                                    ctx.stroke();
                                }
                            }
                        });
                        break;

                    case 'gcd':
                        // Connect points with same GCD - respect GCD filter
                        const gcdGroups = {};
                        filteredPoints.forEach(p => {
                            if (!gcdGroups[p.g]) gcdGroups[p.g] = [];
                            gcdGroups[p.g].push(p);
                        });

                        Object.entries(gcdGroups).forEach(([g, group]) => {
                            ctx.strokeStyle = getGCDColor(parseInt(g), state.maxRing);
                            for (let i = 0; i < group.length - 1; i++) {
                                ctx.beginPath();
                                ctx.moveTo(group[i].x, group[i].y);
                                ctx.lineTo(group[i + 1].x, group[i + 1].y);
                                ctx.stroke();
                            }
                        });
                        break;

                    case 'fraction':
                        // Connect points with same fraction value - respect GCD filter
                        const fracGroups = {};
                        filteredPoints.forEach(p => {
                            const key = Math.floor(p.frac * 10000);
                            if (!fracGroups[key]) fracGroups[key] = [];
                            fracGroups[key].push(p);
                        });

                        ctx.strokeStyle = CONFIG.colors.geodesic;
                        Object.values(fracGroups).forEach(group => {
                            if (group.length >= 2) {
                                for (let i = 0; i < group.length - 1; i++) {
                                    ctx.beginPath();
                                    ctx.moveTo(group[i].x, group[i].y);
                                    ctx.lineTo(group[i + 1].x, group[i + 1].y);
                                    ctx.stroke();
                                }
                            }
                        });
                        break;
                    
                    case 'gap2n':
                        // Connect r to r+gap (gap-2n connections) - respect GCD filter
                        // Group filtered points by modulus first
                        const modGroups = {};
                        filteredPoints.forEach(p => {
                            if (!modGroups[p.m]) modGroups[p.m] = [];
                            modGroups[p.m].push(p);
                        });
                        
                        ctx.strokeStyle = '#e67e22';
                        Object.entries(modGroups).forEach(([m, points]) => {
                            const mod = parseInt(m);
                            const gap = state.gapSize;
                            
                            // For each point r, find r+gap (mod m)
                            points.forEach(p1 => {
                                const targetK = (p1.k + gap) % mod;
                                const p2 = points.find(p => p.k === targetK);
                                
                                if (p2) {
                                    ctx.beginPath();
                                    ctx.moveTo(p1.x, p1.y);
                                    ctx.lineTo(p2.x, p2.y);
                                    ctx.stroke();
                                }
                            });
                        });
                        break;

                    case 'evengaps':
                        // Multiple even gaps - respect GCD filter
                        const modGroupsMulti = {};
                        filteredPoints.forEach(p => {
                            if (!modGroupsMulti[p.m]) modGroupsMulti[p.m] = [];
                            modGroupsMulti[p.m].push(p);
                        });
                        
                        // Generate colors for different gaps
                        const gapColors = [];
                        for (let g = 2; g <= state.maxGap; g += 2) {
                            const hue = (g / state.maxGap) * 360;
                            gapColors.push(`hsla(${hue}, 85%, 65%, 0.7)`);
                        }
                        
                        Object.entries(modGroupsMulti).forEach(([m, points]) => {
                            const mod = parseInt(m);
                            
                            let gapIndex = 0;
                            for (let gap = 2; gap <= state.maxGap; gap += 2) {
                                ctx.strokeStyle = gapColors[gapIndex];
                                
                                points.forEach(p1 => {
                                    const targetK = (p1.k + gap) % mod;
                                    const p2 = points.find(p => p.k === targetK);
                                    
                                    if (p2) {
                                        ctx.beginPath();
                                        ctx.moveTo(p1.x, p1.y);
                                        ctx.lineTo(p2.x, p2.y);
                                        ctx.stroke();
                                    }
                                });
                                
                                gapIndex++;
                            }
                        });
                        break;
                }

                ctx.globalAlpha = 1.0;
            }

            // Global r‚Üír connections (vertical self-similarity)
            if (document.getElementById('toggleShowRtoR').checked) {
                ctx.globalAlpha = 0.4;
                ctx.lineWidth = 1.5;
                
                // Group all points by their residue value k (the integer)
                const residueGroups = {};
                allPoints.forEach(p => {
                    if (!residueGroups[p.k]) residueGroups[p.k] = [];
                    residueGroups[p.k].push(p);
                });
                
                // For each residue k, connect all instances across rings
                Object.values(residueGroups).forEach(group => {
                    if (group.length < 2) return;
                    
                    // Sort by ring radius
                    group.sort((a, b) => a.radius - b.radius);
                    
                    // Determine color based on coprimality
                    const allCoprime = group.every(p => p.g === 1);
                    ctx.strokeStyle = allCoprime ? CONFIG.colors.farey : 'rgba(100, 150, 255, 0.6)';
                    
                    // Draw connections between consecutive rings
                    for (let i = 0; i < group.length - 1; i++) {
                        ctx.beginPath();
                        ctx.moveTo(group[i].x, group[i].y);
                        ctx.lineTo(group[i + 1].x, group[i + 1].y);
                        ctx.stroke();
                    }
                });
                
                ctx.globalAlpha = 1.0;
            }

            // Global r‚Üír+m√ó2‚Åø connections (power-of-2 lifts)
            if (document.getElementById('toggleShowRtoRplus2n').checked) {
                ctx.globalAlpha = 0.35;
                ctx.lineWidth = 1.2;
                
                // For each ring, connect r to r+m in the next ring
                for (let m = state.minRing; m < state.maxRing; m++) {
                    const currentRingPoints = allPoints.filter(p => p.m === m);
                    const nextRingPoints = allPoints.filter(p => p.m === (m + 1));
                    
                    if (nextRingPoints.length === 0) continue;
                    
                    currentRingPoints.forEach(p1 => {
                        // Find target in next ring: r + m (mod m+1)
                        // Since m+1 contains all of {0,1,...,m}, we look for k values:
                        // r, r+m, r+2m, ... that exist in the next ring
                        
                        // For power of 2 structure: connect r to r (same k value)
                        const sameK = nextRingPoints.find(p2 => p2.k === p1.k);
                        
                        // And connect to r+m if it exists
                        const shiftedK = nextRingPoints.find(p2 => p2.k === p1.k + m);
                        
                        // Color based on coprimality
                        const isCoprime = p1.g === 1;
                        ctx.strokeStyle = isCoprime ? 
                            'rgba(255, 100, 100, 0.7)' : 
                            'rgba(150, 150, 200, 0.5)';
                        
                        if (sameK) {
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(sameK.x, sameK.y);
                            ctx.stroke();
                        }
                        
                        if (shiftedK) {
                            ctx.setLineDash([3, 3]);
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(shiftedK.x, shiftedK.y);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                    });
                }
                
                ctx.globalAlpha = 1.0;
            }

            // Highlight custom Farey points if they exist in range
            state.fareyPoints.forEach(fp => {
                if (fp.den >= state.minRing && fp.den <= state.maxRing) {
                    const m = fp.den;
                    const k = fp.num % m;
                    
                    // Calculate ring index with inversion
                    let ringIndex;
                    if (invertRings) {
                        ringIndex = (state.maxRing - m);
                    } else {
                        ringIndex = m - state.minRing;
                    }
                    
                    const ringRadius = baseRadius + ringIndex * (maxRadius - baseRadius) / Math.max(1, numRings - 1) * state.ringSpacing;
                    
                    // Use per-ring preset rotation if available, otherwise use global rotation
                    let ringRotationOffset;
                    if (state.perRingRotations && state.perRingRotations[m] !== undefined) {
                        ringRotationOffset = state.perRingRotations[m] * Math.PI / 180;
                    } else {
                        ringRotationOffset = (state.ringRotation * Math.PI / 180) * ringIndex;
                    }
                    
                    const angle = 2 * Math.PI * k / m + phase + ringRotationOffset;
                    const x = cx + ringRadius * Math.cos(angle);
                    const y = cy + ringRadius * Math.sin(angle);

                    ctx.strokeStyle = '#ff6b6b';
                    ctx.fillStyle = 'rgba(255, 107, 107, 0.3)';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff6b6b';
                    ctx.beginPath();
                    ctx.arc(x, y, 10, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            });

            // Render all labels AFTER all points and connections (so labels are on top)
            allPoints.forEach(point => {
                if (point.shouldLabel) {
                    const g = point.g;
                    const angle = point.angle;
                    const ringRadius = point.radius;
                    
                    ctx.fillStyle = g === 1 ? CONFIG.colors.farey : 'rgba(255, 255, 255, 0.6)';
                    ctx.font = `${state.labelSize - 2}px "Fira Code"`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const labelText = point.labelText;
                    
                    // Calculate label position
                    let labelX, labelY;
                    if (state.labelPosition === 'radial') {
                        // Position label radially outward from center
                        const labelRadius = ringRadius + state.labelOffset;
                        labelX = cx + labelRadius * Math.cos(angle);
                        labelY = cy + labelRadius * Math.sin(angle);
                    } else {
                        // Position on point
                        labelX = point.x;
                        labelY = point.y;
                    }
                    
                    // Add background for better readability
                    ctx.save();
                    const textMetrics = ctx.measureText(labelText);
                    const textWidth = textMetrics.width;
                    const textHeight = state.labelSize - 2;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(labelX - textWidth/2 - 2, labelY - textHeight/2 - 1, textWidth + 4, textHeight + 2);
                    
                    ctx.fillStyle = g === 1 ? CONFIG.colors.farey : 'rgba(255, 255, 255, 0.9)';
                    ctx.shadowBlur = 3;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillText(labelText, labelX, labelY);
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
            });

            // Render Farey point labels AFTER everything else (highest priority)
            if (state.labelMode !== 'none') {
                state.fareyPoints.forEach(fp => {
                    if (fp.den >= state.minRing && fp.den <= state.maxRing) {
                        const m = fp.den;
                        const k = fp.num % m;
                        
                        // Calculate ring index with inversion
                        let ringIndex;
                        if (invertRings) {
                            ringIndex = (state.maxRing - m);
                        } else {
                            ringIndex = m - state.minRing;
                        }
                        
                        const ringRadius = baseRadius + ringIndex * (maxRadius - baseRadius) / Math.max(1, numRings - 1) * state.ringSpacing;
                        
                        // Use per-ring preset rotation if available, otherwise use global rotation
                        let ringRotationOffset;
                        if (state.perRingRotations && state.perRingRotations[m] !== undefined) {
                            ringRotationOffset = state.perRingRotations[m] * Math.PI / 180;
                        } else {
                            ringRotationOffset = (state.ringRotation * Math.PI / 180) * ringIndex;
                        }
                        
                        const angle = 2 * Math.PI * k / m + phase + ringRotationOffset;
                        
                        // Calculate label position
                        let labelX, labelY;
                        if (state.labelPosition === 'radial') {
                            const labelRadius = ringRadius + state.labelOffset;
                            labelX = cx + labelRadius * Math.cos(angle);
                            labelY = cy + labelRadius * Math.sin(angle);
                        } else {
                            labelX = cx + ringRadius * Math.cos(angle);
                            labelY = cy + ringRadius * Math.sin(angle);
                        }
                        
                        // Farey label (in format matching the label mode)
                        const labelText = state.labelMode === 'integers' ? `${k}` : `${fp.num}/${fp.den}`;
                        
                        ctx.font = `bold ${state.labelSize + 2}px "Fira Code"`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Background
                        const textMetrics = ctx.measureText(labelText);
                        const textWidth = textMetrics.width;
                        const textHeight = state.labelSize + 2;
                        
                        ctx.fillStyle = 'rgba(255, 107, 107, 0.9)';
                        ctx.fillRect(labelX - textWidth/2 - 3, labelY - textHeight/2 - 1, textWidth + 6, textHeight + 2);
                        
                        // Text
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
                        ctx.fillText(labelText, labelX, labelY);
                        ctx.shadowBlur = 0;
                    }
                });
            }

            // Title removed to avoid duplication on export
            // ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            // ctx.font = 'bold 20px "Fira Code"';
            // ctx.textAlign = 'center';
            // ctx.shadowBlur = 10;
            // ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            // ctx.fillText('Nested Modular Rings', cx, 35);
            // ctx.font = '12px "Fira Code"';
            // ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            // ctx.fillText(`m = ${state.minRing} to ${state.maxRing}`, cx, 55);
            // ctx.shadowBlur = 0;

            // Draw selection highlight if point is selected on this canvas
            if (inspectionState.selectedPoint && inspectionState.selectedPoint.canvasType === 'nested') {
                const sp = inspectionState.selectedPoint;
                drawSelectionHighlight(ctx, sp.x, sp.y, sp.type);
            }

            // Restore context if inverted
            if (invertAll) {
                ctx.restore();
            }
        }

        // Advanced color scheme system
        const colorSchemes = {
            default: [
                {pos: 0, r: 100, g: 200, b: 255},
                {pos: 1, r: 255, g: 100, b: 100}
            ],
            fire: [
                {pos: 0, r: 0, g: 0, b: 0},
                {pos: 0.33, r: 139, g: 0, b: 0},
                {pos: 0.66, r: 255, g: 69, b: 0},
                {pos: 0.85, r: 255, g: 165, b: 0},
                {pos: 1, r: 255, g: 255, b: 100}
            ],
            plasma: [
                {pos: 0, r: 13, g: 8, b: 135},
                {pos: 0.25, r: 126, g: 3, b: 168},
                {pos: 0.5, r: 204, g: 71, b: 120},
                {pos: 0.75, r: 248, g: 149, b: 64},
                {pos: 1, r: 240, g: 249, b: 33}
            ],
            viridis: [
                {pos: 0, r: 68, g: 1, b: 84},
                {pos: 0.25, r: 59, g: 82, b: 139},
                {pos: 0.5, r: 33, g: 145, b: 140},
                {pos: 0.75, r: 94, g: 201, b: 98},
                {pos: 1, r: 253, g: 231, b: 37}
            ],
            cool: [
                {pos: 0, r: 0, g: 255, b: 255},
                {pos: 0.5, r: 100, g: 100, b: 255},
                {pos: 1, r: 255, g: 0, b: 255}
            ],
            thermal: [
                {pos: 0, r: 0, g: 0, b: 0},
                {pos: 0.33, r: 139, g: 0, b: 0},
                {pos: 0.66, r: 255, g: 140, b: 0},
                {pos: 0.9, r: 255, g: 255, b: 0},
                {pos: 1, r: 255, g: 255, b: 255}
            ],
            ocean: [
                {pos: 0, r: 0, g: 0, b: 51},
                {pos: 0.25, r: 0, g: 51, b: 102},
                {pos: 0.5, r: 0, g: 102, b: 204},
                {pos: 0.75, r: 51, g: 153, b: 255},
                {pos: 1, r: 153, g: 255, b: 255}
            ],
            sunset: [
                {pos: 0, r: 25, g: 25, b: 112},
                {pos: 0.3, r: 138, g: 43, b: 226},
                {pos: 0.6, r: 255, g: 99, b: 71},
                {pos: 0.85, r: 255, g: 165, b: 0},
                {pos: 1, r: 255, g: 255, b: 153}
            ],
            forest: [
                {pos: 0, r: 0, g: 51, b: 0},
                {pos: 0.33, r: 34, g: 139, b: 34},
                {pos: 0.66, r: 144, g: 238, b: 144},
                {pos: 1, r: 255, g: 255, b: 224}
            ],
            rainbow: [
                {pos: 0, r: 148, g: 0, b: 211},
                {pos: 0.17, r: 75, g: 0, b: 130},
                {pos: 0.33, r: 0, g: 0, b: 255},
                {pos: 0.5, r: 0, g: 255, b: 0},
                {pos: 0.67, r: 255, g: 255, b: 0},
                {pos: 0.83, r: 255, g: 127, b: 0},
                {pos: 1, r: 255, g: 0, b: 0}
            ],
            grayscale: [
                {pos: 0, r: 0, g: 0, b: 0},
                {pos: 1, r: 255, g: 255, b: 255}
            ]
        };
        
        function getColorFromScheme(scheme, t) {
            // Get the color scheme, default to 'default' if not found
            const colors = colorSchemes[scheme] || colorSchemes.default;
            
            // Clamp t to [0, 1]
            t = Math.max(0, Math.min(1, t));
            
            // Find the two colors to interpolate between
            for (let i = 0; i < colors.length - 1; i++) {
                if (t >= colors[i].pos && t <= colors[i + 1].pos) {
                    // Calculate local t within this segment
                    const localT = (t - colors[i].pos) / (colors[i + 1].pos - colors[i].pos);
                    
                    // Linear interpolation
                    return {
                        r: Math.round(colors[i].r + (colors[i + 1].r - colors[i].r) * localT),
                        g: Math.round(colors[i].g + (colors[i + 1].g - colors[i].g) * localT),
                        b: Math.round(colors[i].b + (colors[i + 1].b - colors[i].b) * localT)
                    };
                }
            }
            
            // If t is at or beyond the end, return the last color
            return colors[colors.length - 1];
        }
        
        // Format rotation value with smart precision (up to 17 decimal places)
        function formatRotationValue(value) {
            // If it's a whole number, show no decimals
            if (value === Math.floor(value)) {
                return value.toFixed(0);
            }
            
            // For very small rotations (like 1/101 = 3.564356...)
            // Show up to 17 decimal places but remove trailing zeros
            let str = value.toFixed(17);
            
            // Remove trailing zeros
            str = str.replace(/\.?0+$/, '');
            
            // If still very long, limit to 10 significant decimals for display
            const parts = str.split('.');
            if (parts[1] && parts[1].length > 10) {
                return value.toFixed(10).replace(/\.?0+$/, '');
            }
            
            return str;
        }

        // Update color scheme preview gradient
        function updateColorSchemePreview() {
            const scheme = state.nestedColorScheme;
            const previewEl = document.getElementById('colorSchemePreview');
            
            if (!previewEl) return;
            
            // For non-gradient schemes, hide preview
            const gradientSchemes = ['default', 'fire', 'plasma', 'viridis', 'cool', 'thermal', 'ocean', 'sunset', 'rainbow', 'grayscale'];
            
            if (!gradientSchemes.includes(scheme)) {
                previewEl.style.display = 'none';
                return;
            }
            
            previewEl.style.display = 'block';
            
            // Create gradient preview
            const steps = 50;
            let gradient = 'linear-gradient(to right';
            
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const color = getColorFromScheme(scheme, t);
                gradient += `, rgb(${color.r}, ${color.g}, ${color.b})`;
            }
            
            gradient += ')';
            previewEl.style.background = gradient;
        }

        function updateAll() {
            // Draw canvases 1-6
            drawDisk();
            drawCayley();
            drawNested();
            drawReduction();
            drawPixiPrimitiveRoots();
            
            // Draw full plane if visible
            if (document.getElementById('toggleFullPlane') && document.getElementById('toggleFullPlane').checked) {
                drawFullPlane();
            }
            
            // Draw canvases 7-12
            drawCanvas7();
            drawCanvas8();
            drawCanvas9();
            drawCanvas10();
            drawCanvas11();
            drawCanvas12();
            
            // Update stats if panel is visible
            if (document.getElementById('statsPanel') && document.getElementById('statsPanel').style.display !== 'none') {
                updateStats();
            }
            
            // Continue animation if point is selected (for pulsing highlight)
            if (inspectionState.selectedPoint && !state.animationId) {
                requestAnimationFrame(updateAll);
            }
        }

        // ============================================================
        // PER-RING ROTATION PRESETS
        // ============================================================
        
        let rotationPresetAnimation = null;
        
        function updatePresetLabel(presetType) {
            if (presetType === 'k/d') {
                const k = parseInt(document.getElementById('kdNumerator').value) || 1;
                const d = parseInt(document.getElementById('kdDenominator').value) || 2;
                document.getElementById('kdPresetLabel').textContent = k + '/' + d;
            }
        }
        
        function setRingRotationPreset(preset) {
            // Stop any running preset animation
            if (rotationPresetAnimation) {
                clearInterval(rotationPresetAnimation);
                rotationPresetAnimation = null;
                const btn = document.getElementById('rotationAnimateBtn');
                btn.querySelector('span').textContent = '‚ñ∂ Animate';
            }
            
            const applyToAll = document.getElementById('applyPresetsToAllCanvas').checked;
            
            // Get k/d values from inputs
            const k = parseInt(document.getElementById('kdNumerator').value) || 1;
            const d = parseInt(document.getElementById('kdDenominator').value) || 2;
            
            let rotationIncrement;
            
            switch(preset) {
                case 'k/d':
                    // Calculate rotation as fraction of full circle
                    // k/d √ó 360¬∞ = degrees per ring
                    // Example: 1/2 √ó 360¬∞ = 180¬∞ per ring
                    //          1/4 √ó 360¬∞ = 90¬∞ per ring
                    //          2/3 √ó 360¬∞ = 240¬∞ per ring
                    const fraction = k / d;
                    rotationIncrement = 360 * fraction;
                    break;
                    
                case '0':
                    // No rotation
                    rotationIncrement = 0;
                    break;
            }
            
            // Set the per-ring rotation increment (degrees per ring)
            state.ringRotation = rotationIncrement;
            
            // Clear any individual per-ring rotations since we're using global increment
            state.perRingRotations = null;
            
            // Update UI
            document.getElementById('ringRotationValue').textContent = formatRotationValue(rotationIncrement) + '¬∞';
            document.getElementById('ringRotationValue2').textContent = formatRotationValue(rotationIncrement) + '¬∞';
            document.getElementById('ringRotationSlider').value = rotationIncrement;
            document.getElementById('ringRotationSlider2').value = rotationIncrement;
            document.getElementById('ringRotationInput').value = rotationIncrement;
            document.getElementById('ringRotationInput2').value = rotationIncrement;
            
            // If "apply to all canvases" is checked, also set global phase rotation
            if (applyToAll) {
                state.phase = rotationIncrement;
                
                // Update phase UI
                document.getElementById('phaseValue').textContent = rotationIncrement.toFixed(0) + '¬∞';
                document.getElementById('phaseSlider').value = rotationIncrement;
                document.getElementById('phaseInput').value = rotationIncrement.toFixed(1);
            }
            
            updateAll();
        }
        
        function animateRotationPresets() {
            const btn = document.getElementById('rotationAnimateBtn');
            
            if (rotationPresetAnimation) {
                // Stop animation
                clearInterval(rotationPresetAnimation);
                rotationPresetAnimation = null;
                btn.querySelector('span').textContent = '‚ñ∂ Animate';
                return;
            }
            
            // Start animation cycling through presets
            btn.querySelector('span').textContent = '‚è∏ Stop';
            const presets = ['k/d', '0'];
            let currentPreset = 0;
            
            setRingRotationPreset(presets[currentPreset]);
            
            rotationPresetAnimation = setInterval(() => {
                currentPreset = (currentPreset + 1) % presets.length;
                setRingRotationPreset(presets[currentPreset]);
            }, 2000); // Switch every 2 seconds
        }

        // ============================================================
        // PHASE ANIMATION
        // ============================================================
        
        let phaseAnimationId = null;
        let phaseAnimationStart = 0;
        
        function resetAllZoom() {
            // Reset all zoom values to 100%
            state.diskZoom = 1.0;
            state.cayleyZoom = 1.0;
            state.nestedZoom = 1.0;
            state.reductionZoom = 1.0;
            state.fullPlaneZoom = 1.0;
            state.primitiveZoom = 1.0;
            
            // Update all displays
            document.getElementById('diskZoomValue').textContent = '100%';
            document.getElementById('cayleyZoomValue').textContent = '100%';
            document.getElementById('nestedZoomValue').textContent = '100%';
            document.getElementById('reductionZoomValue').textContent = '100%';
            document.getElementById('fullPlaneZoomValue').textContent = '100%';
            document.getElementById('primitiveZoomValue').textContent = '100%';
            document.getElementById('masterZoomValue').textContent = '100%';
            
            // Update all sliders
            document.getElementById('diskZoomSlider').value = 100;
            document.getElementById('cayleyZoomSlider').value = 100;
            document.getElementById('nestedZoomSlider').value = 100;
            document.getElementById('reductionZoomSlider').value = 100;
            document.getElementById('fullPlaneZoomSlider').value = 100;
            document.getElementById('primitiveZoomSlider').value = 100;
            document.getElementById('masterZoomSlider').value = 100;
            
            if (!state.animationId) updateAll();
        }

        function togglePhaseAnimation() {
            const btn = document.getElementById('phaseAnimateBtn');
            
            if (phaseAnimationId) {
                // Stop animation
                cancelAnimationFrame(phaseAnimationId);
                phaseAnimationId = null;
                btn.querySelector('span').textContent = '‚ñ∂ Animate 360¬∞';
                return;
            }
            
            // Start animation
            btn.querySelector('span').textContent = '‚è∏ Stop';
            phaseAnimationStart = state.phase;
            const targetPhase = phaseAnimationStart + 360;
            const loop = document.getElementById('phaseLoopCheck').checked;
            const speed = parseFloat(document.getElementById('phaseSpeedSlider').value);
            const duration = 4000 / speed; // Base duration 4 seconds
            
            const startTime = performance.now();
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Linear interpolation
                const currentPhase = phaseAnimationStart + (360 * progress);
                state.phase = currentPhase % 360;
                
                // Update UI
                document.getElementById('phaseValue').textContent = state.phase.toFixed(0) + '¬∞';
                document.getElementById('phaseSlider').value = state.phase;
                document.getElementById('phaseInput').value = state.phase.toFixed(1);
                
                updateAll();
                
                if (progress < 1) {
                    phaseAnimationId = requestAnimationFrame(animate);
                } else if (loop) {
                    // Restart animation
                    phaseAnimationStart = state.phase % 360;
                    requestAnimationFrame((t) => {
                        startTime = t;
                        animate(t);
                    });
                } else {
                    // Animation complete
                    phaseAnimationId = null;
                    btn.querySelector('span').textContent = '‚ñ∂ Animate 360¬∞';
                }
            }
            
            phaseAnimationId = requestAnimationFrame(animate);
        }
        
        // Update speed display
        document.getElementById('phaseSpeedSlider').addEventListener('input', e => {
            document.getElementById('phaseSpeedValue').textContent = parseFloat(e.target.value).toFixed(1) + 'x';
        });

        // ============================================================
        // CONTROL SYNC FUNCTIONS (for duplicate controls in Basic Parameters)
        // ============================================================
        
        function syncMinRing(value) {
            const val = parseInt(value);
            state.minRing = val;
            document.getElementById('minRingDisplay').textContent = val;
            document.getElementById('minRingDisplay2').textContent = val;
            document.getElementById('minRingInput').value = val;
            document.getElementById('minRingInput2').value = val;
            updateAll();
        }
        
        function syncMaxRing(value) {
            const val = parseInt(value);
            state.maxRing = val;
            document.getElementById('maxRingDisplay').textContent = val;
            document.getElementById('maxRingDisplay2').textContent = val;
            document.getElementById('maxRingInput').value = val;
            document.getElementById('maxRingInput2').value = val;
            updateAll();
        }
        
        function syncSpacing(value) {
            const val = parseFloat(value);
            state.ringSpacing = val;
            document.getElementById('spacingValue').textContent = val.toFixed(1);
            document.getElementById('spacingValue2').textContent = val.toFixed(1);
            document.getElementById('spacingSlider').value = val;
            document.getElementById('spacingSlider2').value = val;
            if (!state.animationId) updateAll();
        }
        
        function syncRingRotation(value) {
            const val = parseFloat(value);
            state.ringRotation = val;
            document.getElementById('ringRotationValue').textContent = formatRotationValue(val) + '¬∞';
            document.getElementById('ringRotationValue2').textContent = formatRotationValue(val) + '¬∞';
            document.getElementById('ringRotationSlider').value = val;
            document.getElementById('ringRotationSlider2').value = val;
            document.getElementById('ringRotationInput').value = val;
            document.getElementById('ringRotationInput2').value = val;
            if (!state.animationId) updateAll();
        }

        // Angular layout mode functions
        function updateAngularLayoutMode(mode) {
            state.angularLayoutMode = mode;
            
            // Update help text
            if (mode === 'sequential') {
                document.getElementById('layoutModeHelp').textContent = 
                    'Sequential mode: residues 0, 1, 2, 3, ... placed in numerical order (0¬∞ ‚Üí 2œÄ)';
            } else {
                document.getElementById('layoutModeHelp').textContent = 
                    'Fractional mode: natural angular positions based on fraction k/m';
            }
            
            updateAll();
        }

        // Calculate angle based on layout mode
        // k = residue value, m = modulus
        function getLayoutAngle(k, m, phase, perRingOffset) {
            const phaseRad = phase * Math.PI / 180;
            
            if (state.angularLayoutMode === 'sequential') {
                // Sequential: residue k goes at position k
                // So residue 0 at 0¬∞, residue 1 at 2œÄ/m, residue 2 at 4œÄ/m, etc.
                // This places them in numerical order: 0, 1, 2, 3, ..., m-1
                return (2 * Math.PI * k / m) + phaseRad + perRingOffset;
            } else {
                // Fractional: natural angle based on k/m fraction
                // For Farey points p/q, this gives angle 2œÄ(p/q)
                return (2 * Math.PI * k / m) + phaseRad + perRingOffset;
            }
        }

        // Nested rings mode functions
        function updateNestedMode() {
            const mode = document.getElementById('nestedDisplayMode').value;
            document.getElementById('sequentialControls').style.display = 
                mode === 'sequential' ? 'block' : 'none';
            drawNested();
        }

        function getAngleForMapping(r, m, mapping) {
            const phase = state.phase * Math.PI / 180;
            switch(mapping) {
                case 'standard':
                    return 2 * Math.PI * r / m + phase;
                case 'reverse':
                    return -2 * Math.PI * r / m + phase;
                case 'complement':
                    return 2 * Math.PI * (m - r) / m + phase;
                case 'rotated':
                    return 2 * Math.PI * r / m - Math.PI / 2 + phase;
                default:
                    return 2 * Math.PI * r / m + phase;
            }
        }

        // GCD color palette
        const GCD_COLORS = {
            1: '#e74c3c',  // Red - coprime
            2: '#3498db',  // Blue
            3: '#2ecc71',  // Green
            4: '#f39c12',  // Orange
            5: '#9b59b6',  // Purple
            6: '#1abc9c',  // Teal
            default: '#95a5a6'  // Gray
        };

        // ============================================================
        // ANIMATION
        // ============================================================

        function startAnimation() {
            if (state.animationId !== null) return;

            function animate() {
                state.phase = (state.phase + state.animSpeed * 0.5) % 360;
                document.getElementById('phaseSlider').value = state.phase;
                document.getElementById('phaseValue').textContent = state.phase.toFixed(1) + '¬∞';
                updateAll();
                state.animationId = requestAnimationFrame(animate);
            }

            animate();
        }

        function stopAnimation() {
            if (state.animationId !== null) {
                cancelAnimationFrame(state.animationId);
                state.animationId = null;
            }
        }

        // ============================================================
        // UI CONTROLS
        // ============================================================

        function toggleIntro() {
            const panel = document.getElementById('introPanel');
            const toggle = document.getElementById('introToggle');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                toggle.innerHTML = '&#9660;';
            } else {
                panel.style.display = 'none';
                toggle.innerHTML = '&#9654;';
            }
        }

        function verifyCayleyTransform() {
            const resultsDiv = document.getElementById('verificationResults');
            resultsDiv.style.display = 'block';
            
            let html = '<h4 style="color: #3498db; margin-bottom: 10px;">Cayley Transform Verification Results:</h4>';
            
            const testPoints = [
                { z: { re: 0, im: 0 }, label: 'z = 0 (center)', expected: 'w = i (upper half-plane)' },
                { z: { re: 1, im: 0 }, label: 'z = 1 (right edge)', expected: 'w = ‚àû (real axis point at infinity)' },
                { z: { re: -1, im: 0 }, label: 'z = -1 (left edge)', expected: 'w = 0 (origin on real axis)' },
                { z: { re: 0, im: 1 }, label: 'z = i (top edge)', expected: 'w = 1 (real axis)' },
                { z: { re: 0, im: -1 }, label: 'z = -i (bottom edge)', expected: 'w = -1 (real axis)' },
                { z: { re: 0.5, im: 0 }, label: 'z = 0.5 (interior)', expected: 'Im(w) > 0' },
            ];
            
            testPoints.forEach(test => {
                const w = cayleyTransform(test.z, 'standard');
                const magnitude = Math.sqrt(test.z.re * test.z.re + test.z.im * test.z.im);
                const isInterior = magnitude < 0.99;
                const isBoundary = magnitude >= 0.99 && magnitude <= 1.01;
                
                let status = '‚úì';
                let color = '#2ecc71';
                
                // Check if mapping is correct
                if (isInterior && w.im <= 0.01) {
                    status = '‚úó';
                    color = '#e74c3c';
                } else if (isBoundary && Math.abs(w.im) > 0.1) {
                    status = '‚úó';
                    color = '#e74c3c';
                }
                
                html += `<div style="margin: 8px 0; padding: 8px; background: rgba(0,0,0,0.2); border-left: 3px solid ${color};">`;
                html += `<span style="color: ${color}; font-weight: bold;">${status}</span> `;
                html += `<strong>${test.label}</strong><br>`;
                html += `|z| = ${magnitude.toFixed(4)} ‚Üí `;
                html += `w = ${w.re.toFixed(4)} + ${w.im.toFixed(4)}i<br>`;
                html += `<span style="color: #95a5a6;">Expected: ${test.expected}</span>`;
                html += `</div>`;
            });
            
            // Overall assessment
            html += '<div style="margin-top: 15px; padding: 12px; background: rgba(255, 215, 0, 0.1); border: 2px solid #ffd700; border-radius: 4px;">';
            html += '<strong style="color: #ffd700;">Assessment:</strong><br>';
            html += 'The formula w = i(1-z)/(1+z) correctly maps:<br>';
            html += '‚Ä¢ Unit disk |z| &lt; 1 ‚Üí Upper half-plane Im(w) &gt; 0 ‚úì<br>';
            html += '‚Ä¢ Unit circle |z| = 1 ‚Üí Real axis Im(w) = 0 ‚úì<br>';
            html += '<br>This is the standard Cayley transform for hyperbolic geometry (Poincar√© disk ‚Üî upper half-plane).';
            html += '</div>';
            
            resultsDiv.innerHTML = html;
        }


        function toggleGuide() {
            const panel = document.getElementById('guidePanel');
            const toggle = document.getElementById('guideToggle');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                toggle.innerHTML = '&#9660;';
            } else {
                panel.style.display = 'none';
                toggle.innerHTML = '&#9654;';
            }
        }

        function toggleIntro() {
            const panel = document.getElementById('introPanel');
            const toggle = document.getElementById('introToggle');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                toggle.innerHTML = '&#9660;';
            } else {
                panel.style.display = 'none';
                toggle.innerHTML = '&#9654;';
            }
        }


        function resetDefaults() {
            state = {
                phase: 180,
                modulus: 101,
                numPrimes: 150,
                primeLimit: 10000,
                animSpeed: 1.0,
                minRing: 1,
                maxRing: 101,
                ringSpacing: 1.0,
                connectionMode: 'none',
                connectionThickness: 1.0,
                connectionOpacity: 0.3,
                labelMode: 'farey',
                labelSize: 10,
                labelFreq: 1,
                cayleyHRange: 6,
                cayleyVRange: 4,
                cayleyVOffset: 0,
                cayleyGridDensity: 1,
                transformType: 'standard',
                mobiusA: 1,
                mobiusB: 0,
                mobiusC: 0,
                mobiusD: 1,
                diskZoom: 1.0,
                cayleyZoom: 1.0,
                nestedZoom: 1.0,
                fareyPoints: [
                    {num: 0, den: 1},
                    {num: 1, den: 1},
                    {num: 0, den: 2},
                    {num: 1, den: 2},
                    {num: 0, den: 3},
                    {num: 1, den: 3},
                    {num: 2, den: 3},
                    {num: 0, den: 4},
                    {num: 1, den: 4},
                    {num: 3, den: 4},
                    {num: 0, den: 5},
                    {num: 1, den: 5},
                    {num: 2, den: 5},
                    {num: 3, den: 5},
                    {num: 4, den: 5}
                ],
                primes: state.primes,
                animationId: null
            };

            // Reset UI
            document.getElementById('phaseSlider').value = 180;
            document.getElementById('modulusInput').value = 101;
            document.getElementById('primesInput').value = 150;
            document.getElementById('primeLimitInput').value = 10000;
            document.getElementById('speedSlider').value = 1;
            document.getElementById('minRingInput').value = 1;
            document.getElementById('maxRingInput').value = 101;
            document.getElementById('spacingSlider').value = 1;
            document.getElementById('ringRotationSlider').value = 0;
            document.getElementById('ringRotationInput').value = 0;
            document.getElementById('cayleyHRangeSlider').value = 6;
            document.getElementById('cayleyVRangeSlider').value = 4;
            document.getElementById('cayleyVOffsetSlider').value = 0;
            document.getElementById('cayleyGridDensitySlider').value = 1;
            document.getElementById('connectionMode').value = 'none';
            document.getElementById('connectionThicknessSlider').value = 1;
            document.getElementById('connectionOpacitySlider').value = 0.3;
            document.getElementById('labelMode').value = 'farey';
            document.getElementById('labelSizeSlider').value = 10;
            document.getElementById('labelFreqInput').value = 1;
            document.getElementById('diskZoomSlider').value = 1;
            document.getElementById('cayleyZoomSlider').value = 1;
            document.getElementById('nestedZoomSlider').value = 1;
            document.getElementById('toggleAnimate').checked = false;
            document.getElementById('toggleFarey').checked = true;
            document.getElementById('toggleGeodesic').checked = true;
            document.getElementById('togglePrimes').checked = true;
            document.getElementById('toggleChannels').checked = true;
            document.getElementById('toggleCusps').checked = true;
            document.getElementById('toggleRings').checked = true;
            document.getElementById('toggleGCD').checked = true;
            document.getElementById('toggleGrid').checked = true;
            document.getElementById('toggleFundDomain').checked = false;
            document.getElementById('toggleVerticals').checked = false;
            document.getElementById('toggleDiskOutline').checked = false;
            document.getElementById('toggleFullPlane').checked = false;
            document.getElementById('toggleShowCoprimeOnly').checked = false;
            document.getElementById('toggleShowNonCoprimeOnly').checked = false;
            document.getElementById('cayleyTransformType').value = 'standard';
            document.getElementById('mobiusA').value = 1;
            document.getElementById('mobiusB').value = 0;
            document.getElementById('mobiusC').value = 0;
            document.getElementById('mobiusD').value = 1;
            document.getElementById('mobiusParamsA').style.display = 'none';
            document.getElementById('mobiusParamsB').style.display = 'none';
            document.getElementById('mobiusParamsC').style.display = 'none';
            document.getElementById('mobiusParamsD').style.display = 'none';
            document.getElementById('transformDescription').textContent = 'Standard: Maps unit disk to upper half-plane (modular forms)';

            document.getElementById('phaseValue').textContent = '180 degrees';
            document.getElementById('modulusDisplay').textContent = '101';
            document.getElementById('primesDisplay').textContent = '150';
            document.getElementById('primeLimitDisplay').textContent = '10000';
            document.getElementById('speedValue').textContent = '1.0√ó';
            document.getElementById('minRingDisplay').textContent = '1';
            document.getElementById('maxRingDisplay').textContent = '101';
            document.getElementById('spacingValue').textContent = '1.0';
            document.getElementById('ringRotationValue').textContent = '0¬∞';
            document.getElementById('cayleyHRangeValue').textContent = '6.0';
            document.getElementById('cayleyVRangeValue').textContent = '4.0';
            document.getElementById('cayleyVOffsetValue').textContent = '0.0';
            document.getElementById('cayleyGridDensityValue').textContent = '1.0';
            document.getElementById('connectionThicknessValue').textContent = '1.0';
            document.getElementById('connectionOpacityValue').textContent = '0.30';
            document.getElementById('labelSizeValue').textContent = '10';
            document.getElementById('labelFreqValue').textContent = '1';
            document.getElementById('labelPosition').value = 'radial';
            document.getElementById('labelOffsetSlider').value = 18;
            document.getElementById('labelOffsetValue').textContent = '18';
            document.getElementById('diskZoomValue').textContent = '1.00√ó';
            document.getElementById('cayleyZoomValue').textContent = '1.00√ó';
            document.getElementById('nestedZoomValue').textContent = '1.00√ó';
            document.getElementById('maxFareyOrder').textContent = '101';

            // Hide full plane panel
            document.getElementById('fullPlanePanel').style.display = 'none';
            document.getElementById('vizGrid').classList.remove('four-panel');

            stopAnimation();
            updateFareyPointsList();
            populateOrderDropdown(); // Initialize order dropdown
            updateAll();
        }

        // Export single canvas as 4K PNG
        function exportSingleCanvas(canvasId, filename) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error('Canvas not found:', canvasId);
                return;
            }

            // Canvas metadata for titles
            const canvasInfo = {
                'diskCanvas': { title: '1. Unit Disk - Farey & Primes', color: '#ffd700' },
                'cayleyCanvas': { title: '2. Cayley Plane - Hyperbolic Geometry', color: '#1abc9c' },
                'nestedCanvas': { title: '3. Nested Modular Rings', color: '#3498db' },
                'reductionCanvas': { title: '4. Modular Reduction', color: '#e67e22' },
                'fullPlaneCanvas': { title: '5. Full Complex Plane', color: '#9b59b6' },
                'primitiveRootsCanvas': { title: '6. Primitive Roots', color: '#e91e63' },
                'canvas7': { title: '7. Coprime Circle', color: '#2ecc71' },
                'canvas8': { title: '8. Phi Ratios Chart', color: '#f1c40f' },
                'canvas9': { title: '9. Convergence to 6/œÄ¬≤', color: '#e74c3c' },
                'canvas10': { title: '10. Coprime Pairs Grid', color: '#6366f1' },
                'canvas11': { title: '11. Nested Density Rings', color: '#27ae60' },
                'canvas12': { title: '12. Dirichlet Characters', color: '#9c27b0' }
            };

            const info = canvasInfo[canvasId] || { title: 'Canvas Export', color: '#ffd700' };

            // Create a 2K export canvas with space for title and legend
            const exportCanvas = document.createElement('canvas');
            const exportWidth = 2000;
            const exportHeight = 2200; // Extra space for title and legend
            exportCanvas.width = exportWidth;
            exportCanvas.height = exportHeight;
            
            const ctx = exportCanvas.getContext('2d');
            
            // Fill background
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, exportWidth, exportHeight);
            
            // Draw title at top
            ctx.fillStyle = info.color;
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(info.title, exportWidth / 2, 60);
            
            // Draw subtitle
            ctx.fillStyle = '#ffffff';
            ctx.font = '28px Arial';
            ctx.fillText(`Modulus M = ${state.modulus} | Phase = ${state.phase.toFixed(1)}¬∞`, exportWidth / 2, 105);
            
            // Draw author credit
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.fillText('By Wessen Getachew', exportWidth / 2, 140);
            
            // Calculate scaling to fit canvas content
            const contentTop = 170;
            const contentHeight = exportHeight - contentTop - 50;
            const canvasAspect = canvas.width / canvas.height;
            
            let drawWidth = exportWidth - 100;
            let drawHeight = drawWidth / canvasAspect;
            
            if (drawHeight > contentHeight) {
                drawHeight = contentHeight;
                drawWidth = drawHeight * canvasAspect;
            }
            
            const drawX = (exportWidth - drawWidth) / 2;
            const drawY = contentTop;
            
            // Draw the canvas content
            ctx.drawImage(canvas, drawX, drawY, drawWidth, drawHeight);
            
            // Draw legend/info box at bottom
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(50, exportHeight - 40, exportWidth - 100, 35);
            ctx.fillStyle = info.color;
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            const timestamp = new Date().toISOString().split('T')[0];
            ctx.fillText(`Interactive Modular Arithmetic Research Suite | ${timestamp}`, exportWidth / 2, exportHeight - 15);
            
            // Download
            exportCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename.replace('4k', '2k');
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        // Export Pixi canvas (Primitive Roots)
        function exportPixiCanvas() {
            if (!canvases.pixiApp || !canvases.pixiApp.renderer) {
                console.error('Pixi app not initialized');
                return;
            }

            try {
                // Extract image from Pixi renderer
                const app = canvases.pixiApp;
                const scale = 4; // 4K resolution
                
                // Create temporary renderer at higher resolution
                const tempApp = new PIXI.Application({
                    width: app.view.width * scale,
                    height: app.view.height * scale,
                    backgroundColor: 0x0a0e27,
                    antialias: true,
                    resolution: scale,
                    preserveDrawingBuffer: true
                });
                
                // Copy the stage
                tempApp.stage.addChild(app.stage.clone());
                
                // Render and extract
                tempApp.renderer.render(tempApp.stage);
                const imageData = tempApp.renderer.view.toDataURL('image/png');
                
                // Download
                const a = document.createElement('a');
                a.href = imageData;
                a.download = 'primitive_roots_4k.png';
                a.click();
                
                // Cleanup
                tempApp.destroy(true);
            } catch (error) {
                console.error('Error exporting Pixi canvas:', error);
                // Fallback: export current view
                const imageData = canvases.pixiApp.renderer.view.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = imageData;
                a.download = 'primitive_roots.png';
                a.click();
            }
        }

        function exportVisualization() {
            // Create export dialog if it doesn't exist
            if (!document.getElementById('exportDialog')) {
                createExportDialog();
            }
            showExportDialog();
        }

        function createExportDialog() {
            const dialog = document.createElement('div');
            dialog.id = 'exportDialog';
            dialog.className = 'export-dialog';
            dialog.style.display = 'none';
            
            dialog.innerHTML = `
                <div class="export-dialog-content">
                    <div class="export-dialog-header">
                        <h3>Export Visualization</h3>
                        <button class="close-btn" onclick="closeExportDialog()">‚úï</button>
                    </div>
                    <div class="export-dialog-body">
                        <div class="export-section">
                            <h4>Select Canvases (Choose Any Combination)</h4>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 12px;">
                                <label class="export-checkbox" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 4px; cursor: pointer;">
                                    <input type="checkbox" class="canvas-checkbox" value="disk" checked>
                                    <span style="width: 16px; height: 16px; background: #ffd700; border-radius: 2px; flex-shrink: 0;"></span>
                                    <span style="flex: 1;">1. Unit Disk ùîª</span>
                                </label>
                                <label class="export-checkbox" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 4px; cursor: pointer;">
                                    <input type="checkbox" class="canvas-checkbox" value="cayley" checked>
                                    <span style="width: 16px; height: 16px; background: #1abc9c; border-radius: 2px; flex-shrink: 0;"></span>
                                    <span style="flex: 1;">2. Cayley Plane ‚Ñç</span>
                                </label>
                                <label class="export-checkbox" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 4px; cursor: pointer;">
                                    <input type="checkbox" class="canvas-checkbox" value="nested" checked>
                                    <span style="width: 16px; height: 16px; background: #3498db; border-radius: 2px; flex-shrink: 0;"></span>
                                    <span style="flex: 1;">3. Nested Rings ‚äö</span>
                                </label>
                                <label class="export-checkbox" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 4px; cursor: pointer;">
                                    <input type="checkbox" class="canvas-checkbox" value="reduction" checked>
                                    <span style="width: 16px; height: 16px; background: #e67e22; border-radius: 2px; flex-shrink: 0;"></span>
                                    <span style="flex: 1;">4. Reduction ‚äó</span>
                                </label>
                                <label class="export-checkbox" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 4px; cursor: pointer;">
                                    <input type="checkbox" class="canvas-checkbox" value="fullplane" checked>
                                    <span style="width: 16px; height: 16px; background: #9b59b6; border-radius: 2px; flex-shrink: 0;"></span>
                                    <span style="flex: 1;">5. Full Plane ‚ÑÇ</span>
                                </label>
                                <label class="export-checkbox" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 4px; cursor: pointer;">
                                    <input type="checkbox" class="canvas-checkbox" value="primitiveroots" checked>
                                    <span style="width: 16px; height: 16px; background: #e91e63; border-radius: 2px; flex-shrink: 0;"></span>
                                    <span style="flex: 1;">6. Primitive Roots ‚öô</span>
                                </label>
                                <label class="export-checkbox" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 4px; cursor: pointer;">
                                    <input type="checkbox" class="canvas-checkbox" value="canvas7" checked>
                                    <span style="width: 16px; height: 16px; background: #2ecc71; border-radius: 2px; flex-shrink: 0;"></span>
                                    <span style="flex: 1;">7. Coprime Circle</span>
                                </label>
                                <label class="export-checkbox" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 4px; cursor: pointer;">
                                    <input type="checkbox" class="canvas-checkbox" value="canvas8" checked>
                                    <span style="width: 16px; height: 16px; background: #f1c40f; border-radius: 2px; flex-shrink: 0;"></span>
                                    <span style="flex: 1;">8. Phi Ratios</span>
                                </label>
                                <label class="export-checkbox" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 4px; cursor: pointer;">
                                    <input type="checkbox" class="canvas-checkbox" value="canvas9" checked>
                                    <span style="width: 16px; height: 16px; background: #e74c3c; border-radius: 2px; flex-shrink: 0;"></span>
                                    <span style="flex: 1;">9. Convergence</span>
                                </label>
                                <label class="export-checkbox" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 4px; cursor: pointer;">
                                    <input type="checkbox" class="canvas-checkbox" value="canvas10" checked>
                                    <span style="width: 16px; height: 16px; background: #6366f1; border-radius: 2px; flex-shrink: 0;"></span>
                                    <span style="flex: 1;">10. Coprime Grid</span>
                                </label>
                                <label class="export-checkbox" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 4px; cursor: pointer;">
                                    <input type="checkbox" class="canvas-checkbox" value="canvas11" checked>
                                    <span style="width: 16px; height: 16px; background: #27ae60; border-radius: 2px; flex-shrink: 0;"></span>
                                    <span style="flex: 1;">11. Density Rings</span>
                                </label>
                                <label class="export-checkbox" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 4px; cursor: pointer;">
                                    <input type="checkbox" class="canvas-checkbox" value="canvas12" checked>
                                    <span style="width: 16px; height: 16px; background: #9c27b0; border-radius: 2px; flex-shrink: 0;"></span>
                                    <span style="flex: 1;">12. Dirichlet Chars</span>
                                </label>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-secondary" onclick="selectAllCanvases()" style="flex: 1; padding: 8px; font-size: 0.9em;">
                                    <span>Select All</span>
                                </button>
                                <button class="btn btn-secondary" onclick="deselectAllCanvases()" style="flex: 1; padding: 8px; font-size: 0.9em;">
                                    <span>Deselect All</span>
                                </button>
                            </div>
                            <div id="canvasSelectionCount" style="margin-top: 8px; color: var(--cyan); font-size: 0.9em; text-align: center;">
                                12 canvases selected
                            </div>
                        </div>
                        
                        <div class="export-section">
                            <h4>Resolution</h4>
                            <div class="export-radio-group">
                                <label class="export-radio">
                                    <input type="radio" name="resolution" value="1080" checked>
                                    <span>Full HD (1920√ó1080)</span>
                                </label>
                                <label class="export-radio">
                                    <input type="radio" name="resolution" value="1440">
                                    <span>2K (2560√ó1440)</span>
                                </label>
                                <label class="export-radio">
                                    <input type="radio" name="resolution" value="4k">
                                    <span>4K UHD (3840√ó2160)</span>
                                </label>
                                <label class="export-radio">
                                    <input type="radio" name="resolution" value="8k">
                                    <span>8K UHD (7680√ó4320)</span>
                                </label>
                            </div>
                        </div>
                        
                        <div class="export-section">
                            <h4>Export Options</h4>
                            <label class="export-checkbox">
                                <input type="checkbox" id="includeTitle" checked>
                                <span>Include Canvas Title</span>
                            </label>
                            <label class="export-checkbox">
                                <input type="checkbox" id="includeLegend" checked>
                                <span>Include Detailed Legend</span>
                            </label>
                            
                            <!-- Export Style Selection -->
                            <div style="margin: 12px 0;">
                                <label class="control-label" style="color: var(--text); font-size: 0.9em; margin-bottom: 8px;">Export Style</label>
                                <select id="exportStyle" style="width: 100%; padding: 8px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 6px; color: var(--text);">
                                    <option value="standard">Standard (Legend Right)</option>
                                    <option value="professional">Professional Layout</option>
                                </select>
                            </div>
                            
                            <!-- Legend Size Control -->
                            <div style="margin-left: 24px; margin-top: 8px; margin-bottom: 12px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="color: rgba(255,255,255,0.7); font-size: 0.85em;">Legend Text Size</span>
                                    <span id="legendSizeValue" style="color: var(--accent); font-weight: bold; font-size: 0.85em;">100%</span>
                                </div>
                                <input type="range" id="legendSizeSlider" min="70" max="150" value="100" step="5" 
                                    style="width: 100%; height: 6px; background: linear-gradient(to right, var(--primary), var(--accent));"
                                    oninput="document.getElementById('legendSizeValue').textContent = this.value + '%'">
                            </div>
                            
                            <label class="export-checkbox">
                                <input type="checkbox" id="includeStatistics" checked>
                                <span>Include Statistical Analysis</span>
                            </label>
                            <label class="export-checkbox">
                                <input type="checkbox" id="includeWatermark" checked>
                                <span>Include Watermark (Wessen Getachew)</span>
                            </label>
                            <label class="export-checkbox">
                                <input type="checkbox" id="includeParameters" checked>
                                <span>Include Parameters in Legend</span>
                            </label>
                            <label class="export-checkbox">
                                <input type="checkbox" id="includeConnections" checked>
                                <span>Include Global Connections (r‚Üír, r‚Üír+m√ó2‚Åø)</span>
                            </label>
                        </div>
                        
                        <div class="action-bar">
                            <button class="btn btn-primary" onclick="performExport()">
                                <span>üíæ Export PNG</span>
                            </button>
                            <button class="btn btn-secondary" onclick="closeExportDialog()">
                                <span>Cancel</span>
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(dialog);
        }

        function showExportDialog() {
            document.getElementById('exportDialog').style.display = 'flex';
            updateCanvasSelectionCount();
            
            // Add event listeners to checkboxes to update count
            document.querySelectorAll('.canvas-checkbox').forEach(cb => {
                cb.addEventListener('change', updateCanvasSelectionCount);
            });
        }

        function closeExportDialog() {
            document.getElementById('exportDialog').style.display = 'none';
        }

        function selectAllCanvases() {
            document.querySelectorAll('.canvas-checkbox').forEach(cb => {
                cb.checked = true;
            });
            updateCanvasSelectionCount();
        }

        function deselectAllCanvases() {
            document.querySelectorAll('.canvas-checkbox').forEach(cb => {
                cb.checked = false;
            });
            updateCanvasSelectionCount();
        }

        function updateCanvasSelectionCount() {
            const count = document.querySelectorAll('.canvas-checkbox:checked').length;
            const countEl = document.getElementById('canvasSelectionCount');
            if (countEl) {
                countEl.textContent = `${count} canvas${count !== 1 ? 'es' : ''} selected`;
                countEl.style.color = count === 0 ? '#ff6666' : 'var(--cyan)';
            }
        }

        function exportMultipleCanvases(tempCanvas, tempCtx, selectedCanvases, baseSize, width, height,
            includeTitle, includeLegend, includeWatermark, includeParameters, legendSpace, legendSize) {
            
            // Canvas metadata with colors
            const canvasInfo = {
                'disk': { canvas: canvases.disk, title: '1. Unit Disk ùîª', color: '#ffd700', subtitle: 'Farey & Primes' },
                'cayley': { canvas: canvases.cayley, title: '2. Cayley Plane ‚Ñç', color: '#1abc9c', subtitle: 'Hyperbolic Geometry' },
                'nested': { canvas: canvases.nested, title: '3. Nested Rings ‚äö', color: '#3498db', subtitle: 'Modular Structure' },
                'reduction': { canvas: canvases.reduction, title: '4. Reduction ‚äó', color: '#e67e22', subtitle: 'Channel Projection' },
                'fullplane': { canvas: canvases.fullPlane, title: '5. Full Plane ‚ÑÇ', color: '#9b59b6', subtitle: 'Complete View' },
                'primitiveroots': { 
                    canvas: canvases.pixiApp ? canvases.pixiApp.renderer.view : null, 
                    title: '6. Primitive Roots ‚öô', 
                    color: '#e91e63',
                    subtitle: 'Cyclic Structure'
                },
                'canvas7': { canvas: canvases.canvas7, title: '7. Coprime Circle', color: '#2ecc71', subtitle: 'œÜ(M)/M Density' },
                'canvas8': { canvas: canvases.canvas8, title: '8. Phi Ratios', color: '#f1c40f', subtitle: 'œÜ(n)/n Chart' },
                'canvas9': { canvas: canvases.canvas9, title: '9. Convergence', color: '#e74c3c', subtitle: 'Limit to 6/œÄ¬≤' },
                'canvas10': { canvas: canvases.canvas10, title: '10. Coprime Grid', color: '#6366f1', subtitle: 'GCD Matrix' },
                'canvas11': { canvas: canvases.canvas11, title: '11. Density Rings', color: '#27ae60', subtitle: 'Nested View' },
                'canvas12': { canvas: canvases.canvas12, title: '12. Dirichlet', color: '#9c27b0', subtitle: 'Characters mod M' }
            };
            
            // Determine grid layout
            const count = selectedCanvases.length;
            let cols, rows;
            if (count <= 2) { cols = count; rows = 1; }
            else if (count <= 4) { cols = 2; rows = 2; }
            else if (count <= 6) { cols = 3; rows = 2; }
            else if (count <= 9) { cols = 3; rows = 3; }
            else if (count <= 12) { cols = 4; rows = 3; }
            else { cols = 4; rows = Math.ceil(count / 4); }
            
            const canvasSize = baseSize / Math.max(rows, cols);
            const gridWidth = canvasSize * cols;
            const gridHeight = canvasSize * rows;
            
            tempCanvas.width = gridWidth + legendSpace;
            tempCanvas.height = gridHeight;
            
            tempCtx.fillStyle = '#0a0e27';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Draw canvases in grid
            selectedCanvases.forEach((canvasKey, idx) => {
                const info = canvasInfo[canvasKey];
                if (!info || !info.canvas) return;
                
                const col = idx % cols;
                const row = Math.floor(idx / cols);
                const x = col * canvasSize;
                const y = row * canvasSize;
                
                // Draw canvas
                tempCtx.drawImage(info.canvas, 
                    0, 0, info.canvas.width, info.canvas.height,
                    x, y, canvasSize, canvasSize);
                
                // Draw colored border
                tempCtx.strokeStyle = info.color;
                tempCtx.lineWidth = 4;
                tempCtx.strokeRect(x, y, canvasSize, canvasSize);
                
                if (includeTitle) {
                    const scale = canvasSize / 1000;
                    const fontSize = Math.max(18, 24 * scale);
                    
                    // Title
                    tempCtx.fillStyle = info.color;
                    tempCtx.font = `bold ${fontSize}px "Fira Code"`;
                    tempCtx.textAlign = 'center';
                    tempCtx.textBaseline = 'top';
                    tempCtx.fillText(info.title, x + canvasSize / 2, y + 15 * scale);
                    
                    // Subtitle
                    tempCtx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    tempCtx.font = `${fontSize * 0.6}px "Fira Code"`;
                    tempCtx.fillText(info.subtitle, x + canvasSize / 2, y + (15 + fontSize * 1.3) * scale);
                }
            });
            
            // Draw legend if enabled
            if (includeLegend) {
                drawCompactMultiCanvasLegend(tempCtx, tempCanvas.width, tempCanvas.height, gridWidth, 
                    selectedCanvases, canvasInfo, includeParameters, legendSize);
            }
            
            if (includeWatermark) {
                drawWatermark(tempCtx, tempCanvas.width, tempCanvas.height);
            }
            
            // Download
            const link = document.createElement('a');
            link.download = `Farey_Cayley_${selectedCanvases.length}_Canvases_m${state.modulus}.png`;
            link.href = tempCanvas.toDataURL();
            link.click();
            
            closeExportDialog();
            alert(`Successfully exported ${selectedCanvases.length} canvas${selectedCanvases.length > 1 ? 'es' : ''}!`);
        }
        
        function drawCompactMultiCanvasLegend(ctx, canvasWidth, canvasHeight, gridWidth, selectedCanvases, canvasInfo, includeParameters, legendSize) {
            const legendX = gridWidth + 20;
            const legendWidth = canvasWidth - gridWidth - 40;
            const padding = 20;
            
            ctx.save();
            
            // Background
            ctx.fillStyle = 'rgba(10, 14, 39, 0.95)';
            ctx.fillRect(legendX, 20, legendWidth, canvasHeight - 40);
            
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.strokeRect(legendX, 20, legendWidth, canvasHeight - 40);
            
            let currentY = 50;
            const baseFont = Math.max(16, 22 * legendSize);
            const titleFont = Math.max(20, 28 * legendSize);
            const squareSize = baseFont * 1.2;
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = `bold ${titleFont}px "Fira Code"`;
            ctx.textAlign = 'left';
            ctx.fillText('EXPORT LEGEND', legendX + padding, currentY);
            currentY += titleFont * 2;
            
            // Canvases section
            ctx.fillStyle = '#00ffff';
            ctx.font = `bold ${baseFont * 1.2}px "Fira Code"`;
            ctx.fillText('Canvases', legendX + padding, currentY);
            currentY += baseFont * 2;
            
            selectedCanvases.forEach(key => {
                const info = canvasInfo[key];
                if (!info) return;
                
                // Color square - larger and more prominent
                ctx.fillStyle = info.color;
                ctx.fillRect(legendX + padding, currentY - squareSize * 0.8, squareSize, squareSize);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 2;
                ctx.strokeRect(legendX + padding, currentY - squareSize * 0.8, squareSize, squareSize);
                
                // Title - larger and bolder
                ctx.fillStyle = info.color;
                ctx.font = `bold ${baseFont}px "Fira Code"`;
                ctx.fillText(info.title, legendX + padding + squareSize + 12, currentY);
                
                // Subtitle
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = `${baseFont * 0.75}px "Fira Code"`;
                ctx.fillText(info.subtitle, legendX + padding + squareSize + 12, currentY + baseFont * 1.1);
                
                currentY += baseFont * 2.8;
            });
            
            // Parameters section - show per-canvas details
            if (includeParameters) {
                currentY += baseFont;
                ctx.fillStyle = '#00ffff';
                ctx.font = `bold ${baseFont * 1.2}px "Fira Code"`;
                ctx.fillText('Global Parameters', legendX + padding, currentY);
                currentY += baseFont * 2;
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = `${baseFont * 0.9}px "Fira Code"`;
                
                const params = [
                    `Modulus: m = ${state.modulus}`,
                    `Phase: œÜ = ${state.phase.toFixed(1)}¬∞`,
                    `Ring Range: ${state.minRing} ‚Üí ${state.maxRing}`,
                    `Primes: ${state.numPrimes} shown`,
                ];
                
                // Add canvas-specific zoom info if multiple canvases
                if (selectedCanvases.length > 1) {
                    params.push(`Zoom Levels:`);
                    selectedCanvases.forEach(key => {
                        const info = canvasInfo[key];
                        let zoomVal = 100;
                        switch(key) {
                            case 'disk': zoomVal = (state.diskZoom * 100).toFixed(0); break;
                            case 'cayley': zoomVal = (state.cayleyZoom * 100).toFixed(0); break;
                            case 'nested': zoomVal = (state.nestedZoom * 100).toFixed(0); break;
                            case 'reduction': zoomVal = (state.reductionZoom * 100).toFixed(0); break;
                            case 'fullplane': zoomVal = (state.fullPlaneZoom * 100).toFixed(0); break;
                            case 'primitiveroots': zoomVal = (state.primitiveZoom * 100).toFixed(0); break;
                        }
                        params.push(`  ${info.title}: ${zoomVal}%`);
                    });
                }
                
                params.forEach(param => {
                    ctx.fillText('‚Ä¢ ' + param, legendX + padding, currentY);
                    currentY += baseFont * 1.4;
                });
            }
            
            // Mathematical info section
            currentY += baseFont;
            ctx.fillStyle = '#ffd700';
            ctx.font = `bold ${baseFont * 1.2}px "Fira Code"`;
            ctx.fillText('Math Info', legendX + padding, currentY);
            currentY += baseFont * 2;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            ctx.font = `${baseFont * 0.85}px "Fira Code"`;
            
            const phi = eulerPhi(state.modulus);
            const mathInfo = [
                `œÜ(${state.modulus}) = ${phi}`,
                `Coprime count: ${phi}`,
                `Cayley: ùîª ‚Üí ‚Ñç`
            ];
            
            mathInfo.forEach(info => {
                ctx.fillText('‚ó¶ ' + info, legendX + padding, currentY);
                currentY += baseFont * 1.3;
            });
            
            // Footer
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = `italic ${baseFont * 0.8}px "Fira Code"`;
            ctx.textAlign = 'center';
            ctx.fillText('Farey Triangle & Cayley Transform Explorer', legendX + legendWidth / 2, canvasHeight - 40);
            ctx.fillText('Wessen Getachew (@7dview)', legendX + legendWidth / 2, canvasHeight - 20);
            
            ctx.restore();
        }


        function performExport() {
            try {
                // Get selected canvases from checkboxes
                const selectedCanvases = Array.from(document.querySelectorAll('.canvas-checkbox:checked'))
                    .map(cb => cb.value);
                
                if (selectedCanvases.length === 0) {
                    alert('Please select at least one canvas to export.');
                    return;
                }
                
                const resolution = document.querySelector('input[name="resolution"]:checked').value;
                const includeTitle = document.getElementById('includeTitle').checked;
                const includeLegend = document.getElementById('includeLegend').checked;
                const includeWatermark = document.getElementById('includeWatermark').checked;
                const includeParameters = document.getElementById('includeParameters').checked;
                const includeConnections = document.getElementById('includeConnections').checked;
                const includeStatistics = document.getElementById('includeStatistics').checked;
                const legendSize = parseInt(document.getElementById('legendSizeSlider').value) / 100;
                const exportStyle = document.getElementById('exportStyle').value;

                // Validate canvases exist
                if (!canvases.disk || !canvases.cayley || !canvases.nested || !canvases.reduction || !canvases.fullPlane) {
                    alert('Error: Canvases not initialized. Please refresh the page.');
                    return;
                }

                // Get dimensions
                let width, height;
                switch(resolution) {
                    case '1080': width = 1920; height = 1080; break;
                    case '1440': width = 2560; height = 1440; break;
                    case '4k': width = 3840; height = 2160; break;
                    case '8k': width = 7680; height = 4320; break;
                }

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                const baseSize = Math.min(width, height);

                if (exportStyle === 'professional') {
                    // Professional layout: visualization on left, detailed panel on right
                    exportProfessionalLayout(tempCanvas, tempCtx, selectedCanvases, baseSize, 
                        includeTitle, includeLegend, includeWatermark, includeParameters, 
                        includeConnections, includeStatistics, legendSize);
                } else {
                    // Standard layout with flexible grid
                    const legendSpace = includeLegend ? 500 : 0;

                    if (selectedCanvases.length > 1) {
                        // Multi-canvas export with dynamic grid
                        exportMultipleCanvases(tempCanvas, tempCtx, selectedCanvases, baseSize, width, height,
                            includeTitle, includeLegend, includeWatermark, includeParameters, legendSpace, legendSize);
                    } else {
                        // Single canvas export
                        const canvasKey = selectedCanvases[0];
                        tempCanvas.width = baseSize + legendSpace;
                        tempCanvas.height = baseSize;

                        tempCtx.fillStyle = '#0a0e27';
                        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                        let sourceCanvas, title;
                        switch(canvasKey) {
                            case 'disk':
                                sourceCanvas = canvases.disk;
                                title = 'Unit Disk ùîª - Farey Triangle';
                                break;
                            case 'cayley':
                                sourceCanvas = canvases.cayley;
                                title = 'Upper Half-Plane ‚Ñç - Cayley Transform';
                                break;
                            case 'nested':
                                sourceCanvas = canvases.nested;
                                title = 'Nested Modular Rings';
                                break;
                            case 'reduction':
                                sourceCanvas = canvases.reduction;
                                title = 'Modular Reduction Projection';
                                break;
                            case 'fullplane':
                                sourceCanvas = canvases.fullPlane;
                                title = 'Full Complex Plane ‚ÑÇ';
                                break;
                            case 'primitiveroots':
                                if (canvases.pixiApp) {
                                    sourceCanvas = canvases.pixiApp.renderer.view;
                                    title = 'Primitive Roots - Cyclic Structure';
                                } else {
                                    alert('Pixi canvas not initialized');
                                    return;
                                }
                                break;
                        }

                        if (!sourceCanvas) throw new Error(`Canvas not found: ${canvasKey}`);

                        tempCtx.drawImage(sourceCanvas, 0, 0, baseSize, baseSize);

                        if (includeTitle) {
                            const scale = baseSize / 1000;
                            tempCtx.fillStyle = '#ffd700';
                            tempCtx.font = `bold ${28 * scale}px "Fira Code"`;
                            tempCtx.textAlign = 'center';
                            tempCtx.textBaseline = 'top';
                            tempCtx.fillText(title, baseSize / 2, 30 * scale);
                        }

                        if (includeLegend) {
                            drawEnhancedLegend(tempCtx, tempCanvas.width, tempCanvas.height, baseSize, canvasKey, 
                                includeParameters, includeConnections, includeStatistics, legendSize);
                        }
                        
                        if (includeWatermark) {
                            drawWatermark(tempCtx, tempCanvas.width, tempCanvas.height);
                        }

                        // Download
                        const link = document.createElement('a');
                        link.download = `Farey_Cayley_${canvasKey}_m${state.modulus}.png`;
                        link.href = tempCanvas.toDataURL();
                        link.click();

                        closeExportDialog();
                        alert('Export successful!');
                    }
                }
            } catch (error) {
                console.error('Export error:', error);
                alert('Export failed: ' + error.message);
            }
        }

        // Professional export layout (inspired by Modular Reduction Explorer)
        function exportProfessionalLayout(canvas, ctx, canvasSelection, baseSize, includeTitle, includeLegend, 
            includeWatermark, includeParameters, includeConnections, includeStatistics, legendSize) {
            
            canvas.width = baseSize;
            canvas.height = baseSize;
            
            const leftPanel = baseSize * 0.65;
            const rightPanel = baseSize * 0.35;
            const padding = baseSize * 0.03;
            
            // Background
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // TITLE at top
            if (includeTitle) {
                ctx.font = `bold ${baseSize * 0.025}px "Fira Code"`;
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.fillText('Farey Triangle & Cayley Transform Explorer', canvas.width / 2, padding * 1.5);
                
                ctx.font = `${baseSize * 0.012}px "Fira Code"`;
                ctx.fillStyle = '#8b949e';
                const now = new Date();
                ctx.fillText(now.toLocaleString(), canvas.width / 2, padding * 2.3);
            }
            
            const titleHeight = includeTitle ? padding * 3 : padding;
            
            // VISUALIZATION (left side, centered)
            const vizSize = leftPanel - padding * 2;
            const vizX = padding;
            const vizY = titleHeight + (canvas.height - titleHeight - vizSize) / 2;
            
            let sourceCanvas;
            switch(canvasSelection) {
                case 'disk': sourceCanvas = canvases.disk; break;
                case 'cayley': sourceCanvas = canvases.cayley; break;
                case 'nested': sourceCanvas = canvases.nested; break;
                case 'reduction': sourceCanvas = canvases.reduction; break;
                case 'fullplane': sourceCanvas = canvases.fullPlane; break;
                case 'all':
                    const canvasSize = vizSize / 2;
                    // Top row: disk, cayley, nested
                    // Bottom row: reduction, fullplane
                    [[canvases.disk, 0, 0], [canvases.cayley, canvasSize, 0],
                     [canvases.nested, 0, canvasSize], [canvases.reduction, canvasSize/2, canvasSize*1.5],
                     [canvases.fullPlane, canvasSize*1.5, canvasSize]].forEach(([c, dx, dy]) => {
                        if (c) ctx.drawImage(c, 0, 0, c.width, c.height, vizX + dx, vizY + dy, canvasSize, canvasSize);
                    });
                    break;
            }
            
            if (sourceCanvas) {
                ctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, vizX, vizY, vizSize, vizSize);
            }
            
            // RIGHT PANEL - Professional legend
            if (includeLegend) {
                const rightX = leftPanel + padding;
                let currentY = titleHeight + padding;
                
                ctx.font = `bold ${baseSize * 0.018}px "Fira Code"`;
                ctx.fillStyle = '#79c0ff';
                ctx.textAlign = 'left';
                ctx.fillText('CONFIGURATION', rightX, currentY);
                currentY += padding * 0.8;
                
                ctx.strokeStyle = '#30363d';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(rightX, currentY);
                ctx.lineTo(rightX + rightPanel - padding * 2, currentY);
                ctx.stroke();
                currentY += padding * 0.8;
                
                ctx.font = `${baseSize * 0.013}px "Fira Code"`;
                ctx.fillStyle = '#c9d1d9';
                
                ctx.fillText(`Modulus: m = ${state.modulus}`, rightX, currentY); currentY += padding * 0.6;
                ctx.fillText(`Rings: [${state.minRing}, ${state.maxRing}]`, rightX, currentY); currentY += padding * 0.6;
                ctx.fillText(`œÜ(m) = ${eulerPhi(state.modulus)}`, rightX, currentY); currentY += padding * 1.2;
                
                // Statistics
                ctx.font = `bold ${baseSize * 0.018}px "Fira Code"`;
                ctx.fillStyle = '#79c0ff';
                ctx.fillText('STATISTICS', rightX, currentY); currentY += padding * 0.8;
                
                ctx.strokeStyle = '#30363d';
                ctx.beginPath();
                ctx.moveTo(rightX, currentY);
                ctx.lineTo(rightX + rightPanel - padding * 2, currentY);
                ctx.stroke();
                currentY += padding * 0.8;
                
                ctx.font = `${baseSize * 0.013}px "Fira Code"`;
                ctx.fillStyle = '#c9d1d9';
                
                const coprimeCount = state.fareyPoints.filter(fp => gcd(fp.num, fp.den) === 1).length;
                ctx.fillText(`Points: ${state.fareyPoints.length}`, rightX, currentY); currentY += padding * 0.6;
                ctx.fillText(`Coprime: ${coprimeCount}`, rightX, currentY); currentY += padding * 0.6;
                ctx.fillText(`Primes: ${Math.min(state.numPrimes, state.primes.length)}`, rightX, currentY); currentY += padding * 1.2;
                
                // Color key
                ctx.font = `bold ${baseSize * 0.018}px "Fira Code"`;
                ctx.fillStyle = '#79c0ff';
                ctx.fillText('COLOR KEY', rightX, currentY); currentY += padding * 0.8;
                
                ctx.strokeStyle = '#30363d';
                ctx.beginPath();
                ctx.moveTo(rightX, currentY);
                ctx.lineTo(rightX + rightPanel - padding * 2, currentY);
                ctx.stroke();
                currentY += padding * 0.8;
                
                const swatchSize = baseSize * 0.015;
                const swatchGap = baseSize * 0.025;
                
                ctx.font = `${baseSize * 0.012}px "Fira Code"`;
                
                ctx.fillStyle = CONFIG.colors.farey;
                ctx.fillRect(rightX, currentY - swatchSize * 0.7, swatchSize, swatchSize);
                ctx.fillStyle = '#c9d1d9';
                ctx.fillText('GCD=1 (Coprime)', rightX + swatchGap, currentY); currentY += padding * 0.8;
                
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(rightX, currentY - swatchSize * 0.7, swatchSize, swatchSize);
                ctx.fillStyle = '#c9d1d9';
                ctx.fillText('GCD=m (Divisible)', rightX + swatchGap, currentY); currentY += padding * 1.2;
                
                // Metadata at bottom
                currentY = canvas.height - padding * 4;
                ctx.font = `bold ${baseSize * 0.016}px "Fira Code"`;
                ctx.fillStyle = '#79c0ff';
                ctx.fillText('METADATA', rightX, currentY); currentY += padding * 0.8;
                
                ctx.font = `${baseSize * 0.01}px "Fira Code"`;
                ctx.fillStyle = '#8b949e';
                ctx.fillText(`Generated: ${new Date().toLocaleString()}`, rightX, currentY); currentY += padding * 0.5;
                ctx.fillText('Author: Wessen Getachew', rightX, currentY); currentY += padding * 0.5;
                ctx.fillText('Farey Triangle & Cayley Transform Explorer', rightX, currentY);
            }
            
            if (includeWatermark) {
                drawWatermark(ctx, canvas.width, canvas.height);
            }
        }

        // Enhanced legend with comprehensive details
        function drawEnhancedLegend(ctx, totalWidth, totalHeight, baseSize, canvasType, includeParams, includeConns, includeStats, sizeScale) {
            const legendX = baseSize + 20;
            const legendWidth = 310;
            let currentY = 30;
            const baseLineHeight = 18;
            const lineHeight = baseLineHeight * sizeScale;
            const baseFontSize = 11;
            const fontSize = baseFontSize * sizeScale;
            const sectionGap = 8 * sizeScale;
            
            // Legend background
            ctx.fillStyle = 'rgba(10, 14, 39, 0.95)';
            ctx.fillRect(baseSize, 0, totalWidth - baseSize, totalHeight);
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(baseSize, 0, totalWidth - baseSize, totalHeight);
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = `bold ${14 * sizeScale}px "Fira Code"`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText('LEGEND & ANALYSIS', legendX, currentY);
            currentY += lineHeight * 1.8;
            
            // Color scheme
            ctx.font = `bold ${12 * sizeScale}px "Fira Code"`;
            ctx.fillText('Color Coding:', legendX, currentY);
            currentY += lineHeight * 1.1;
            
            ctx.font = `${fontSize}px "Fira Code"`;
            const colorSize = 11 * sizeScale;
            const colors = [
                { color: CONFIG.colors.farey, text: 'GCD=1 (Coprime to m)' },
                { color: '#e74c3c', text: 'GCD=m (Divisible by m)' },
                { color: '#00ffff', text: 'GCD=2 (Even, not by m)' },
                { color: '#9b59b6', text: 'GCD=3 (Triple, not by m)' },
                { color: CONFIG.colors.prime, text: 'Prime Numbers p' }
            ];
            
            colors.forEach(item => {
                ctx.fillStyle = item.color;
                ctx.fillRect(legendX, currentY, colorSize, colorSize);
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fillText(item.text, legendX + colorSize + 8, currentY);
                currentY += lineHeight;
            });
            
            currentY += sectionGap;
            
            // Statistical Analysis
            if (includeStats) {
                ctx.fillStyle = '#ffd700';
                ctx.font = `bold ${12 * sizeScale}px "Fira Code"`;
                ctx.fillText('Statistics:', legendX, currentY);
                currentY += lineHeight * 1.1;
                
                ctx.font = `${fontSize}px "Fira Code"`;
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                
                // Calculate comprehensive stats
                const phi_m = eulerPhi(state.modulus);
                const coprimeCount = state.fareyPoints.filter(fp => gcd(fp.num, fp.den) === 1).length;
                const coprimeDensity = (coprimeCount / state.fareyPoints.length * 100).toFixed(1);
                
                // Ring analysis
                let totalRingPoints = 0;
                let totalCoprimeRingPoints = 0;
                for (let m = state.minRing; m <= state.maxRing; m++) {
                    totalRingPoints += m;
                    totalCoprimeRingPoints += eulerPhi(m);
                }
                const ringCoprimeDensity = (totalCoprimeRingPoints / totalRingPoints * 100).toFixed(1);
                
                const stats = [
                    `œÜ(${state.modulus}) = ${phi_m} coprime`,
                    `Coprime: ${coprimeCount}/${state.fareyPoints.length} (${coprimeDensity}%)`,
                    `Ring pts: ${totalRingPoints} total`,
                    `Ring coprime: ${totalCoprimeRingPoints} (${ringCoprimeDensity}%)`,
                    `Prime density: ${(state.primes.length / state.primeLimit * 100).toFixed(1)}%`,
                    `Rings active: ${state.maxRing - state.minRing + 1}`
                ];
                
                stats.forEach(stat => {
                    ctx.fillText(stat, legendX, currentY);
                    currentY += lineHeight;
                });
                
                currentY += sectionGap;
            }
            
            // Parameters section
            if (includeParams) {
                ctx.fillStyle = '#ffd700';
                ctx.font = `bold ${12 * sizeScale}px "Fira Code"`;
                ctx.fillText('Parameters:', legendX, currentY);
                currentY += lineHeight * 1.1;
                
                ctx.font = `${fontSize}px "Fira Code"`;
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                
                const params = [
                    `Modulus: m = ${state.modulus}`,
                    `Phase: Œ∏ = ${state.phase.toFixed(1)}¬∞`,
                    `Per-ring: ŒîŒ∏ = ${state.ringRotation.toFixed(0)}¬∞`,
                    `Rings: [${state.minRing}, ${state.maxRing}]`,
                    `Spacing: ${state.ringSpacing.toFixed(2)}√ó`,
                    `Points: ${state.fareyPoints.length}`,
                    `Primes: ${Math.min(state.numPrimes, state.primes.length)}`,
                    `Max prime: ${state.primes[state.primes.length - 1] || 0}`,
                    `Transform: ${state.transformType}`,
                    `Color scheme: ${state.nestedColorScheme}`,
                    `Connection: ${state.connectionMode}`
                ];
                
                params.forEach(param => {
                    ctx.fillText(param, legendX, currentY);
                    currentY += lineHeight;
                });
                
                currentY += sectionGap;
            }
            
            // Mathematical Relationships
            ctx.fillStyle = '#ffd700';
            ctx.font = `bold ${12 * sizeScale}px "Fira Code"`;
            ctx.fillText('Theory:', legendX, currentY);
            currentY += lineHeight * 1.1;
            
            ctx.font = `${fontSize}px "Fira Code"`;
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            
            const theory = [
                'z ‚àà ùîª: Unit disk |z| < 1',
                'w = (z-i)/(z+i): Cayley',
                'w ‚àà ‚Ñç: Im(w) > 0',
                'Farey: gcd(k,n)=1, n|m',
                'Rotation: e^(iŒ∏) ¬∑ z'
            ];
            
            theory.forEach(line => {
                ctx.fillText(line, legendX, currentY);
                currentY += lineHeight;
            });
            
            currentY += sectionGap;
            
            // Connections section
            if (includeConns) {
                const showRtoR = document.getElementById('toggleShowRtoR') && document.getElementById('toggleShowRtoR').checked;
                const showRtoR2n = document.getElementById('toggleShowRtoRplus2n') && document.getElementById('toggleShowRtoRplus2n').checked;
                
                if (showRtoR || showRtoR2n) {
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `bold ${12 * sizeScale}px "Fira Code"`;
                    ctx.fillText('Connections:', legendX, currentY);
                    currentY += lineHeight * 1.1;
                    
                    ctx.font = `${fontSize}px "Fira Code"`;
                    if (showRtoR) {
                        ctx.fillStyle = '#00ffff';
                        ctx.fillRect(legendX, currentY, colorSize, colorSize);
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                        ctx.fillText('r ‚Üí r (identity)', legendX + colorSize + 8, currentY);
                        currentY += lineHeight;
                    }
                    if (showRtoR2n) {
                        ctx.fillStyle = 'rgba(255,100,100,0.9)';
                        ctx.fillRect(legendX, currentY, colorSize, colorSize);
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                        ctx.fillText('r ‚Üí r+m√ó2‚Åø (lifting)', legendX + colorSize + 8, currentY);
                        currentY += lineHeight;
                    }
                }
            }
        }

        function drawParametersInfo(ctx, width, height, canvasType) {
            const scale = Math.min(width, height) / 1920;
            const fontSize = 11 * scale;
            const padding = 20 * scale;
            
            // Position in bottom-left corner
            const boxWidth = 380 * scale;
            const lineHeight = 16 * scale;
            
            // Build parameter text
            const params = [
                `Modulus: m = ${state.modulus}`,
                `Phase: Œ∏ = ${state.phase.toFixed(1)}¬∞`,
                `Rings: ${state.minRing}‚Äì${state.maxRing}`,
                `Primes: ${state.numPrimes}`,
                `Transform: ${state.transformType}`,
                `Color Scheme: ${state.nestedColorScheme}`,
                `Label Mode: ${state.labelMode}`,
                `Connection: ${state.connectionMode}`,
            ];
            
            // Add connection status
            const rToR = document.getElementById('toggleShowRtoR').checked;
            const rToR2n = document.getElementById('toggleShowRtoRplus2n').checked;
            if (rToR || rToR2n) {
                const connections = [];
                if (rToR) connections.push('r‚Üír');
                if (rToR2n) connections.push('r‚Üír+m√ó2‚Åø');
                params.push(`Global: ${connections.join(', ')}`);
            }
            
            const boxHeight = (params.length + 1) * lineHeight + padding * 2;
            const boxX = padding;
            const boxY = height - boxHeight - padding;
            
            // Background
            ctx.save();
            ctx.fillStyle = 'rgba(10, 14, 39, 0.92)';
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
            ctx.lineWidth = 2 * scale;
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
            
            // Title
            ctx.fillStyle = '#00ffff';
            ctx.font = `bold ${fontSize + 2}px "Fira Code"`;
            ctx.textAlign = 'left';
            ctx.fillText('PARAMETERS', boxX + padding, boxY + padding + fontSize);
            
            // Parameters
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = `${fontSize}px "Fira Code"`;
            params.forEach((param, idx) => {
                ctx.fillText(param, boxX + padding, boxY + padding + (idx + 2) * lineHeight);
            });
            
            ctx.restore();
        }

        function drawMainTitle(ctx, size, titleText) {
            const scale = size / 1000;
            const fontSize = 28 * scale;
            const padding = 40 * scale;

            ctx.save();
            
            // Measure text width
            ctx.font = `bold ${fontSize}px "Fira Code"`;
            const textMetrics = ctx.measureText(titleText);
            const titleWidth = textMetrics.width + 80 * scale;
            const titleHeight = 70 * scale;
            const titleX = (size - titleWidth) / 2;
            const titleY = padding;

            // Title background with gradient
            const gradient = ctx.createLinearGradient(titleX, titleY, titleX, titleY + titleHeight);
            gradient.addColorStop(0, 'rgba(10, 14, 39, 0.95)');
            gradient.addColorStop(1, 'rgba(20, 30, 60, 0.95)');
            ctx.fillStyle = gradient;
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
            ctx.lineWidth = 3 * scale;
            
            const radius = 10 * scale;
            ctx.beginPath();
            ctx.moveTo(titleX + radius, titleY);
            ctx.lineTo(titleX + titleWidth - radius, titleY);
            ctx.quadraticCurveTo(titleX + titleWidth, titleY, titleX + titleWidth, titleY + radius);
            ctx.lineTo(titleX + titleWidth, titleY + titleHeight - radius);
            ctx.quadraticCurveTo(titleX + titleWidth, titleY + titleHeight, titleX + titleWidth - radius, titleY + titleHeight);
            ctx.lineTo(titleX + radius, titleY + titleHeight);
            ctx.quadraticCurveTo(titleX, titleY + titleHeight, titleX, titleY + titleHeight - radius);
            ctx.lineTo(titleX, titleY + radius);
            ctx.quadraticCurveTo(titleX, titleY, titleX + radius, titleY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Title text - solid yellow
            ctx.fillStyle = '#ffd700';  // Solid yellow, no gradient
            ctx.font = `bold ${fontSize}px "Fira Code"`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowBlur = 15 * scale;
            ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
            ctx.fillText(titleText, size / 2, titleY + titleHeight / 2);
            
            ctx.restore();
        }

        function drawCanvasTitles(ctx, width, height, canvasSize, offsetY) {
            const scale = width / 5760; // Scale based on combined width
            const fontSize = 20 * scale;
            const titles = [
                'Unit Disk ùîª',
                'Upper Half-Plane ‚Ñç',
                'Nested Rings ‚äö'
            ];

            ctx.save();
            
            titles.forEach((title, idx) => {
                const centerX = (idx + 0.5) * (width / 3);
                const titleY = offsetY - 40 * scale;

                ctx.fillStyle = '#ffd700';
                ctx.font = `bold ${fontSize}px "Fira Code"`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowBlur = 8 * scale;
                ctx.shadowColor = 'rgba(255, 215, 0, 0.4)';
                ctx.fillText(title, centerX, titleY);
            });
            
            ctx.restore();
        }

        function drawWatermark(ctx, width, height) {
            const scale = Math.min(width, height) / 1920;
            const fontSize = 18 * scale;
            const padding = 30 * scale;

            ctx.save();
            
            // Measure text first
            ctx.font = `bold ${fontSize}px "Fira Code"`;
            const textMetrics = ctx.measureText('by Wessen Getachew ¬∑ @7dview');
            const watermarkWidth = textMetrics.width + 50 * scale;
            const watermarkHeight = 55 * scale;
            const watermarkX = width - watermarkWidth - padding;
            const watermarkY = height - watermarkHeight - padding;

            // Watermark background with gradient
            const gradient = ctx.createLinearGradient(watermarkX, watermarkY, watermarkX, watermarkY + watermarkHeight);
            gradient.addColorStop(0, 'rgba(10, 14, 39, 0.95)');
            gradient.addColorStop(1, 'rgba(20, 30, 60, 0.95)');
            ctx.fillStyle = gradient;
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
            ctx.lineWidth = 3 * scale;
            
            // Rounded rectangle
            const radius = 10 * scale;
            ctx.beginPath();
            ctx.moveTo(watermarkX + radius, watermarkY);
            ctx.lineTo(watermarkX + watermarkWidth - radius, watermarkY);
            ctx.quadraticCurveTo(watermarkX + watermarkWidth, watermarkY, watermarkX + watermarkWidth, watermarkY + radius);
            ctx.lineTo(watermarkX + watermarkWidth, watermarkY + watermarkHeight - radius);
            ctx.quadraticCurveTo(watermarkX + watermarkWidth, watermarkY + watermarkHeight, watermarkX + watermarkWidth - radius, watermarkY + watermarkHeight);
            ctx.lineTo(watermarkX + radius, watermarkY + watermarkHeight);
            ctx.quadraticCurveTo(watermarkX, watermarkY + watermarkHeight, watermarkX, watermarkY + watermarkHeight - radius);
            ctx.lineTo(watermarkX, watermarkY + radius);
            ctx.quadraticCurveTo(watermarkX, watermarkY, watermarkX + radius, watermarkY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Watermark text with gradient
            const textGradient = ctx.createLinearGradient(watermarkX, watermarkY, watermarkX, watermarkY + watermarkHeight);
            textGradient.addColorStop(0, '#ffd700');
            textGradient.addColorStop(1, '#ffed4e');
            ctx.fillStyle = textGradient;
            ctx.font = `bold ${fontSize}px "Fira Code"`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowBlur = 15 * scale;
            ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
            ctx.fillText('by Wessen Getachew ¬∑ @7dview', watermarkX + watermarkWidth / 2, watermarkY + watermarkHeight / 2);
            
            ctx.restore();
        }

        function drawLegend(ctx, width, height, canvasType) {
            const scale = Math.min(width, height) / 1920;
            
            // Adjust legend size and position to avoid all overlap
            let legendWidth = 420 * scale;
            let legendX, legendY;
            
            // Always position in bottom-left to avoid title/canvas overlap
            legendX = 30 * scale;
            legendY = height - 30 * scale; // Start from bottom
            
            const fontSize = 11 * scale;
            const titleSize = 16 * scale;
            const sectionTitleSize = 13 * scale;
            const itemHeight = 24 * scale;
            const symbolSize = 18 * scale;
            const padding = 15 * scale;

            let items = [];
            let parameters = [];
            
            if (canvasType === 'disk') {
                items = [
                    { type: 'section', text: 'Unit Disk' },
                    { color: CONFIG.colors.disk, text: 'Circle Boundary' },
                    { color: CONFIG.colors.farey, text: 'Farey Vertices' },
                    { color: CONFIG.colors.prime, text: 'Primes' }
                ];
                parameters = [
                    `m=${state.modulus}`,
                    `Primes: ${Math.min(state.numPrimes, state.primes.length)}`,
                    `Œ∏=${state.phase.toFixed(0)}¬∞`
                ];
            } else if (canvasType === 'cayley') {
                items = [
                    { type: 'section', text: 'Half-Plane ‚Ñç' },
                    { color: 'rgba(255, 255, 255, 0.5)', text: 'Real Axis' },
                    { color: CONFIG.colors.farey, text: 'Farey Points' },
                    { color: CONFIG.colors.geodesic, text: 'Geodesics' },
                    { color: CONFIG.colors.cusp, text: 'Cusps' }
                ];
                parameters = [
                    `m=${state.modulus}`,
                    `Re: [${(-state.cayleyHRange/2).toFixed(1)},${(state.cayleyHRange/2).toFixed(1)}]`,
                    `Im: [${state.cayleyVOffset.toFixed(1)},${(state.cayleyVRange+state.cayleyVOffset).toFixed(1)}]`
                ];
            } else if (canvasType === 'nested') {
                items = [
                    { type: 'section', text: 'GCD Colors' },
                    { color: CONFIG.colors.farey, text: 'GCD=1' },
                    { color: '#e74c3c', text: 'GCD=m' },
                    { color: '#00ffff', text: 'GCD=2' },
                    { color: '#9b59b6', text: 'GCD=3' }
                ];
                parameters = [
                    `Rings: ${state.minRing}‚Äì${state.maxRing}`,
                    `Count: ${state.maxRing - state.minRing + 1}`,
                    `Mode: ${state.connectionMode}`
                ];
            } else             if (canvasType === 'all') {
                items = [
                    { type: 'section', text: 'Elements' },
                    { color: CONFIG.colors.farey, text: 'Farey/Coprime' },
                    { color: CONFIG.colors.geodesic, text: 'Geodesics' },
                    { color: CONFIG.colors.prime, text: 'Primes' },
                    { type: 'section', text: 'GCD' },
                    { color: CONFIG.colors.farey, text: 'GCD=1' },
                    { color: '#e74c3c', text: 'GCD=m' },
                    { type: 'section', text: 'Connections' }
                ];
                
                // Add connection legend items
                if (document.getElementById('toggleShowRtoR').checked) {
                    items.push({ color: '#00ffff', text: 'r‚Üír (Self-similar)' });
                }
                if (document.getElementById('toggleShowRtoRplus2n').checked) {
                    items.push({ color: 'rgba(255,100,100,0.9)', text: 'r‚Üír+m√ó2‚Åø (Binary)' });
                }
                
                parameters = [
                    `m=${state.modulus}`,
                    `Primes: ${Math.min(state.numPrimes, state.primes.length)}`,
                    `Rings: ${state.minRing}‚Äì${state.maxRing}`,
                    `Scheme: ${state.nestedColorScheme}`
                ];
            }

            // Calculate actual legend height
            const sectionCount = items.filter(i => i.type === 'section').length;
            const regularItemCount = items.filter(i => !i.type).length;
            const legendHeight = (padding * 4) + 
                                (sectionCount * itemHeight * 0.7) + 
                                (regularItemCount * itemHeight * 0.9) + 
                                (parameters.length * itemHeight * 0.65) +
                                (itemHeight * 1.2);

            // Adjust Y position so legend goes UP from bottom
            legendY = legendY - legendHeight;

            // Ensure legend stays within bounds
            if (legendY < 30 * scale) legendY = 30 * scale;
            if (legendX + legendWidth > width - 30 * scale) {
                legendWidth = width - legendX - 30 * scale;
            }

            // Background with gradient
            const gradient = ctx.createLinearGradient(legendX, legendY, legendX, legendY + legendHeight);
            gradient.addColorStop(0, 'rgba(10, 14, 39, 0.95)');
            gradient.addColorStop(1, 'rgba(20, 30, 60, 0.95)');
            ctx.fillStyle = gradient;
            
            ctx.strokeStyle = CONFIG.colors.farey;
            ctx.lineWidth = 2 * scale;
            ctx.shadowBlur = 12 * scale;
            ctx.shadowColor = 'rgba(255, 215, 0, 0.3)';
            
            // Rounded rectangle
            const radius = 8 * scale;
            ctx.beginPath();
            ctx.moveTo(legendX + radius, legendY);
            ctx.lineTo(legendX + legendWidth - radius, legendY);
            ctx.quadraticCurveTo(legendX + legendWidth, legendY, legendX + legendWidth, legendY + radius);
            ctx.lineTo(legendX + legendWidth, legendY + legendHeight - radius);
            ctx.quadraticCurveTo(legendX + legendWidth, legendY + legendHeight, legendX + legendWidth - radius, legendY + legendHeight);
            ctx.lineTo(legendX + radius, legendY + legendHeight);
            ctx.quadraticCurveTo(legendX, legendY + legendHeight, legendX, legendY + legendHeight - radius);
            ctx.lineTo(legendX, legendY + radius);
            ctx.quadraticCurveTo(legendX, legendY, legendX + radius, legendY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Clip to legend box to prevent overflow
            ctx.save();
            ctx.beginPath();
            ctx.rect(legendX, legendY, legendWidth, legendHeight);
            ctx.clip();

            // Title
            ctx.fillStyle = CONFIG.colors.farey;
            ctx.font = `bold ${titleSize}px "Fira Code"`;
            ctx.textAlign = 'left';
            ctx.shadowBlur = 6 * scale;
            ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
            ctx.fillText('LEGEND', legendX + padding, legendY + padding * 1.5);
            ctx.shadowBlur = 0;

            // Separator line
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.lineWidth = 1 * scale;
            ctx.beginPath();
            ctx.moveTo(legendX + padding, legendY + padding * 2.1);
            ctx.lineTo(legendX + legendWidth - padding, legendY + padding * 2.1);
            ctx.stroke();

            // Items
            let currentY = legendY + padding * 2.8;
            
            items.forEach((item, idx) => {
                if (item.type === 'section') {
                    // Section header
                    currentY += itemHeight * 0.15;
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                    ctx.font = `bold ${sectionTitleSize}px "Fira Code"`;
                    
                    // Ensure text fits in legend
                    const maxTextWidth = legendWidth - padding * 2;
                    let text = item.text;
                    let textWidth = ctx.measureText(text).width;
                    
                    if (textWidth > maxTextWidth) {
                        // Truncate text if too long
                        while (textWidth > maxTextWidth && text.length > 3) {
                            text = text.slice(0, -1);
                            textWidth = ctx.measureText(text + '...').width;
                        }
                        text = text + '...';
                    }
                    
                    ctx.fillText(text, legendX + padding, currentY);
                    
                    // Underline
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                    ctx.lineWidth = 1 * scale;
                    ctx.beginPath();
                    ctx.moveTo(legendX + padding, currentY + 3 * scale);
                    ctx.lineTo(legendX + legendWidth - padding, currentY + 3 * scale);
                    ctx.stroke();
                    
                    currentY += itemHeight * 0.55;
                } else {
                    // Regular item
                    ctx.fillStyle = item.color;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1 * scale;
                    
                    // Symbol
                    const symbolRadius = 3 * scale;
                    const symX = legendX + padding;
                    const symY = currentY - symbolSize * 0.6;
                    
                    ctx.beginPath();
                    ctx.moveTo(symX + symbolRadius, symY);
                    ctx.lineTo(symX + symbolSize - symbolRadius, symY);
                    ctx.quadraticCurveTo(symX + symbolSize, symY, symX + symbolSize, symY + symbolRadius);
                    ctx.lineTo(symX + symbolSize, symY + symbolSize - symbolRadius);
                    ctx.quadraticCurveTo(symX + symbolSize, symY + symbolSize, symX + symbolSize - symbolRadius, symY + symbolSize);
                    ctx.lineTo(symX + symbolRadius, symY + symbolSize);
                    ctx.quadraticCurveTo(symX, symY + symbolSize, symX, symY + symbolSize - symbolRadius);
                    ctx.lineTo(symX, symY + symbolRadius);
                    ctx.quadraticCurveTo(symX, symY, symX + symbolRadius, symY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Text with truncation
                    ctx.fillStyle = '#e8f1f5';
                    ctx.font = `${fontSize}px "Fira Code"`;
                    
                    const maxTextWidth = legendWidth - padding * 2 - symbolSize - 8 * scale;
                    let text = item.text;
                    let textWidth = ctx.measureText(text).width;
                    
                    if (textWidth > maxTextWidth) {
                        while (textWidth > maxTextWidth && text.length > 3) {
                            text = text.slice(0, -1);
                            textWidth = ctx.measureText(text + '...').width;
                        }
                        text = text + '...';
                    }
                    
                    ctx.fillText(text, legendX + padding + symbolSize + 8 * scale, currentY);
                    
                    currentY += itemHeight * 0.9;
                }
            });

            // Parameters section
            currentY += itemHeight * 0.2;
            ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
            ctx.font = `bold ${sectionTitleSize}px "Fira Code"`;
            ctx.fillText('Params', legendX + padding, currentY);
            
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.lineWidth = 1 * scale;
            ctx.beginPath();
            ctx.moveTo(legendX + padding, currentY + 3 * scale);
            ctx.lineTo(legendX + legendWidth - padding, currentY + 3 * scale);
            ctx.stroke();
            
            currentY += itemHeight * 0.55;

            ctx.font = `${fontSize * 0.95}px "Fira Code"`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            parameters.forEach(param => {
                const maxTextWidth = legendWidth - padding * 2.5;
                let text = param;
                let textWidth = ctx.measureText('‚Ä¢ ' + text).width;
                
                if (textWidth > maxTextWidth) {
                    while (textWidth > maxTextWidth && text.length > 3) {
                        text = text.slice(0, -1);
                        textWidth = ctx.measureText('‚Ä¢ ' + text + '...').width;
                    }
                    text = text + '...';
                }
                
                ctx.fillText('‚Ä¢ ' + text, legendX + padding, currentY);
                currentY += itemHeight * 0.65;
            });

            // Math notation footer
            currentY += itemHeight * 0.15;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = `italic ${fontSize * 0.85}px "Fira Code"`;
            ctx.fillText('ùîª ‚Üí ‚Ñç Cayley', legendX + padding, currentY);
            
            ctx.restore(); // Remove clipping
        }

        function drawLegendRight(ctx, totalWidth, totalHeight, baseSize, canvasType) {
            // Position legend in the right extended space
            const scale = baseSize / 1920;
            const legendWidth = 230;  // Fixed width for right panel
            const legendX = baseSize + 10;  // Start just after canvas
            
            const fontSize = 11 * scale;
            const titleSize = 16 * scale;
            const sectionTitleSize = 13 * scale;
            const itemHeight = 24 * scale;
            const symbolSize = 14 * scale;
            const padding = 12;

            let items = [];
            let parameters = [];
            
            // Define legend content based on canvas type
            if (canvasType === 'disk') {
                items = [
                    { type: 'section', text: 'Unit Disk' },
                    { color: CONFIG.colors.disk, text: 'Circle Boundary' },
                    { color: CONFIG.colors.farey, text: 'Farey Vertices' },
                    { color: CONFIG.colors.prime, text: 'Primes' }
                ];
                
                // Calculate coprime fraction
                const coprimeCount = state.fareyPoints.filter(fp => gcd(fp.num, fp.den) === 1).length;
                const coprimePct = ((coprimeCount / state.fareyPoints.length) * 100).toFixed(0);
                
                // Calculate visible primes
                const visiblePrimes = Math.min(state.numPrimes, state.primes.length);
                const primeLimit = state.primes[state.primes.length - 1] || 0;
                
                parameters = [
                    `m=${state.modulus} (œÜ(m)=${eulerPhi(state.modulus)})`,
                    `Farey: ${state.fareyPoints.length} pts`,
                    `Coprime: ${coprimeCount} (${coprimePct}%)`,
                    `Primes: ${visiblePrimes}/${state.primes.length}`,
                    `Max p: ${primeLimit}`,
                    `Œ∏=${state.phase.toFixed(0)}¬∞ (rotation)`
                ];
            } else if (canvasType === 'cayley') {
                items = [
                    { type: 'section', text: 'Half-Plane ‚Ñç' },
                    { color: 'rgba(255, 255, 255, 0.5)', text: 'Real Axis' },
                    { color: CONFIG.colors.farey, text: 'Farey Points' },
                    { color: CONFIG.colors.geodesic, text: 'Geodesics' },
                    { color: CONFIG.colors.cusp, text: 'Cusps' }
                ];
                
                // Calculate area shown
                const areaWidth = state.cayleyHRange;
                const areaHeight = state.cayleyVRange;
                const area = (areaWidth * areaHeight).toFixed(1);
                
                parameters = [
                    `m=${state.modulus}`,
                    `Points: ${state.fareyPoints.length}`,
                    `Cusps: ${state.fareyPoints.length} on ‚Ñù`,
                    `Area: ${area} units¬≤`,
                    `Re: [${(-state.cayleyHRange/2).toFixed(1)}, ${(state.cayleyHRange/2).toFixed(1)}]`,
                    `Im: [${state.cayleyVOffset.toFixed(1)}, ${(state.cayleyVRange+state.cayleyVOffset).toFixed(1)}]`,
                    `Zoom: ${state.cayleyZoom.toFixed(2)}√ó`
                ];
            } else if (canvasType === 'nested') {
                items = [
                    { type: 'section', text: 'GCD Colors' },
                    { color: CONFIG.colors.farey, text: 'GCD=1' },
                    { color: '#e74c3c', text: 'GCD=m' },
                    { color: '#00ffff', text: 'GCD=2' },
                    { color: '#9b59b6', text: 'GCD=3' }
                ];
                
                // Calculate total points across all rings
                let totalPoints = 0;
                let coprimePoints = 0;
                for (let m = state.minRing; m <= state.maxRing; m++) {
                    totalPoints += m;
                    coprimePoints += eulerPhi(m);
                }
                const coprimeDensity = ((coprimePoints / totalPoints) * 100).toFixed(1);
                
                parameters = [
                    `Rings: ${state.minRing}‚Äì${state.maxRing}`,
                    `Ring count: ${state.maxRing - state.minRing + 1}`,
                    `Total points: ${totalPoints}`,
                    `Coprime: ${coprimePoints} (${coprimeDensity}%)`,
                    `Spacing: ${state.ringSpacing.toFixed(2)}`,
                    `Mode: ${state.connectionMode}`,
                    `Rotation: ${state.ringRotation}¬∞`
                ];
            } else if (canvasType === 'fullplane') {
                items = [
                    { type: 'section', text: 'Full Plane ‚ÑÇ' },
                    { color: CONFIG.colors.farey, text: 'Farey Points' },
                    { color: CONFIG.colors.geodesic, text: 'Geodesics' },
                    { color: CONFIG.colors.cusp, text: 'Cusps' }
                ];
                parameters = [
                    `m=${state.modulus}`,
                    `Points: ${state.fareyPoints.length}`,
                    `Transform: ${state.transformType}`,
                    `Zoom: ${state.cayleyZoom.toFixed(2)}√ó`,
                    `Grid: ${state.cayleyGridDensity.toFixed(1)}`,
                    `H-Range: ${state.cayleyHRange.toFixed(1)}`,
                    `V-Offset: ${state.cayleyVOffset.toFixed(1)}`
                ];
            } else if (canvasType === 'reduction') {
                // Reduction canvas legend with comprehensive statistics
                const M = state.modulus;
                
                // Calculate divisors (Farey channels)
                const divisors = [];
                for (let d = 1; d <= M; d++) {
                    if (M % d === 0) divisors.push(d);
                }
                
                // Count coprime and non-coprime on outer ring
                let coprimeCount = 0;
                let nonCoprimeCount = 0;
                for (let r = 0; r < M; r++) {
                    if (gcd(r, M) === 1) {
                        coprimeCount++;
                    } else {
                        nonCoprimeCount++;
                    }
                }
                
                const coprimePct = ((coprimeCount / M) * 100).toFixed(1);
                const factorization = formatPrimeFactorization(M);
                const primeStatus = isPrime(M) ? 'Prime' : 'Composite';
                
                items = [
                    { type: 'section', text: 'Modular Reduction' },
                    { color: '#00ffff', text: 'Coprime (gcd=1)' },
                    { color: '#ff1493', text: 'Reducible (gcd>1)' },
                    { color: '#ff0000', text: 'Projection Lines' },
                    { color: '#ffd700', text: 'Channel Rings' },
                    { type: 'section', text: 'Farey Channels' },
                    { color: '#ffd700', text: `${divisors.length} channels (divisors of M)` }
                ];
                
                parameters = [
                    `Modulus: M = ${M}`,
                    `Type: ${primeStatus}`,
                    `Factorization: ${factorization}`,
                    `œÜ(M) = ${coprimeCount}`,
                    `Coprime: ${coprimeCount} (${coprimePct}%)`,
                    `Reducible: ${nonCoprimeCount} (${(100-parseFloat(coprimePct)).toFixed(1)}%)`,
                    `Channels: ${divisors.length} divisors`,
                    `Œ∏=${state.phase.toFixed(17)}¬∞`,
                    `Ring Rot: ${state.ringRotation.toFixed(2)}¬∞`,
                    `Line Thick: ${state.globalLineThickness.toFixed(2)}`
                ];
            } else if (canvasType === 'all') {
                console.log('Drawing legend for ALL 5 canvases');
                // For 2√ó3 grid view with reduction
                
                const M = state.modulus;
                let coprimeM = 0;
                let nonCoprimeM = 0;
                for (let r = 0; r < M; r++) {
                    if (gcd(r, M) === 1) coprimeM++;
                    else nonCoprimeM++;
                }
                
                items = [
                    { type: 'section', text: 'Disk & Cayley' },
                    { color: CONFIG.colors.farey, text: 'Farey/Coprime' },
                    { color: CONFIG.colors.geodesic, text: 'Geodesics' },
                    { color: CONFIG.colors.prime, text: 'Primes' },
                    { type: 'section', text: 'Nested Rings GCD' },
                    { color: CONFIG.colors.farey, text: 'GCD=1' },
                    { color: '#e74c3c', text: 'GCD=m' },
                    { color: '#00ffff', text: 'GCD=2' },
                    { color: '#9b59b6', text: 'GCD=3' },
                    { type: 'section', text: 'Reduction' },
                    { color: '#00ffff', text: 'Coprime' },
                    { color: '#ff1493', text: 'Reducible' },
                    { color: '#ff0000', text: 'Projections' }
                ];
                
                // Add connection legend items if active
                try {
                    if (document.getElementById('toggleShowRtoR') && document.getElementById('toggleShowRtoR').checked) {
                        if (items[items.length - 1].type !== 'section') {
                            items.push({ type: 'section', text: 'Connections' });
                        }
                        items.push({ color: '#00ffff', text: 'r‚Üír' });
                    }
                    if (document.getElementById('toggleShowRtoRplus2n') && document.getElementById('toggleShowRtoRplus2n').checked) {
                        if (items[items.length - 1].type !== 'section' && (!document.getElementById('toggleShowRtoR') || !document.getElementById('toggleShowRtoR').checked)) {
                            items.push({ type: 'section', text: 'Connections' });
                        }
                        items.push({ color: 'rgba(255,100,100,0.9)', text: 'r‚Üír+m√ó2‚Åø' });
                    }
                } catch (e) {
                    console.warn('Could not add connection items:', e);
                }
                
                // Calculate comprehensive analysis
                const coprimeCount = state.fareyPoints.filter(fp => gcd(fp.num, fp.den) === 1).length;
                let totalRingPoints = 0;
                let totalCoprimeRingPoints = 0;
                console.log('Calculating ring points from', state.minRing, 'to', state.maxRing);
                for (let m = state.minRing; m <= state.maxRing; m++) {
                    totalRingPoints += m;
                    totalCoprimeRingPoints += eulerPhi(m);
                }
                console.log('Total ring points:', totalRingPoints, 'Coprime:', totalCoprimeRingPoints);
                
                const coprimePctM = ((coprimeM / M) * 100).toFixed(1);
                
                parameters = [
                    `m=${state.modulus} (œÜ=${eulerPhi(state.modulus)})`,
                    `Type: ${isPrime(M) ? 'Prime' : formatPrimeFactorization(M)}`,
                    `Farey: ${state.fareyPoints.length} (${coprimeCount} coprime)`,
                    `Reduction: ${coprimeM} coprime (${coprimePctM}%)`,
                    `Primes: ${Math.min(state.numPrimes, state.primes.length)}/${state.primes.length}`,
                    `Rings: ${state.minRing}‚Äì${state.maxRing} (${state.maxRing - state.minRing + 1} rings)`,
                    `Ring pts: ${totalRingPoints} (${totalCoprimeRingPoints} coprime)`,
                    `Œ∏=${state.phase.toFixed(17)}¬∞`,
                    `Ring Rot: ${state.ringRotation.toFixed(2)}¬∞`,
                    `Line Thick: ${state.globalLineThickness.toFixed(2)}`,
                    `Mode: ${state.connectionMode}`,
                    `Scheme: ${state.nestedColorScheme}`
                ];
            } else {
                // Default case - shouldn't happen but prevents errors
                console.warn('Unknown canvas type:', canvasType);
                items = [
                    { type: 'section', text: 'Visualization' }
                ];
                parameters = [
                    `m=${state.modulus}`,
                    `Œ∏=${state.phase.toFixed(0)}¬∞`
                ];
            }

            // Calculate legend height
            const totalItems = items.length + parameters.length + 3; // +3 for titles
            const legendHeight = Math.min(totalItems * itemHeight * 0.8 + padding * 4, totalHeight - 40);
            const legendY = (totalHeight - legendHeight) / 2; // Center vertically

            ctx.save();
            
            // Legend background
            ctx.fillStyle = 'rgba(10, 14, 39, 0.95)';
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
            ctx.lineWidth = 2;
            ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
            ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);

            // Title
            let currentY = legendY + padding + titleSize;
            ctx.fillStyle = '#ffd700';
            ctx.font = `bold ${titleSize}px "Fira Code"`;
            ctx.textAlign = 'left';
            ctx.fillText('LEGEND', legendX + padding, currentY);
            
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(legendX + padding, currentY + 5);
            ctx.lineTo(legendX + legendWidth - padding, currentY + 5);
            ctx.stroke();
            
            currentY += itemHeight * 0.7;

            // Draw items
            items.forEach(item => {
                if (item.type === 'section') {
                    // Section header
                    currentY += itemHeight * 0.3;
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                    ctx.font = `bold ${sectionTitleSize}px "Fira Code"`;
                    ctx.fillText(item.text, legendX + padding, currentY);
                    
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(legendX + padding, currentY + 3);
                    ctx.lineTo(legendX + legendWidth - padding, currentY + 3);
                    ctx.stroke();
                    
                    currentY += itemHeight * 0.5;
                } else {
                    // Regular item with symbol
                    ctx.fillStyle = item.color;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    
                    // Draw symbol
                    const symX = legendX + padding;
                    const symY = currentY - symbolSize * 0.6;
                    
                    ctx.beginPath();
                    ctx.arc(symX + symbolSize/2, symY + symbolSize/2, symbolSize/2, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();

                    // Text
                    ctx.fillStyle = '#e8f1f5';
                    ctx.font = `${fontSize}px "Fira Code"`;
                    ctx.fillText(item.text, legendX + padding + symbolSize + 8, currentY);
                    
                    currentY += itemHeight * 0.75;
                }
            });

            // Parameters section
            currentY += itemHeight * 0.2;
            ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
            ctx.font = `bold ${sectionTitleSize}px "Fira Code"`;
            ctx.fillText('Params', legendX + padding, currentY);
            
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(legendX + padding, currentY + 3);
            ctx.lineTo(legendX + legendWidth - padding, currentY + 3);
            ctx.stroke();
            
            currentY += itemHeight * 0.5;

            ctx.font = `${fontSize * 0.95}px "Fira Code"`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            parameters.forEach(param => {
                ctx.fillText('‚Ä¢ ' + param, legendX + padding, currentY);
                currentY += itemHeight * 0.6;
            });

            // Analysis section - add mathematical insights
            if (currentY < legendY + legendHeight - itemHeight * 3) {
                currentY += itemHeight * 0.3;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.font = `bold ${sectionTitleSize}px "Fira Code"`;
                ctx.fillText('Analysis', legendX + padding, currentY);
                
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(legendX + padding, currentY + 3);
                ctx.lineTo(legendX + legendWidth - padding, currentY + 3);
                ctx.stroke();
                
                currentY += itemHeight * 0.5;

                ctx.font = `${fontSize * 0.9}px "Fira Code"`;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.75)';
                
                let insights = [];
                
                if (canvasType === 'disk' || canvasType === 'all') {
                    const coprimeDensity = state.fareyPoints.filter(fp => gcd(fp.num, fp.den) === 1).length / state.fareyPoints.length;
                    insights.push(`Coprime density: ${(coprimeDensity * 100).toFixed(0)}%`);
                    
                    if (state.modulus > 1) {
                        const phiRatio = (eulerPhi(state.modulus) / state.modulus).toFixed(3);
                        insights.push(`œÜ(m)/m = ${phiRatio}`);
                    }
                }
                
                if (canvasType === 'nested' || canvasType === 'all') {
                    const ringCount = state.maxRing - state.minRing + 1;
                    if (ringCount > 1) {
                        insights.push(`Avg pts/ring: ${(totalRingPoints / ringCount).toFixed(1)}`);
                    }
                }
                
                if (canvasType === 'cayley') {
                    const aspectRatio = (state.cayleyHRange / state.cayleyVRange).toFixed(2);
                    insights.push(`Aspect ratio: ${aspectRatio}:1`);
                }
                
                // Universal insights
                if (state.filters.enabled) {
                    insights.push(`‚ö† Filters active`);
                }
                
                insights.forEach(insight => {
                    if (currentY < legendY + legendHeight - itemHeight * 0.8) {
                        ctx.fillText('‚ñ∏ ' + insight, legendX + padding, currentY);
                        currentY += itemHeight * 0.55;
                    }
                });
            }

            // Math notation footer
            currentY += itemHeight * 0.15;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = `italic ${fontSize * 0.85}px "Fira Code"`;
            ctx.fillText('ùîª ‚Üí ‚Ñç ‚Üí ‚ÑÇ', legendX + padding, currentY);
            
            ctx.restore();
        }

        function printDiagnostics() {
            console.log('=== FAREY TRIANGLE & CAYLEY TRANSFORM DIAGNOSTICS ===');
            console.log('\n[BASIC PARAMETERS]:');
            console.log('  Modulus m:', state.modulus);
            console.log('  Phase rotation:', state.phase, 'degrees');
            console.log('  Animation speed:', state.animSpeed + 'x');
            
            console.log('\n[CAYLEY PLANE VIEW]:');
            console.log('  Horizontal range (Re):', -state.cayleyHRange / 2, 'to', state.cayleyHRange / 2);
            console.log('  Vertical range (Im):', state.cayleyVOffset, 'to', state.cayleyVRange + state.cayleyVOffset);
            console.log('  Vertical offset:', state.cayleyVOffset);
            console.log('  Grid density:', state.cayleyGridDensity);
            
            console.log('\n[NESTED RINGS]:');
            console.log('  Ring range: m =', state.minRing, 'to', state.maxRing);
            console.log('  Ring spacing factor:', state.ringSpacing);
            console.log('  Total rings:', state.maxRing - state.minRing + 1);
            
            console.log('\n[FAREY POINTS]:');
            const phase = state.phase * Math.PI / 180;
            state.fareyPoints.forEach((fp, idx) => {
                const frac = fp.num / fp.den;
                const angle = 2 * Math.PI * frac + phase;
                const z = { re: Math.cos(angle), im: Math.sin(angle) };
                const w = cayleyTransform(z, state.transformType);
                console.log(`  ${idx + 1}. ${fp.num}/${fp.den} = ${frac.toFixed(6)}`);
                console.log(`     Unit Disk:     z = ${z.re.toFixed(6)} + ${z.im.toFixed(6)}i`);
                console.log(`     Upper Half-Plane: w = ${w.re.toFixed(6)} + ${w.im.toFixed(6)}i`);
                console.log(`     |z| = ${Math.sqrt(z.re*z.re + z.im*z.im).toFixed(6)}`);
                console.log(`     Im(w) = ${w.im.toFixed(6)}`);
            });
            
            console.log('\n[PRIME DISTRIBUTION]:');
            console.log('  Total primes available:', state.primes.length);
            console.log('  Displaying:', Math.min(state.numPrimes, state.primes.length));
            console.log('  Prime limit:', state.primeLimit);
            if (state.primes.length > 0) {
                console.log('  First 10 primes:', state.primes.slice(0, 10).join(', '));
                console.log('  Last 10 primes:', state.primes.slice(-10).join(', '));
            }
            
            console.log('\n[CONNECTION MODE]:', state.connectionMode);
            console.log('  Thickness:', state.connectionThickness);
            console.log('  Opacity:', state.connectionOpacity);
            
            console.log('\n[LABEL MODE]:', state.labelMode);
            console.log('  Size:', state.labelSize + 'px');
            console.log('  Frequency: every', state.labelFreq, 'ring(s)');
            
            console.log('\n[DISPLAY TOGGLES]:');
            const toggles = [
                'toggleFarey', 'toggleGeodesic', 'togglePrimes', 'toggleChannels',
                'toggleCusps', 'toggleRings', 'toggleGCD', 'toggleGrid',
                'toggleFundDomain', 'toggleVerticals', 'toggleDiskOutline', 'toggleAnimate'
            ];
            toggles.forEach(id => {
                const elem = document.getElementById(id);
                if (elem) {
                    console.log('  ' + id.replace('toggle', '') + ':', elem.checked ? '[ON]' : '[OFF]');
                }
            });
            
            console.log('\n[CAYLEY TRANSFORM VERIFICATION]:');
            console.log('  Current Formula: w = i(1+z)/(1-z) [CORRECT]');
            console.log('  Maps unit disk D to upper half-plane H');
            console.log('  Inverse of: f(z) = (z-i)/(z+i) which maps H to D');
            console.log('  Preserves angles (conformal)');

            
            // Test a few points
            const testPoints = [
                { re: 1, im: 0, label: 'z=1' },
                { re: -1, im: 0, label: 'z=-1' },
                { re: 0, im: 1, label: 'z=i' },
                { re: 0, im: 0, label: 'z=0' }
            ];
            
            console.log('\n  Test transformations:');
            testPoints.forEach(z => {
                const w = cayleyTransform(z, state.transformType);
                console.log(`    ${z.label}: w = ${w.re.toFixed(4)} + ${w.im.toFixed(4)}i`);
            });
            
            console.log('\n=====================================================');
        }

        // ========================================
        // CANVAS 7: Coprime Circle
        // ========================================
        function drawCanvas7() {
            const canvas = document.getElementById('canvas7');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;
            const cx = w / 2;
            const cy = h / 2;
            const radius = Math.min(w, h) * 0.4;
            
            // Clear
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, w, h);
            
            const n = state.modulus;
            const phase = state.phase * Math.PI / 180;
            
            // Draw circle
            ctx.strokeStyle = 'rgba(46, 204, 113, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Draw points colored by coprimality
            for (let i = 1; i < n; i++) {
                const angle = 2 * Math.PI * i / n + phase;
                const x = cx + radius * Math.cos(angle);
                const y = cy + radius * Math.sin(angle);
                
                const isCoprime = gcd(i, n) === 1;
                ctx.fillStyle = isCoprime ? '#2ecc71' : 'rgba(231, 76, 60, 0.5)';
                ctx.beginPath();
                ctx.arc(x, y, isCoprime ? 5 : 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw connections between coprimes
                if (isCoprime && state.showConnections) {
                    for (let j = i + 1; j < n; j++) {
                        if (gcd(j, n) === 1) {
                            const angle2 = 2 * Math.PI * j / n + phase;
                            const x2 = cx + radius * Math.cos(angle2);
                            const y2 = cy + radius * Math.sin(angle2);
                            
                            ctx.strokeStyle = 'rgba(46, 204, 113, 0.1)';
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // Center label
            ctx.fillStyle = '#2ecc71';
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`œÜ(${n}) = ${phi(n)}`, cx, cy - 20);
            ctx.font = '16px monospace';
            ctx.fillText(`${phi(n)}/${n} = ${(phi(n)/n).toFixed(4)}`, cx, cy + 10);
        }

        // ========================================
        // CANVAS 8: Phi Ratios Chart
        // ========================================
        function drawCanvas8() {
            const canvas = document.getElementById('canvas8');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;
            
            // Clear
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, w, h);
            
            const maxN = Math.min(state.modulus, 200);
            const margin = 80;
            const chartWidth = w - 2 * margin;
            const chartHeight = h - 2 * margin;
            
            // Draw axes
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, h - margin);
            ctx.lineTo(w - margin, h - margin);
            ctx.stroke();
            
            // Draw phi(n)/n values
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            let firstPoint = true;
            for (let n = 2; n <= maxN; n++) {
                const ratio = phi(n) / n;
                const x = margin + (n / maxN) * chartWidth;
                const y = h - margin - ratio * chartHeight;
                
                if (firstPoint) {
                    ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(x, y);
                }
                
                // Mark primes
                if (isPrime(n)) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#f1c40f';
            ctx.font = 'bold 20px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('œÜ(n)/n Ratio Chart', w / 2, 40);
            
            ctx.font = '14px monospace';
            ctx.fillText('n', w - margin + 20, h - margin + 5);
            ctx.save();
            ctx.translate(margin - 50, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('œÜ(n)/n', 0, 0);
            ctx.restore();
        }

        // ========================================
        // CANVAS 9: Convergence to 6/œÄ¬≤
        // ========================================
        function drawCanvas9() {
            const canvas = document.getElementById('canvas9');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;
            
            // Clear
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, w, h);
            
            const maxN = Math.min(state.modulus, 500);
            const margin = 80;
            const chartWidth = w - 2 * margin;
            const chartHeight = h - 2 * margin;
            const target = 6 / (Math.PI * Math.PI);
            
            // Draw axes
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, h - margin);
            ctx.lineTo(w - margin, h - margin);
            ctx.stroke();
            
            // Draw target line
            const targetY = h - margin - (target / 1.0) * chartHeight;
            ctx.strokeStyle = 'rgba(46, 204, 113, 0.5)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(margin, targetY);
            ctx.lineTo(w - margin, targetY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Calculate cumulative coprime density
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            let coprimeCount = 0;
            let totalCount = 0;
            let firstPoint = true;
            
            for (let n = 1; n <= maxN; n++) {
                for (let k = 1; k < n; k++) {
                    totalCount++;
                    if (gcd(k, n) === 1) coprimeCount++;
                }
                
                const density = coprimeCount / totalCount;
                const x = margin + (n / maxN) * chartWidth;
                const y = h - margin - (density / 1.0) * chartHeight;
                
                if (firstPoint) {
                    ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 20px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Convergence to 6/œÄ¬≤', w / 2, 40);
            
            ctx.font = '14px monospace';
            ctx.fillStyle = '#2ecc71';
            ctx.fillText(`Target: ${target.toFixed(6)}`, w / 2, 65);
        }

        // ========================================
        // CANVAS 10: Coprime Pairs Grid
        // ========================================
        function drawCanvas10() {
            const canvas = document.getElementById('canvas10');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;
            
            // Clear
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, w, h);
            
            const n = Math.min(state.modulus, 50);
            const margin = 60;
            const gridSize = Math.min((w - 2 * margin) / n, (h - 2 * margin) / n);
            
            // Draw grid
            for (let i = 1; i < n; i++) {
                for (let j = 1; j < n; j++) {
                    const x = margin + i * gridSize;
                    const y = margin + j * gridSize;
                    
                    const g = gcd(i, j);
                    const isCoprime = g === 1;
                    
                    ctx.fillStyle = isCoprime ? 
                        'rgba(99, 102, 241, 0.8)' : 
                        `rgba(99, 102, 241, ${0.1 + (1 / g) * 0.3})`;
                    ctx.fillRect(x, y, gridSize - 1, gridSize - 1);
                    
                    // Mark diagonal
                    if (i === j) {
                        ctx.strokeStyle = '#f1c40f';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, gridSize - 1, gridSize - 1);
                    }
                }
            }
            
            // Title
            ctx.fillStyle = '#6366f1';
            ctx.font = 'bold 20px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Coprime Pairs Matrix', w / 2, 35);
            ctx.font = '14px monospace';
            ctx.fillText('Brighter = Coprime', w / 2, 55);
        }

        // ========================================
        // CANVAS 11: Nested Density Rings
        // ========================================
        function drawCanvas11() {
            const canvas = document.getElementById('canvas11');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;
            const cx = w / 2;
            const cy = h / 2;
            const maxRadius = Math.min(w, h) * 0.45;
            
            // Clear
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, w, h);
            
            const maxN = Math.min(state.modulus, 30);
            const phase = state.phase * Math.PI / 180;
            
            // Draw rings from 1 to maxN
            for (let n = 2; n <= maxN; n++) {
                const radius = (n / maxN) * maxRadius;
                const phiN = phi(n);
                
                // Per-ring rotation support
                let perRingOffset = 0;
                if (state.perRingRotations && state.perRingRotations[n] !== undefined) {
                    perRingOffset = state.perRingRotations[n] * Math.PI / 180;
                }
                
                // Draw ring circle
                ctx.strokeStyle = `rgba(39, 174, 96, ${0.2 + (phiN / n) * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Draw coprime points on this ring
                for (let k = 1; k < n; k++) {
                    if (gcd(k, n) === 1) {
                        const angle = 2 * Math.PI * k / n + phase + perRingOffset;
                        const x = cx + radius * Math.cos(angle);
                        const y = cy + radius * Math.sin(angle);
                        
                        ctx.fillStyle = '#27ae60';
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
                
                // Label every 5th ring
                if (n % 5 === 0) {
                    ctx.fillStyle = '#27ae60';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText(`n=${n}`, cx + radius + 10, cy);
                }
            }
            
            // Center label
            ctx.fillStyle = '#27ae60';
            ctx.font = 'bold 18px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Nested Density Rings', cx, cy);
            ctx.font = '14px monospace';
            ctx.fillText(`Showing 1 to ${maxN}`, cx, cy + 25);
        }

        // ========================================
        // CANVAS 12: Dirichlet Characters
        // ========================================
        function drawCanvas12() {
            const canvas = document.getElementById('canvas12');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;
            const cx = w / 2;
            const cy = h / 2;
            const radius = Math.min(w, h) * 0.4;
            
            // Clear
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, w, h);
            
            const m = state.modulus;
            const phase = state.phase * Math.PI / 180;
            
            // Draw main circle
            ctx.strokeStyle = 'rgba(156, 39, 176, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Calculate principal Dirichlet character mod m
            // œá(n) = 1 if gcd(n,m)=1, 0 otherwise (principal character)
            const phiM = phi(m);
            const colors = ['#9c27b0', '#e91e63', '#f44336', '#ff9800', '#ffc107', '#8bc34a', '#4caf50', '#00bcd4'];
            
            // For each residue class, calculate character value
            for (let n = 1; n < m; n++) {
                const g = gcd(n, m);
                const angle = 2 * Math.PI * n / m + phase;
                const x = cx + radius * Math.cos(angle);
                const y = cy + radius * Math.sin(angle);
                
                if (g === 1) {
                    // Coprime - part of character group
                    // Calculate order of n in (Z/mZ)*
                    let order = 1;
                    let power = n % m;
                    while (power !== 1 && order < m) {
                        power = (power * n) % m;
                        order++;
                    }
                    
                    const colorIndex = order % colors.length;
                    ctx.fillStyle = colors[colorIndex];
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw ray for character
                    ctx.strokeStyle = colors[colorIndex] + '40';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                } else {
                    // Not coprime - œá(n) = 0
                    ctx.fillStyle = 'rgba(156, 39, 176, 0.2)';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            // Center labels
            ctx.fillStyle = '#9c27b0';
            ctx.font = 'bold 20px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Dirichlet Characters', cx, cy - 30);
            ctx.font = '16px monospace';
            ctx.fillText(`mod ${m}`, cx, cy);
            ctx.font = '14px monospace';
            ctx.fillText(`œÜ(${m}) = ${phiM}`, cx, cy + 25);
        }

        // ========================================
        // Export Functions for Canvases 7-12
        // ========================================
        function exportCanvas7() { exportSingleCanvas('canvas7', 'coprime_circle_4k.png'); }
        function exportCanvas8() { exportSingleCanvas('canvas8', 'phi_ratios_4k.png'); }
        function exportCanvas9() { exportSingleCanvas('canvas9', 'convergence_4k.png'); }
        function exportCanvas10() { exportSingleCanvas('canvas10', 'coprime_grid_4k.png'); }
        function exportCanvas11() { exportSingleCanvas('canvas11', 'density_rings_4k.png'); }
        function exportCanvas12() { exportSingleCanvas('canvas12', 'dirichlet_characters_4k.png'); }

        // ========================================
        // Master Draw Function - All 12 Canvases
        // ========================================
        function drawAll() {
            drawDisk();
            drawCayley();
            drawNested();
            drawReduction();
            drawFullPlane();
            // Canvas 6 (Pixi) draws itself
            drawCanvas7();
            drawCanvas8();
            drawCanvas9();
            drawCanvas10();
            drawCanvas11();
            drawCanvas12();
        }

        console.log('‚úÖ 12-Canvas Mega Research Tool Initialized');
        console.log('By Wessen Getachew');
        console.log('Canvases 1-6: Farey & Transform Suite');
        console.log('Canvases 7-11: Coprime Density Analysis');
        console.log('Canvas 12: Dirichlet Characters (NEW)');
    </script>
</body>
</html>
