<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Modular Lifting Rings v8.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1f2e 0%, #2d3748 100%);
            color: #e2e8f0;
            min-height: 100vh;
            transition: background 0.3s ease, color 0.3s ease;
        }
        
        body.light-mode {
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            color: #2d3748;
        }
        
        body.light-mode .app-header {
            background: linear-gradient(135deg, #ffffff 0%, #f7fafc 100%);
            border-bottom: 2px solid #e2e8f0;
        }
        
        body.light-mode .control-panel,
        body.light-mode .visualization-panel,
        body.light-mode .analysis-panel {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e2e8f0;
        }
        
        body.light-mode .section-card {
            background: #ffffff;
            border: 1px solid #e2e8f0;
        }
        
        body.light-mode h1,
        body.light-mode h2,
        body.light-mode h3 {
            color: #2d3748;
        }

        .app-header {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            padding: 20px 30px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .header-content {
            max-width: 1800px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-title h1 {
            font-size: 1.8em;
            font-weight: 600;
            color: #FFD700;
            margin-bottom: 4px;
        }

        .header-title .subtitle {
            font-size: 0.9em;
            opacity: 0.8;
            color: #cbd5e0;
        }

        .header-actions {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .app-container {
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 300px minmax(600px, 1fr) 350px;
            gap: 15px;
            min-height: calc(100vh - 100px);
        }

        .control-panel {
            background: rgba(45, 55, 72, 0.95);
            border-radius: 12px;
            padding: 0;
            height: fit-content;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .panel-header {
            position: sticky;
            top: 0;
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            padding: 15px 20px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.2);
            z-index: 10;
        }

        .panel-header h2 {
            font-size: 1.2em;
            font-weight: 600;
            color: #FFD700;
            margin: 0;
        }

        .panel-content {
            padding: 15px;
        }

        .section-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.2s ease;
        }

        .section-card:hover {
            border-color: rgba(255, 215, 0, 0.3);
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.1);
        }

        .section-card h3 {
            color: #cbd5e0;
            margin-bottom: 12px;
            font-size: 0.95em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
        }

        .section-card.collapsed .section-content {
            display: none;
        }

        .section-content {
            margin-top: 12px;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 8px;
            border-radius: 6px;
            transition: background 0.2s;
            font-size: 0.9em;
        }

        .checkbox-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .checkbox-item input[type="checkbox"] {
            transform: scale(1.2);
            accent-color: #FFD700;
        }

        .visualization-panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .canvas-wrapper {
            position: relative;
            background: #000000;
            border-radius: 8px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            overflow: hidden;
        }

        #canvas {
            border-radius: 8px;
            background: #000000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 100%;
            max-width: 100%;
            max-height: 875px;
            height: auto;
            cursor: grab;
            display: block;
        }

        #canvas:active {
            cursor: grabbing;
        }

        #canvas.distance-mode {
            cursor: crosshair !important;
        }

        .distance-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .distance-overlay.active {
            pointer-events: all;
        }

        .analysis-panel {
            background: rgba(45, 55, 72, 0.95);
            border-radius: 12px;
            padding: 0;
            height: fit-content;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .tab-navigation {
            display: flex;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px 8px 0 0;
            overflow: hidden;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .tab-button {
            flex: 1;
            padding: 12px 15px;
            background: transparent;
            border: none;
            color: #cbd5e0;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
        }

        .tab-button:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #FFD700;
        }

        .tab-button.active {
            color: #FFD700;
            border-bottom-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        .tab-content {
            display: none;
            padding: 20px;
        }

        .tab-content.active {
            display: block;
        }

        .rh-section {
            background: linear-gradient(45deg, rgba(255, 215, 0, 0.12), rgba(72, 187, 120, 0.12));
            border: 1px solid rgba(255, 215, 0, 0.25);
        }

        .rh-btn {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #000000;
            font-weight: 600;
            border: 1px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.2);
        }

        .rh-btn:hover {
            background: linear-gradient(45deg, #FFA500, #FF8C00);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
        }

        .rh-info {
            background: linear-gradient(45deg, rgba(255, 215, 0, 0.1), rgba(72, 187, 120, 0.1));
            border-left: 3px solid #48BB78;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .validation-status {
            position: absolute;
            top: 50px;
            right: 10px;
            background: linear-gradient(45deg, #48BB78, #38a169);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: bold;
            border: 2px solid rgba(255, 215, 0, 0.4);
            z-index: 10;
            box-shadow: 0 4px 15px rgba(72, 187, 120, 0.3);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { 
                box-shadow: 0 4px 15px rgba(72, 187, 120, 0.3);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 6px 20px rgba(72, 187, 120, 0.5);
                transform: scale(1.02);
            }
        }

        .rh-visualization-section {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 30, 0.9));
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .rh-visualization-section h3 {
            color: #FFD700;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.3em;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .rh-visual-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .critical-line-display,
        .character-support-display,
        .prime-distribution-display {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            text-align: center;
        }

        .rh-visual-title {
            color: #FFD700;
            font-weight: 600;
            margin: 10px 0 5px 0;
            font-size: 1.1em;
        }

        .rh-visual-desc {
            color: #bdc3c7;
            font-size: 0.9em;
            font-style: italic;
        }

        .rh-research-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .rh-explanation {
            background: linear-gradient(45deg, rgba(255, 215, 0, 0.08), rgba(72, 187, 120, 0.08));
            border: 2px solid rgba(255, 215, 0, 0.25);
            border-radius: 15px;
            padding: 20px;
            margin: 18px 0;
            font-size: 14px;
            position: relative;
            overflow: hidden;
        }

        .rh-explanation::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #FFD700, #48BB78, #FFD700);
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1.0; }
        }

        .rh-notice {
            background: linear-gradient(45deg, rgba(255, 215, 0, 0.1), rgba(72, 187, 120, 0.1));
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin: 18px 0;
            font-size: 14px;
            position: relative;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.1);
        }

        .unit-circle-highlight {
            background: rgba(160, 174, 192, 0.12);
            border: 1px solid rgba(160, 174, 192, 0.25);
            font-weight: 500;
        }

        .custom-gap {
            margin-top: 12px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .gap-input {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .gap-input input {
            width: 70px;
            padding: 8px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
            text-align: center;
        }

        .gap-input input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        button {
            background: #4a5568;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 8px 14px;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-weight: 500;
            font-size: 13px;
            transition: all 0.2s ease;
            margin: 2px;
            font-family: inherit;
        }

        button:hover {
            background: #5a6478;
            border-color: rgba(255, 255, 255, 0.25);
            transform: translateY(-1px);
        }

        .reset-btn {
            background: #e53e3e;
            border-color: rgba(229, 62, 62, 0.3);
        }

        .special-btn {
            background: #805ad5;
            border-color: rgba(128, 90, 213, 0.3);
        }

        .slider-group {
            margin: 15px 0;
        }

        .slider-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
        }

        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #a0aec0;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .slider-group select {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-size: 14px;
        }

        .slider-group input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 100%;
            max-width: 100%;
            overflow: hidden;
            box-sizing: border-box;
        }

        #canvas {
            border-radius: 8px;
            background: #000000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 100%;
            max-height: 875px;
            width: auto;
            height: auto;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .analysis-section {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 25px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .analysis-section h3 {
            color: #a0aec0;
            margin-bottom: 20px;
            font-size: 1.2em;
            text-align: center;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .analysis-section h3:hover {
            color: #cbd5e0;
        }

        .collapse-icon {
            transition: transform 0.3s ease;
            font-size: 0.8em;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .ring-info {
            margin: 10px 0;
            padding: 12px;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 6px;
            font-size: 13px;
            border-left: 3px solid #a0aec0;
        }

        .unit-circle-info {
            background: rgba(160, 174, 192, 0.12);
            border-left: 3px solid #a0aec0;
            font-weight: 500;
        }

        .collapsible-content {
            max-height: 500px;
            overflow-y: auto;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
        }

        .collapsible-section {
            max-height: 2000px;
            overflow-y: auto;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .collapsible-section.collapsed {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
        }

        .legend {
            margin-top: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .legend h3 {
            color: #a0aec0;
            margin-bottom: 20px;
            font-size: 1.2em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .legend-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.03);
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .math-notation {
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }

        @media (max-width: 1200px) {
            .app-container {
                grid-template-columns: 1fr;
            }
            
            #canvas {
                width: 100%;
                max-width: 90vw;
                height: auto;
            }
        }

        @media (max-width: 768px) {
            .canvas-container {
                padding: 15px;
            }
            
            #canvas {
                max-width: 95vw;
                max-height: 500px;
            }
            
            .container {
                padding: 15px;
            }
        }

        .animation-status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
        
        .keyboard-shortcuts {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 15px;
            font-size: 12px;
            max-width: 250px;
            display: none;
        }
        
        .keyboard-shortcuts.visible {
            display: block;
        }
        
        .keyboard-shortcuts h4 {
            margin: 0 0 10px 0;
            color: #FFD700;
        }
        
        .keyboard-shortcuts kbd {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 11px;
        }
        
        .hover-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #FFD700;
            border-radius: 8px;
            padding: 12px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10000;
            max-width: 300px;
            display: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        
        .hover-tooltip.visible {
            display: block;
        }
        
        .hover-tooltip h5 {
            margin: 0 0 8px 0;
            color: #FFD700;
            font-size: 14px;
        }
        
        .hover-tooltip .property {
            margin: 4px 0;
            color: #4ECDC4;
        }
        
        .hover-tooltip .property strong {
            color: #ffffff;
        }
        
        .color-palette-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin: 10px 0;
        }
        
        .palette-option {
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .palette-option:hover {
            transform: scale(1.05);
            border-color: #FFD700;
        }
        
        .palette-option.active {
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .palette-option.rainbow {
            background: linear-gradient(90deg, #FF6B6B, #FFD700, #4ECDC4, #9b59b6);
        }
        
        .palette-option.ocean {
            background: linear-gradient(90deg, #006994, #1e90ff, #4ECDC4, #7fcdbb);
        }
        
        .palette-option.sunset {
            background: linear-gradient(90deg, #FF6B6B, #FF8C42, #FFA500, #FFD700);
        }
        
        .palette-option.matrix {
            background: linear-gradient(90deg, #003300, #00ff00, #00cc00, #39FF14);
        }
        
        .palette-option.fire {
            background: linear-gradient(90deg, #8B0000, #FF0000, #FF4500, #FFA500);
        }
        
        .palette-option.ice {
            background: linear-gradient(90deg, #E0FFFF, #ADD8E6, #87CEEB, #4682B4);
        }
        
        .palette-option.purple {
            background: linear-gradient(90deg, #4B0082, #8B008B, #9370DB, #BA55D3);
        }
        
        .palette-option.earth {
            background: linear-gradient(90deg, #8B4513, #D2691E, #DEB887, #F4A460);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="theme-toggle" onclick="toggleTheme()">
            <span id="themeIcon">üåô</span>
            <span id="themeText">Dark Mode</span>
        </div>
        
        <div class="keyboard-shortcuts" id="keyboardShortcuts">
            <h4>‚å®Ô∏è Keyboard Shortcuts</h4>
            <div><kbd>?</kbd> Toggle this help</div>
            <div><kbd>T</kbd> Toggle theme</div>
            <div><kbd>R</kbd> Toggle rotation</div>
            <div><kbd>L</kbd> Toggle labels</div>
            <div><kbd>Space</kbd> Start/Stop animation</div>
            <div><kbd>‚Üê‚Üí</kbd> Adjust rotation</div>
            <div><kbd>‚Üë‚Üì</kbd> Adjust zoom</div>
            <div><kbd>Esc</kbd> Reset view</div>
            <div><kbd>S</kbd> Take screenshot</div>
            <div><kbd>1-8</kbd> Quick gap selection</div>
        </div>
        
        <div class="hover-tooltip" id="hoverTooltip">
            <h5 id="tooltipTitle">Residue Info</h5>
            <div id="tooltipContent"></div>
        </div>
        
        <h1>Riemann Hypothesis Explorer</h1>
        <div class="subtitle">Interactive Modular Rings & Complex Analysis Visualization<br>
        <em class="math-notation">Exploring Œ∂(s), L(s,œá), and Prime Distribution through Geometric Patterns</em></div>

        <div class="main-grid">
            <div class="controls">
                
                <div class="control-section" style="background: linear-gradient(45deg, rgba(78, 205, 196, 0.15), rgba(138, 43, 226, 0.15)); border: 2px solid rgba(78, 205, 196, 0.4);">
                    <h3 onclick="toggleSection('layoutSection')" style="cursor: pointer; user-select: none; color: #4ECDC4;">
                        <span class="collapse-icon collapsed" id="layoutSectionIcon">‚ñº</span>
                        Coordinate System Layout
                    </h3>
                    <div id="layoutSection" class="collapsible-section collapsed">
                    
                    <div class="slider-group">
                        <label><strong>Coordinate System:</strong></label>
                        <select id="coordinateSystem" onchange="updateCoordinateSystem()" style="width: 100%; padding: 8px; border-radius: 6px; font-size: 13px;">
                            <option value="polar" selected>Polar/Concentric (default)</option>
                            <option value="log-cylinder">Log-Cylinder (u=ln m, v=Œ∏)</option>
                            <option value="spiral">Logarithmic Spiral</option>
                            <option value="hyperbolic">Hyperbolic (Poincar√© disk)</option>
                            <option value="rectangular">Rectangular Grid</option>
                            <option value="treemap">Treemap/Packing</option>
                            <option value="voronoi">Voronoi Tessellation</option>
                            <option value="fractal">Fractal Self-Similar</option>
                        </select>
                    </div>
                    
                    <div id="coordinateParams" style="margin-top: 15px;">
                        <!-- Parameters for each coordinate system -->
                    </div>
                    
                    <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px; padding: 10px; background: rgba(78, 205, 196, 0.1); border-radius: 6px; border-left: 3px solid #4ECDC4;">
                        <strong>Current System:</strong><br>
                        <span id="coordSystemDesc">Traditional polar coordinates with concentric rings</span>
                    </div>
                    
                    </div>
                </div>
                <div class="control-section">
                    <h3 onclick="toggleSection('globalScaleSection')" style="cursor: pointer; user-select: none;">
                        <span class="collapse-icon collapsed" id="globalScaleSectionIcon">‚ñº</span>
                        Global Scale Control
                    </h3>
                    <div id="globalScaleSection" class="collapsible-section collapsed">
                        <div class="slider-group">
                            <label>Global Visual Scale: <span id="globalScaleValue">1.0</span>x</label>
                            <input type="range" id="globalScale" min="0.3" max="3.0" step="0.1" value="1.0" oninput="updateGlobalScale()">
                        </div>
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                            <strong>Scales entire system:</strong><br>
                            ‚Ä¢ Ring radii and spacing<br>
                            ‚Ä¢ Point sizes and line thickness<br>
                            ‚Ä¢ Labels and annotations<br>
                            ‚Ä¢ Prime-phase field vectors<br>
                            Use for better visibility or to fit more rings on screen
                        </div>
                    </div>
                </div>

                <div class="control-section rh-section">
                    <h3 onclick="toggleSection('rhSection')" style="cursor: pointer; user-select: none;">
                        <span class="collapse-icon collapsed" id="rhSectionIcon">‚ñº</span>
                        Riemann Hypothesis Research Hub
                    </h3>
                    <div id="rhSection" class="collapsible-section collapsed">
                    
                    
                    <div class="custom-gap" style="background: linear-gradient(45deg, rgba(255, 215, 0, 0.15), rgba(72, 187, 120, 0.15)); border: 2px solid rgba(255, 215, 0, 0.3); margin-top: 15px;">
                        <label><strong>Zero-Residue Alignment Diagnostics:</strong></label>
                        <div class="checkbox-item">
                            <input type="checkbox" id="enableZeroAlignment" onchange="toggleZeroAlignment()"> Enable Alignment Analysis
                        </div>
                        
                        <div id="zeroAlignmentControls" style="display: none; margin-top: 10px;">
                            <div class="slider-group">
                                <label>Height t (imaginary part): <span id="alignmentTValue">14.134</span></label>
                                <input type="range" id="alignmentT" min="0" max="100" step="0.5" value="14.134" oninput="updateAlignmentT()">
                            </div>
                            
                            <div class="slider-group">
                                <label>Prime Cutoff X: <span id="alignmentXValue">1000</span></label>
                                <input type="range" id="alignmentX" min="100" max="10000" step="100" value="1000" oninput="updateAlignmentX()">
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="showPrimePhaseVectors" checked onchange="updateZeroAlignment()"> Show Prime-Phase Vectors P_t(M,r)
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="showCoherenceScore" checked onchange="updateZeroAlignment()"> Show Coherence Score C_t
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="enableTSweep" onchange="toggleTSweep()"> Enable t-Sweep Animation
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="showRandomBaseline" onchange="updateZeroAlignment()"> Compare with Random Phase Baseline
                            </div>
                            
                            <div class="slider-group" id="tSweepControls" style="display: none;">
                                <label>Sweep Speed: <span id="tSweepSpeedValue">1.0</span>x</label>
                                <input type="range" id="tSweepSpeed" min="0.1" max="5.0" step="0.1" value="1.0" oninput="updateTSweepSpeed()">
                            </div>
                            
                            <div class="gap-input" style="margin-top: 15px;">
                                <button class="rh-btn" onclick="computeAlignmentForAllZeros()">Test All Known Zeros</button>
                                <button class="rh-btn" onclick="findCoherencePeaks()">Find Coherence Peaks</button>
                            </div>
                            
                            <div id="alignmentResults" style="display: none; margin-top: 15px; padding: 15px; background: rgba(72, 187, 120, 0.1); border-radius: 8px; border: 2px solid rgba(72, 187, 120, 0.3);">
                                <strong>Alignment Analysis Results:</strong>
                                <div id="alignmentResultsContent" style="font-size: 12px; margin-top: 10px;"></div>
                            </div>
                            
                            <div style="font-size: 11px; opacity: 0.85; margin-top: 10px; padding: 8px; background: rgba(255, 215, 0, 0.1); border-radius: 4px;">
                                <strong>Mathematical Framework:</strong><br>
                                ‚Ä¢ P_t(M,r) = Œ£ p^(-1/2) e^(it¬∑ln p) for p‚â°r (mod M)<br>
                                ‚Ä¢ C_t = Œ£ Re(P_t(M,r)) measures global coherence<br>
                                ‚Ä¢ Peaks in C_t correlate with zero heights<br>
                                ‚Ä¢ Random baseline tests genuine alignment vs noise
                            </div>
                        </div>
                    </div>
                    
                    <div class="custom-gap" style="background: linear-gradient(45deg, rgba(255, 215, 0, 0.12), rgba(72, 187, 120, 0.12)); border: 2px solid rgba(255, 215, 0, 0.3); margin-bottom: 15px;">
                        <label><strong>Advanced Distance Measurement:</strong></label>
                        <div class="checkbox-item">
                            <input type="checkbox" id="enableDistanceTool" onchange="toggleDistanceTool()"> Enable Multi-Point Measurement
                        </div>
                        <div id="distanceControls" style="display: none; margin-top: 10px;">
                            <div class="slider-group">
                                <label>Measurement Mode:</label>
                                <select id="distanceMode" onchange="updateDistanceMode()">
                                    <option value="euclidean">Euclidean (straight line)</option>
                                    <option value="manhattan">Manhattan (|Œîx| + |Œîy|)</option>
                                    <option value="geodesic">Geodesic (along ring)</option>
                                    <option value="angular">Angular (radians)</option>
                                    <option value="modular">Modular Arithmetic</option>
                                </select>
                            </div>
                            
                            <div class="slider-group">
                                <label>Path Type:</label>
                                <select id="pathType" onchange="updatePathType()">
                                    <option value="sequential">Sequential (point-to-point)</option>
                                    <option value="closed">Closed Loop</option>
                                    <option value="star">Star (all to centroid)</option>
                                    <option value="mst">Minimum Spanning Tree</option>
                                    <option value="tsp">Traveling Salesman</option>
                                </select>
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="showDistanceLabels" onchange="draw()"> Show Distance Labels
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="showAngles" onchange="draw()"> Show Angles
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="showMidpoints" onchange="draw()"> Show Midpoints
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="showCentroid" onchange="draw()"> Show Centroid
                            </div>
                            
                            <div style="margin-top: 12px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                <strong>Quick Selection:</strong>
                                <div class="gap-input" style="margin-top: 8px;">
                                    <button onclick="selectAllOnRing()">All on Ring</button>
                                    <button onclick="selectPrimesOnly()">Primes Only</button>
                                    <button onclick="selectByGCD()">By GCD=1</button>
                                </div>
                            </div>
                            
                            <div style="font-size: 12px; opacity: 0.9; margin: 12px 0 8px 0;">
                                <strong>Manual Point Entry:</strong>
                            </div>
                            <div class="gap-input">
                                r = <input type="number" id="pointResidue" min="0" placeholder="0" style="width: 50px;">
                                M = <input type="number" id="pointModulus" min="1" placeholder="30" style="width: 50px;">
                                <button onclick="addMeasurementPoint()" style="background: #4ECDC4; color: #fff; font-weight: bold;">Add Point</button>
                            </div>
                            
                            <div id="pointsList" style="max-height: 150px; overflow-y: auto; margin: 10px 0; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 6px; font-size: 11px;">
                                <em>No points selected. Click points on canvas or enter manually.</em>
                            </div>
                            
                            <div id="distanceResults" style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px; min-height: 80px; margin-bottom: 10px; font-size: 12px;">
                                <strong>Statistics</strong><br>
                                <em>Select 2+ points to see analysis</em>
                            </div>
                            
                            <div class="gap-input">
                                <button onclick="clearAllPoints()">Clear All</button>
                                <button onclick="exportMeasurementData()">Export Data</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="custom-gap" style="background: linear-gradient(45deg, rgba(138, 43, 226, 0.12), rgba(75, 0, 130, 0.12)); border: 2px solid rgba(138, 43, 226, 0.3); margin-bottom: 15px;">
                        <label><strong>Farey Sequence & Franel-Landau Analysis:</strong></label>
                        <div class="gap-input">
                            Farey order N: <input type="number" id="fareyOrder" min="2" max="1000" value="30" style="width: 70px;">
                            <button class="rh-btn" onclick="generateFareySequence()">Compute Farey</button>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showFareyVisualization" onchange="updateRhVisualizations()"> Show Farey Discrepancy Plot
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showFranelLandau" onchange="updateRhVisualizations()"> Show Franel-Landau Test
                        </div>
                        <div id="fareyResults" style="display: none; margin-top: 10px; background: rgba(138, 43, 226, 0.1); padding: 12px; border-radius: 6px;">
                            <strong>Farey Sequence Results:</strong><br>
                            <div id="fareyStats" style="font-size: 12px; margin-top: 8px;"></div>
                        </div>
                        <div style="font-size: 11px; opacity: 0.85; margin-top: 8px; line-height: 1.4;">
                            <strong>Franel-Landau Theorem:</strong> RH is equivalent to<br>
                            <em style="font-family: 'Times New Roman', serif;">D(N) = O(N^(1/2+Œµ))</em><br>
                            where D(N) measures discrepancy from uniform spacing
                        </div>
                    </div>
                    
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableRhAnalysis"> Enable RH Predictions
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showCharacterSupport" checked> Show Dirichlet Character Support
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showLFunctionZeros"> Visualize L-function Critical Line
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showEquidistributionTest"> Test Prime Equidistribution
                    </div>
                    
                    <div class="custom-gap" style="margin-top: 15px;">
                        <label><strong>RH Visualization Controls:</strong></label>
                        
                        <!-- Critical Line Analysis -->
                        <div class="checkbox-item">
                            <input type="checkbox" id="showCriticalLine" checked onchange="toggleRhVisualization('criticalLineCanvas')"> Critical Line Analysis
                        </div>
                        <div id="criticalLineParams" class="gap-input" style="margin-left: 25px; display: block;">
                            t-range: <input type="number" id="criticalLineTMin" min="0" value="0" style="width: 50px;"> to 
                            <input type="number" id="criticalLineTMax" min="1" value="50" style="width: 50px;">
                            <button onclick="updateRhVisualizations()" style="font-size: 11px; padding: 4px 8px;">Apply</button>
                        </div>
                        
                        <!-- Character Support Domains -->
                        <div class="checkbox-item">
                            <input type="checkbox" id="showCharacterCanvas" checked onchange="toggleRhVisualization('characterCanvas')"> Character Support Domains
                        </div>
                        <div id="characterParams" class="gap-input" style="margin-left: 25px; display: block;">
                            Max rings: <input type="number" id="characterMaxRings" min="1" max="20" value="10" style="width: 50px;">
                            <button onclick="updateRhVisualizations()" style="font-size: 11px; padding: 4px 8px;">Apply</button>
                        </div>
                        
                        <!-- Prime Distribution -->
                        <div class="checkbox-item">
                            <input type="checkbox" id="showPrimeDistCanvas" checked onchange="toggleRhVisualization('primeDistCanvas')"> Prime Distribution
                        </div>
                        <div id="primeDistParams" class="gap-input" style="margin-left: 25px; display: block;">
                            <em style="font-size: 11px; opacity: 0.8;">Uses active sieve data</em>
                        </div>
                        
                        <!-- Zeta Function Zeros -->
                        <div class="checkbox-item">
                            <input type="checkbox" id="showZetaZeros" checked onchange="toggleRhVisualization('zetaZerosCanvas')"> Zeta Function Zeros
                        </div>
                        <div id="zetaZerosParams" class="gap-input" style="margin-left: 25px; display: block;">
                            Show zeros: <input type="number" id="zetaZerosCount" min="1" max="50" value="10" style="width: 50px;">
                            <label style="font-size: 11px;"><input type="checkbox" id="animateZetaZeros"> Animate</label>
                            <button onclick="updateRhVisualizations()" style="font-size: 11px; padding: 4px 8px;">Apply</button>
                        </div>
                        
                        <!-- Prime Counting œÄ(x) -->
                        <div class="checkbox-item">
                            <input type="checkbox" id="showPrimeCounting" checked onchange="toggleRhVisualization('primeCountingCanvas')"> Prime Counting œÄ(x)
                        </div>
                        <div id="primeCountingParams" class="gap-input" style="margin-left: 25px; display: block;">
                            œÄ(x) limit: <input type="number" id="primeCountLimit" min="100" value="10000" style="width: 70px;">
                            <button onclick="updateRhVisualizations()" style="font-size: 11px; padding: 4px 8px;">Apply</button>
                        </div>
                        
                        <!-- Residue Heatmap -->
                        <div class="checkbox-item">
                            <input type="checkbox" id="showResidueHeatmap" checked onchange="toggleRhVisualization('residueHeatmapCanvas')"> Residue Heatmap
                        </div>
                        <div id="residueHeatmapParams" class="gap-input" style="margin-left: 25px; display: block;">
                            <em style="font-size: 11px; opacity: 0.8;">Uses active sieve data</em>
                        </div>
                        
                        <!-- Chi-Squared Test -->
                        <div class="checkbox-item">
                            <input type="checkbox" id="showChiSquared" checked onchange="toggleRhVisualization('chiSquaredCanvas')"> Chi-Squared Test
                        </div>
                        <div id="chiSquaredParams" class="gap-input" style="margin-left: 25px; display: block;">
                            Significance: <select id="chiSquaredSignificance" onchange="updateRhVisualizations()" style="width: 80px; font-size: 11px;">
                                <option value="0.05" selected>p=0.05</option>
                                <option value="0.01">p=0.01</option>
                                <option value="0.10">p=0.10</option>
                            </select>
                        </div>
                        
                        <!-- Modulus Comparison -->
                        <div class="checkbox-item">
                            <input type="checkbox" id="showModulusComparison" checked onchange="toggleRhVisualization('modulusComparisonCanvas')"> Modulus Comparison
                        </div>
                        <div id="modulusComparisonParams" class="gap-input" style="margin-left: 25px; display: block;">
                            Display: <select id="modulusComparisonMode" onchange="updateRhVisualizations()" style="width: 120px; font-size: 11px;">
                                <option value="phi" selected>Euler œÜ(M)</option>
                                <option value="density">Density œÜ(M)/M</option>
                                <option value="both">Both</option>
                            </select>
                        </div>
                        
                        <!-- L-Function Magnitude -->
                        <div class="checkbox-item">
                            <input type="checkbox" id="showLFunction" checked onchange="toggleRhVisualization('lFunctionCanvas')"> L-Function Magnitude
                        </div>
                        <div id="lFunctionParams" class="gap-input" style="margin-left: 25px; display: block; background: rgba(255,215,0,0.1); padding: 10px; border-radius: 6px; margin-top: 5px;">
                            <strong style="font-size: 12px; color: #FFD700;">L-Function Parameters:</strong><br>
                            
                            <!-- L-function Type Selection -->
                            <div style="margin: 8px 0;">
                                Type: <select id="lFunctionType" onchange="updateLFunctionParams()" style="width: 140px; font-size: 11px;">
                                    <option value="dirichlet" selected>Dirichlet L(s,œá)</option>
                                    <option value="riemann">Riemann Œ∂(s)</option>
                                    <option value="hasse-weil">Hasse-Weil L(E,s)</option>
                                </select>
                            </div>
                            
                            <!-- Dirichlet Parameters -->
                            <div id="dirichletParams" style="margin: 8px 0;">
                                Character œá mod: <input type="number" id="lFunctionModulus" min="2" value="30" style="width: 50px;">
                                index: <input type="number" id="lFunctionCharIndex" min="0" value="0" style="width: 40px;">
                            </div>
                            
                            <!-- Hasse-Weil Parameters (hidden by default) -->
                            <div id="hasseWeilParams" style="margin: 8px 0; display: none;">
                                Elliptic Curve: <select id="ellipticCurveChoice" style="width: 100px; font-size: 11px;">
                                    <option value="11a">11a (rank 0)</option>
                                    <option value="37a">37a (rank 1)</option>
                                    <option value="389a">389a (rank 2)</option>
                                </select>
                            </div>
                            
                            <!-- Evaluation Parameters -->
                            <div style="margin: 8px 0;">
                                Critical line œÉ=1/2, t: <input type="number" id="lFunctionTMin" min="0" value="0" style="width: 45px;"> to 
                                <input type="number" id="lFunctionTMax" min="1" value="30" style="width: 45px;">
                            </div>
                            
                            <!-- Computation Settings -->
                            <div style="margin: 8px 0;">
                                <label style="font-size: 11px;"><input type="checkbox" id="lFunctionShowEulerProduct"> Show Euler product</label><br>
                                <label style="font-size: 11px;"><input type="checkbox" id="lFunctionShowFunctionalEq"> Show functional equation</label>
                            </div>
                            
                            <!-- Series Terms Control -->
                            <div style="margin: 8px 0;">
                                Dirichlet series terms: <input type="number" id="lFunctionSeriesTerms" min="100" max="50000" value="5000" style="width: 60px;">
                                <br><em style="font-size: 10px; opacity: 0.8;">More terms = better accuracy, slower computation</em>
                            </div>
                            
                            <!-- Precision Display -->
                            <div style="margin: 8px 0;">
                                <label style="font-size: 11px;"><input type="checkbox" id="lFunctionShowErrorBounds" checked> Display error bounds</label>
                            </div>
                            
                            <button onclick="updateRhVisualizations()" style="font-size: 11px; padding: 4px 8px; background: linear-gradient(45deg, #FFD700, #FFA500); color: #000; font-weight: bold;">
                                Compute L-function
                            </button>
                            
                            <div style="margin-top: 8px; font-size: 10px; opacity: 0.85; line-height: 1.4;">
                                <strong>Current:</strong> <span id="lFunctionCurrentDesc">L(s,œá‚ÇÄ) with œá‚ÇÄ mod 30 (principal character)</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="custom-gap" style="background: linear-gradient(45deg, rgba(138, 43, 226, 0.15), rgba(255, 215, 0, 0.15)); border: 2px solid rgba(138, 43, 226, 0.4);">
                        <label><strong>Conjecture Testing Dashboard:</strong></label>
                        
                        <div class="slider-group">
                            <label>Select Conjecture:</label>
                            <select id="conjectureSelect" onchange="updateConjectureParams()">
                                <option value="grh">GRH Uniformity</option>
                                <option value="hardy-littlewood">Hardy-Littlewood k-Tuples</option>
                                <option value="goldbach">Goldbach Conjecture</option>
                                <option value="polignac">Polignac's Conjecture</option>
                                <option value="prime-race">Prime Number Races</option>
                                <option value="andrica">Andrica's Conjecture</option>
                                <option value="firoozbakht">Firoozbakht's Conjecture</option>
                                <option value="legendre">Legendre's Conjecture</option>
                                <option value="cramer">Cram√©r's Conjecture</option>
                            </select>
                        </div>
                        
                        <div id="conjectureParams" style="margin: 10px 0;">
                            <div class="gap-input">
                                Test Range: <input type="number" id="conjectureMin" min="2" value="2" style="width: 70px;">
                                to <input type="number" id="conjectureMax" min="3" value="100000" style="width: 80px;">
                            </div>
                            <div id="extraParams" style="margin-top: 8px;">
                                <!-- Dynamic parameters based on selected conjecture -->
                            </div>
                        </div>
                        
                        <div class="gap-input">
                            <button class="rh-btn" onclick="runConjectureTest()">Run Test</button>
                            <button onclick="viewTestHistory()">View History</button>
                            <button onclick="exportCertificate()">Export Certificate</button>
                        </div>
                        
                        <div id="conjectureResults" style="display: none; margin-top: 15px; padding: 15px; background: rgba(138, 43, 226, 0.1); border-radius: 8px; border: 2px solid rgba(138, 43, 226, 0.3);">
                            <strong>Test Results:</strong>
                            <div id="conjectureResultsContent" style="font-size: 12px; margin-top: 10px;"></div>
                        </div>
                        
                        <div style="font-size: 11px; opacity: 0.85; margin-top: 10px; padding: 8px; background: rgba(138, 43, 226, 0.1); border-radius: 4px;">
                            <strong>About Conjecture Testing:</strong><br>
                            Automatically verify famous unsolved problems up to computational limits. 
                            Tests generate verification certificates with evidence strength and statistical analysis.
                        </div>
                    </div>
                    
                    <div class="custom-gap">
                        <label><strong>GRH Test Parameters:</strong></label>
                        <div class="gap-input">
                            Test modulus: <input type="number" id="grhModulus" min="2" value="30" placeholder="30">
                            <button class="rh-btn" onclick="runGrhAnalysis()">Test GRH</button>
                        </div>
                        <div class="gap-input">
                            <button class="rh-btn" onclick="validateCharacterSupport()">Validate œá Support</button>
                            <button class="rh-btn" onclick="testPrimeEquidistribution()">Test Prime Distribution</button>
                        </div>
                        <div id="rhPredictions" style="font-size: 12px; margin: 10px 0; opacity: 0.9;"></div>
                    </div>
                    

                    
                    <div class="custom-gap">
                        <label><strong>Visualization Range Controls:</strong></label>
                        <div class="gap-input">
                            Critical Line t-range: <input type="number" id="criticalTMin" min="0" value="0" style="width: 60px;"> to 
                            <input type="number" id="criticalTMax" min="1" value="50" style="width: 60px;">
                        </div>
                        <div class="gap-input">
                            Zeta Zeros Count: <input type="number" id="zetaZerosCount" min="1" max="50" value="10" style="width: 60px;">
                            <label style="font-size: 11px; opacity: 0.8;">(first N zeros)</label>
                        </div>
                        <div class="gap-input">
                            œÄ(x) limit: <input type="number" id="primeCountLimit" min="100" value="10000" style="width: 80px;">
                        </div>
                        <div class="gap-input">
                            <button class="rh-btn" onclick="applyVisualizationRanges()">Apply Ranges</button>
                            <button onclick="resetVisualizationRanges()">Reset Defaults</button>
                        </div>
                    </div>
                    
                    <div class="custom-gap">
                        <label><strong>Prime Sieve Engine:</strong></label>
                        <div class="gap-input">
                            Search up to: <input type="number" id="sieveLimit" min="100" value="10000" placeholder="10000">
                        </div>
                        <div class="gap-input">
                            Using modulus: <input type="number" id="sieveModulus" min="2" value="30" placeholder="30">
                            <button class="rh-btn" onclick="runPrimeSieve()">Generate Sieve</button>
                        </div>
                        <div class="gap-input">
                            <button onclick="clearPrimeSieve()">Clear Sieve</button>
                            <button onclick="exportPrimeData()">Export Data</button>
                        </div>
                        <div id="sieveProgress" style="display: none; margin-top: 10px;">
                            <div style="background: rgba(255,255,255,0.2); border-radius: 10px; height: 20px;">
                                <div id="progressBar" style="background: linear-gradient(45deg, #4ECDC4, #44A08D); height: 100%; border-radius: 10px; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="progressText" style="text-align: center; margin-top: 5px; font-size: 12px;"></div>
                        </div>
                        
                        <div id="sieveResults" style="display: none; margin-top: 15px;">
                            <label><strong>Prime Distribution Analysis:</strong></label>
                            <div id="primeStats" style="font-size: 13px; margin: 10px 0;"></div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="showPrimeMarkers"> Highlight Primes on Rings
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="showCompositeMarkers"> Show Composite Numbers
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="showPrimeDensity"> Show Density Visualization
                            </div>
                        </div>
                        
                        <div id="primePatternAnalysis" style="display: none; margin-top: 15px;">
                            <label><strong>Quick Sieve Presets:</strong></label>
                            <div class="gap-input">
                                <button onclick="quickSieve(1000, 6)">1K (mod 6)</button>
                                <button onclick="quickSieve(10000, 30)">10K (mod 30)</button>
                            </div>
                            <div class="gap-input">
                                <button onclick="quickSieve(100000, 210)">100K (mod 210)</button>
                                <button onclick="quickSieve(1000000, 2310)">1M (mod 2310)</button>
                            </div>
                            
                            <div style="margin-top: 15px;">
                                <label><strong>Complete Distribution:</strong></label>
                                <div id="residueDistribution" style="font-size: 12px; max-height: 400px; overflow-y: auto; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-top: 10px;"></div>
                                
                                <div class="gap-input" style="margin-top: 15px;">
                                    <button onclick="exportDetailedPrimeList()">Export All Primes</button>
                                    <button onclick="togglePrimeSearchMode()">Search Primes</button>
                                </div>
                                
                                <div id="primeSearchControls" style="display: none; margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                    <label><strong>Prime Search:</strong></label>
                                    <div class="gap-input">
                                        Prime: <input type="number" id="searchPrime" min="2" max="1000000" placeholder="Enter prime">
                                        <button onclick="findPrimeInResidue()">Find Residue</button>
                                    </div>
                                    <div id="searchResult" style="margin-top: 10px; font-size: 13px;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="custom-gap">
                        <label><strong>Ring Radius Scaling:</strong></label>
                        <div class="slider-group">
                            <label>Scaling Function:</label>
                            <select id="radiusScaling" onchange="updateRadiusScaling()">
                                <option value="uniform" selected>Uniform Spacing (default)</option>
                                <option value="linear">Linear: r(m) = c¬∑m</option>
                                <option value="sqrt">Square-root: r(m) = c¬∑‚àöm</option>
                                <option value="log">Logarithmic: r(m) = c¬∑log(m+1)</option>
                                <option value="totient">Totient: r(m) = c¬∑œÜ(m)</option>
                                <option value="density">Density: r(m) = c¬∑œÜ(m)/m</option>
                                <option value="inverse">Inverse: r(m) = c/m</option>
                                <option value="exponential">Exponential: r(m) = c¬∑a·µê</option>
                            </select>
                        </div>
                        
                        <div class="slider-group">
                            <label>Scaling Constant c: <span id="scalingConstValue">1.0</span></label>
                            <input type="range" id="scalingConst" min="0.1" max="5" step="0.1" value="1.0" oninput="updateScalingConst()">
                        </div>
                        
                        <div class="slider-group" id="expBaseGroup" style="display: none;">
                            <label>Exponential Base a: <span id="expBaseValue">1.15</span></label>
                            <input type="range" id="expBase" min="1.01" max="1.5" step="0.01" value="1.15" oninput="updateExpBase()">
                        </div>
                        
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                            <strong>Mathematical Interpretation:</strong><br>
                            <span id="scalingDescription">
                                Uniform spacing places rings at equal intervals regardless of modulus value.
                            </span>
                        </div>
                        
                        <div class="gap-input" style="margin-top: 10px;">
                            <button onclick="showRadiusComparison()">Compare Scalings</button>
                            <button onclick="resetRadiusScaling()">Reset to Uniform</button>
                        </div>
                    </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3 onclick="toggleSection('gapSection')" style="cursor: pointer; user-select: none;">
                        <span class="collapse-icon collapsed" id="gapSectionIcon">‚ñº</span>
                        Gap Analysis
                    </h3>
                    <div id="gapSection" class="collapsible-section collapsed">
                    <div class="checkbox-group" id="gapControls">
                        <!-- All gaps unchecked by default -->
                    </div>
                    
                    <div class="custom-gap">
                        <label><strong>Dynamic Gap Generation:</strong></label>
                        <div class="gap-input">
                            Max Gap: <input type="number" id="maxGap" min="2" step="2" value="12" placeholder="12">
                        </div>
                        <div class="gap-input">
                            <strong>Add Consecutive Range:</strong><br>
                            From: <input type="number" id="gapStart" min="2" step="1" value="14" placeholder="14">
                            To: <input type="number" id="gapEnd" min="3" step="1" value="20" placeholder="20">
                            <button onclick="addConsecutiveGaps()">Add Range</button>
                        </div>
                        <div class="gap-input">
                            <button onclick="generateGaps()">Generate Even Gaps</button>
                            <button class="reset-btn" onclick="clearAllGaps()">Clear All Gaps</button>
                        </div>
                    </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3 onclick="toggleSection('ringSection')" style="cursor: pointer; user-select: none;">
                        <span class="collapse-icon collapsed" id="ringSectionIcon">‚ñº</span>
                        Modular Ring System
                    </h3>
                    <div id="ringSection" class="collapsible-section collapsed">
                    <div class="checkbox-group" id="ringControls">
                        <!-- Generated by JavaScript -->
                    </div>
                    
                    <div class="custom-gap">
                        <label><strong>Custom Modulus Explorer:</strong></label>
                        <div class="gap-input">
                            Single: <input type="number" id="customMod" min="2" value="42" placeholder="42">
                            <button onclick="addCustomRing()">Add Single</button>
                        </div>
                        <div class="gap-input">
                            <strong>Add Consecutive Range:</strong><br>
                            From: <input type="number" id="modStart" min="1" value="1" placeholder="1">
                            To: <input type="number" id="modEnd" min="2" value="20" placeholder="20">
                            <button onclick="addConsecutiveMods()">Add M‚ÇÅ to M‚Çô</button>
                        </div>
                        <div style="font-size: 0.85em; opacity: 0.8; margin-top: 8px;">
                            No limits - explore any modulus range you want!
                        </div>
                        <div class="gap-input" style="margin-top: 15px;">
                            <button class="reset-btn" onclick="clearAllRings()">Clear All Rings</button>
                            <button class="special-btn" onclick="resetToDefaults()">Reset to M1-M30</button>
                        </div>
                    </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3 onclick="toggleSection('visualSection')" style="cursor: pointer; user-select: none;">
                        <span class="collapse-icon collapsed" id="visualSectionIcon">‚ñº</span>
                        Visual Customization
                    </h3>
                    <div id="visualSection" class="collapsible-section collapsed">
                    
                    <div class="custom-gap">
                        <label><strong>Color Palette Presets:</strong></label>
                        <div class="color-palette-selector">
                            <div class="palette-option rainbow active" onclick="applyPalette('rainbow')" title="Rainbow"></div>
                            <div class="palette-option ocean" onclick="applyPalette('ocean')" title="Ocean"></div>
                            <div class="palette-option sunset" onclick="applyPalette('sunset')" title="Sunset"></div>
                            <div class="palette-option matrix" onclick="applyPalette('matrix')" title="Matrix"></div>
                            <div class="palette-option fire" onclick="applyPalette('fire')" title="Fire"></div>
                            <div class="palette-option ice" onclick="applyPalette('ice')" title="Ice"></div>
                            <div class="palette-option purple" onclick="applyPalette('purple')" title="Purple"></div>
                            <div class="palette-option earth" onclick="applyPalette('earth')" title="Earth"></div>
                        </div>
                    </div>
                    
                    <div class="slider-group">
                        <label>Residue Coloring Scheme:</label>
                        <select id="residueColorMode" onchange="updateColorMode()">
                            <option value="hue" selected>Rainbow by Angular Position</option>
                            <option value="value">By Residue Value</option>
                            <option value="modulo">By Ring (Modulus)</option>
                            <option value="prime">Prime vs Composite</option>
                            <option value="gcd_unified">GCD=1: Unified Color (Character Support)</option>
                            <option value="gcd_per_mod">GCD=1: Unique Color per Modulus</option>
                            <option value="gcd_per_residue">GCD=1: Unique Color per Residue Value</option>
                            <option value="gcd_mathematical">GCD=1: Mathematical Progression</option>
                            <option value="gcd_spectrum">GCD=1: Spectral Distribution</option>
                            <option value="custom">Custom Single Color</option>
                        </select>
                    </div>
                    <div class="slider-group" id="customColorGroup" style="display: none;">
                        <label>Custom Residue Color:</label>
                        <input type="color" id="customResidueColor" value="#FF6B6B" onchange="draw()">
                    </div>
                    
                    <div class="slider-group" id="gcdColorGroup" style="display: none;">
                        <label>Base GCD=1 Color:</label>
                        <input type="color" id="gcdBaseColor" value="#FF6B6B" onchange="draw()">
                    </div>
                    
                    <div class="slider-group" id="nonGcdColorGroup" style="display: none;">
                        <label>Non-GCD=1 Color (if any):</label>
                        <input type="color" id="nonGcdColor" value="#666666" onchange="draw()">
                    </div>
                    
                    <div class="slider-group">
                        <label>Direct Lift Line Color:</label>
                        <input type="color" id="liftLineColor" value="#FFD700" onchange="draw()">
                    </div>
                    
                    <div class="slider-group">
                        <label>Modular Lift Line Color:</label>
                        <input type="color" id="modularLiftColor" value="#FF6384" onchange="draw()">
                    </div>
                    
                    <div class="slider-group">
                        <label>Lift Line Thickness: <span id="thicknessValue">0.5</span></label>
                        <input type="range" id="lineThickness" min="0" max="1" step="0.01" value="0.5" oninput="updateThickness()">
                    </div>
                    
                    <div class="slider-group">
                        <label>Gap Line Thickness: <span id="gapThicknessValue">0.3</span></label>
                        <input type="range" id="gapLineThickness" min="0" max="1" step="0.01" value="0.3" oninput="updateGapThickness()">
                    </div>
                    
                    <div class="slider-group">
                        <label>Ring Circle Thickness: <span id="ringThicknessValue">0.2</span></label>
                        <input type="range" id="ringThickness" min="0" max="1" step="0.01" value="0.2" oninput="updateRingThickness()">
                    </div>
                    
                    <div class="slider-group">
                        <label>Unit Circle Thickness: <span id="unitThicknessValue">0.8</span></label>
                        <input type="range" id="unitThickness" min="0" max="1" step="0.01" value="0.8" oninput="updateUnitThickness()">
                    </div>
                    
                    <div class="slider-group">
                        <label>Residue Point Size: <span id="pointSizeValue">0.4</span></label>
                        <input type="range" id="pointSize" min="0" max="1" step="0.01" value="0.4" oninput="updatePointSize()">
                    </div>
                    
                    <div class="slider-group">
                        <label>Point Border Thickness: <span id="pointBorderValue">0.3</span></label>
                        <input type="range" id="pointBorder" min="0" max="1" step="0.01" value="0.3" oninput="updatePointBorder()">
                    </div>
                    </div>
                </div>

                <div class="control-section" style="background: linear-gradient(45deg, rgba(78, 205, 196, 0.15), rgba(138, 43, 226, 0.15)); border: 2px solid rgba(78, 205, 196, 0.4);">
                    <h3 onclick="toggleSection('smithChartSection')" style="cursor: pointer; user-select: none; color: #4ECDC4;">
                        <span class="collapse-icon collapsed" id="smithChartSectionIcon">‚ñº</span>
                        Smith Chart Transform (Cayley Map)
                    </h3>
                    <div id="smithChartSection" class="collapsible-section collapsed">
                    <div class="custom-gap">
                        <div class="checkbox-item">
                            <input type="checkbox" id="enableSmithChart" onchange="toggleSmithChart()"> Enable Smith Chart Transform
                        </div>
                        
                        <div id="smithChartControls" style="display: none; margin-top: 15px;">
                            <div class="slider-group">
                                <label>Global Phase Shift Œ±: <span id="smithAlphaValue">90</span>¬∞</label>
                                <input type="range" id="smithAlpha" min="0" max="360" step="1" value="90" oninput="updateSmithChart()">
                            </div>
                            
                            <div class="slider-group">
                                <label>Radius Scaling Mode:</label>
                                <select id="smithRadiusMode" onchange="updateSmithChart()">
                                    <option value="unit">Unit Radius (R=1)</option>
                                    <option value="scaled" selected>Scaled by Index</option>
                                    <option value="modulus">By Modulus Value</option>
                                    <option value="custom">Custom Scaling</option>
                                </select>
                            </div>
                            
                            <div class="slider-group" id="smithCustomScaleGroup" style="display: none;">
                                <label>Custom Radius Scale: <span id="smithScaleValue">1.0</span></label>
                                <input type="range" id="smithScale" min="0.1" max="5" step="0.1" value="1.0" oninput="updateSmithScale()">
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="smithShowGrid" checked onchange="draw()"> Show Smith Grid
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="smithShowCircles" checked onchange="draw()"> Show Constant-R Circles
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="smithShowArcs" checked onchange="draw()"> Show Constant-X Arcs
                            </div>
                            
                            <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px; padding: 10px; background: rgba(78, 205, 196, 0.1); border-radius: 6px; border-left: 3px solid #4ECDC4;">
                                <strong>Cayley/Smith Transform:</strong><br>
                                Œì = (z - 1)/(z + 1)<br><br>
                                ‚Ä¢ Maps z = R¬∑e^(iŒ∏) ‚Üí unit disk<br>
                                ‚Ä¢ Œ∏ = 2œÄr/M + Œ± (residue angle)<br>
                                ‚Ä¢ R=1: pure imaginary axis<br>
                                ‚Ä¢ R>1: Smith chart arcs<br>
                                ‚Ä¢ Conformal mapping preserves angles<br><br>
                                <strong>Real part:</strong><br>
                                Re(Œì) = (AC + B¬≤)/(C¬≤ + B¬≤)<br>
                                A = R¬∑cos(Œ∏) - 1, B = R¬∑sin(Œ∏)<br>
                                C = R¬∑cos(Œ∏) + 1<br><br>
                                <strong>Imaginary part:</strong><br>
                                Im(Œì) = B(C - A)/(C¬≤ + B¬≤)<br><br>
                                Special case (R=1):<br>
                                Œì(Œ∏) = i¬∑tan(Œ∏/2)
                            </div>
                        </div>
                    </div>
                    </div>
                </div>
                
                <div class="control-section" style="background: linear-gradient(45deg, rgba(78, 205, 196, 0.15), rgba(138, 43, 226, 0.15)); border: 2px solid rgba(78, 205, 196, 0.4);">
                    <h3 onclick="toggleSection('rotation3dSection')" style="cursor: pointer; user-select: none; color: #4ECDC4;">
                        <span class="collapse-icon collapsed" id="rotation3dSectionIcon">‚ñº</span>
                        3D Rotation Panel
                    </h3>
                    <div id="rotation3dSection" class="collapsible-section collapsed">
                    <div class="custom-gap">
                        <label><strong>Select Ring to Rotate:</strong></label>
                        <select id="rotation3dRingSelector" onchange="update3DRotationRing()" style="width: 100%; padding: 8px; border-radius: 6px; margin-bottom: 10px;">
                            <option value="all">All Rings (Global Rotation)</option>
                        </select>
                        
                        <div class="slider-group">
                            <label>X-Axis Rotation: <span id="rotationXValue">0</span>¬∞</label>
                            <input type="range" id="rotationX" min="0" max="360" step="1" value="0" oninput="update3DRotation()">
                        </div>
                        
                        <div class="slider-group">
                            <label>Y-Axis Rotation: <span id="rotationYValue">0</span>¬∞</label>
                            <input type="range" id="rotationY" min="0" max="360" step="1" value="0" oninput="update3DRotation()">
                        </div>
                        
                        <div class="slider-group">
                            <label>Z-Axis Rotation: <span id="rotationZValue">0</span>¬∞</label>
                            <input type="range" id="rotationZ" min="0" max="360" step="1" value="0" oninput="update3DRotation()">
                        </div>
                        
                        <div class="checkbox-item">
                            <input type="checkbox" id="enable3DPerspective" onchange="update3DRotation()"> Enable Perspective Projection
                        </div>
                        
                        <div class="gap-input" style="margin-top: 15px;">
                            <button onclick="reset3DRotation()" style="background: #e74c3c;">Reset Rotation</button>
                            <button onclick="apply3DToAll()" style="background: #9b59b6;">Apply to All</button>
                        </div>
                        
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px; padding: 10px; background: rgba(78, 205, 196, 0.1); border-radius: 6px; border-left: 3px solid #4ECDC4;">
                            <strong>3D Rotation:</strong><br>
                            ‚Ä¢ X-axis: Pitch (tilt forward/backward)<br>
                            ‚Ä¢ Y-axis: Yaw (turn left/right)<br>
                            ‚Ä¢ Z-axis: Roll (rotate clockwise/counter-clockwise)<br>
                            ‚Ä¢ All visual elements rotate together<br>
                            ‚Ä¢ Each ring can have independent rotation
                        </div>
                    </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3 onclick="toggleSection('animationSection')" style="cursor: pointer; user-select: none;">
                        <span class="collapse-icon collapsed" id="animationSectionIcon">‚ñº</span>
                        Advanced Animation Engine
                    </h3>
                    <div id="animationSection" class="collapsible-section collapsed">
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableRotation" onchange="toggleRotation()"> Enable Individual Ring Rotation
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableColorInvert" onchange="toggleColorInvert()"> Invert Colors (Dark/Light Mode)
                    </div>
                    <div class="slider-group">
                        <label>Global Animation Speed: <span id="globalSpeedValue">1.0</span>x</label>
                        <input type="range" id="globalSpeed" min="0.1" max="8" step="0.1" value="1" oninput="updateGlobalSpeed()">
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="reverseDirection"> Reverse Rotation Direction
                    </div>
                    
                    <div class="custom-gap">
                        <label><strong>Ring Nesting Animation:</strong></label>
                        <div class="checkbox-item">
                            <input type="checkbox" id="enableNestingAnimation"> Enable Nesting Inversion
                        </div>
                        
                        <div id="nestingAnimationControls" style="display: none; margin-top: 10px;">
                            <div class="slider-group">
                                <label>Nesting Inversion: <span id="nestingInversionValue">0.0</span></label>
                                <input type="range" id="nestingInversion" min="0" max="1" step="0.01" value="0" oninput="updateNestingInversion()">
                            </div>
                            
                            <div class="slider-group">
                                <label>Animation Speed: <span id="nestingSpeedValue">1.0</span>x</label>
                                <input type="range" id="nestingSpeed" min="0.1" max="5" step="0.1" value="1.0" oninput="updateNestingSpeed()">
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="nestingLoop" checked> Loop Animation
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="nestingPingPong"> Ping-Pong (reverse direction)
                            </div>
                            
                            <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                <strong>Gradual Position Exchange:</strong><br>
                                ‚Ä¢ 0.0 = Normal order (M1 inner, M30 outer)<br>
                                ‚Ä¢ 0.5 = Rings crossing midpoint<br>
                                ‚Ä¢ 1.0 = Inverted (M30 inner, M1 outer)<br>
                                ‚Ä¢ Each ring smoothly trades positions
                            </div>
                            
                            <div class="gap-input" style="margin-top: 10px;">
                                <button onclick="startNestingAnimation()">Start Animation</button>
                                <button onclick="stopNestingAnimation()">Stop</button>
                                <button onclick="resetNestingOrder()">Reset</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="custom-gap">
                        <label><strong>Ring Inversion Animation:</strong></label>
                        <div class="checkbox-item">
                            <input type="checkbox" id="enableInversion" onchange="toggleInversionAnimation()"> Enable Ring Inversion
                        </div>
                        <div id="inversionControls" style="display: none;">
                            <div class="slider-group">
                                <label>Inversion Wave Speed: <span id="inversionSpeedValue">1.0</span>x</label>
                                <input type="range" id="inversionSpeed" min="0.1" max="5" step="0.1" value="1" oninput="updateInversionSpeed()">
                            </div>
                            <div class="slider-group">
                                <label>Inversion Wave Intensity: <span id="inversionIntensityValue">1.0</span>x</label>
                                <input type="range" id="inversionIntensity" min="0.1" max="3.0" step="0.1" value="1.0" oninput="updateInversionIntensity()">
                            </div>
                            <div class="slider-group">
                                <label>Inversion Pattern:</label>
                                <select id="inversionPattern" onchange="draw()">
                                    <option value="wave">Mathematical Wave</option>
                                    <option value="spiral">Spiral Transform</option>
                                    <option value="pulse">Radial Pulse</option>
                                    <option value="twist">Ring Twist</option>
                                </select>
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="inversionLoop" checked> Loop Inversion Continuously
                            </div>
                            <button onclick="stopInversionAnimation()">Stop Inversion</button>
                        </div>
                    </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3 onclick="toggleSection('labelSection')" style="cursor: pointer; user-select: none;">
                        <span class="collapse-icon collapsed" id="labelSectionIcon">‚ñº</span>
                        Label Controls
                    </h3>
                    <div id="labelSection" class="collapsible-section collapsed">
                    <div class="checkbox-item">
                        <input type="checkbox" id="showLabels"> Show Residue Labels
                    </div>
                    
                    <div class="custom-gap" id="labelControls">
                        <label><strong>Label Format:</strong></label>
                        <div class="slider-group">
                            <select id="labelFormat" onchange="updateLabelFormat()">
                                <option value="number" selected>Number (r)</option>
                                <option value="fraction">Fraction (r/M)</option>
                                <option value="farey">Farey Sequence (r/M simplified)</option>
                                <option value="angle">Angle (Œ∏ = 2œÄr/M)</option>
                                <option value="gcd">GCD Value gcd(r,M)</option>
                                <option value="coprime">Coprime Status (‚úì/‚úó)</option>
                                <option value="combined">Combined (r, gcd, Œ∏)</option>
                            </select>
                        </div>
                        
                        <label><strong>Selective Labeling:</strong></label>
                        <div class="checkbox-item">
                            <input type="checkbox" id="labelUnitCircle" checked> Label Unit Circle
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="labelGcdOne" checked> Label GCD=1 Residues
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="labelNonGcdOne"> Label GCD‚â†1 Residues
                        </div>
                        
                        <label><strong>GCD-Specific Labels:</strong></label>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showGcdValue"> Show gcd(r,M) value
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showCoprimeIndicator"> Show ‚úì/‚úó coprime indicator
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showTotientPosition"> Show position in œÜ(M) sequence
                        </div>
                        
                        <div class="gap-input">
                            <strong>Label Specific Moduli:</strong><br>
                            Moduli: <input type="text" id="labelSpecificMods" placeholder="2,3,5,30" style="width: 120px;">
                            <button onclick="updateSpecificLabels()">Apply</button>
                        </div>
                        
                        <div class="gap-input">
                            <strong>Label Consecutive Range:</strong><br>
                            From M: <input type="number" id="labelModStart" min="1" value="1" style="width: 60px;">
                            To M: <input type="number" id="labelModEnd" min="1" value="10" style="width: 60px;">
                            <button onclick="updateLabelRange()">Apply Range</button>
                        </div>
                        
                        <div class="gap-input">
                            Min Ring Radius: <input type="number" id="labelMinRadius" min="0" value="80" placeholder="80">
                            <button onclick="draw()">Update</button>
                        </div>
                        
                        <div class="slider-group">
                            <label>Label Size: <span id="labelSizeValue">1.0</span>x</label>
                            <input type="range" id="labelSize" min="0.3" max="3.0" step="0.1" value="1.0" oninput="updateLabelSize()">
                        </div>
                        
                        <div class="slider-group">
                            <label>Label Opacity: <span id="labelOpacityValue">0.95</span></label>
                            <input type="range" id="labelOpacity" min="0.1" max="1.0" step="0.05" value="0.95" oninput="updateLabelOpacity()">
                        </div>
                        
                        <div class="checkbox-item">
                            <input type="checkbox" id="labelShowPrimeCounts" checked> Show Prime Counts (when sieve active)
                        </div>
                    </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3 onclick="toggleSection('gcdAnalysisSection')" style="cursor: pointer; user-select: none;">
                        <span class="collapse-icon collapsed" id="gcdAnalysisSectionIcon">‚ñº</span>
                        GCD Analysis & Visualization
                    </h3>
                    <div id="gcdAnalysisSection" class="collapsible-section collapsed">
                    <div class="custom-gap">
                        <label><strong>GCD Visual Analysis Mode:</strong></label>
                        <div class="checkbox-item">
                            <input type="checkbox" id="highlightGcdBoundary" onchange="draw()"> Highlight GCD=1 boundary
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showGcdConnections" onchange="draw()"> Show GCD structure connections
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="animateGcdHighlight" onchange="toggleGcdAnimation()"> Animate GCD=1 residues
                        </div>
                    </div>
                    
                    <div class="custom-gap">
                        <label><strong>GCD Information Display:</strong></label>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showTotientCount" onchange="draw()"> Show œÜ(M) count per ring
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showGcdDistribution" onchange="draw()"> Show GCD distribution chart
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="compareTotientDensity" onchange="draw()"> Compare totient densities
                        </div>
                    </div>
                    
                    <div class="custom-gap">
                        <label><strong>GCD Research Tools:</strong></label>
                        <div class="gap-input">
                            <button onclick="analyzeGcdPatterns()">Analyze GCD Patterns</button>
                            <button onclick="exportGcdData()">Export GCD Data</button>
                        </div>
                        <div class="gap-input">
                            <button onclick="visualizeFareySequence()">Show Farey Sequence</button>
                            <button onclick="testCoprimalityTheorems()">Test Coprimality Theorems</button>
                        </div>
                    </div>
                    
                    <div id="gcdAnalysisResults" style="display: none; margin-top: 15px; padding: 15px; background: rgba(72, 187, 120, 0.1); border-radius: 8px; border: 2px solid rgba(72, 187, 120, 0.3);">
                        <label><strong>GCD Analysis Results:</strong></label>
                        <div id="gcdResultsContent" style="font-size: 13px; margin-top: 10px;"></div>
                    </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3 onclick="toggleSection('liftSection')" style="cursor: pointer; user-select: none;">
                        <span class="collapse-icon collapsed" id="liftSectionIcon">‚ñº</span>
                        Lift Controls
                    </h3>
                    <div id="liftSection" class="collapsible-section collapsed">
                    <div class="checkbox-item">
                        <input type="checkbox" id="showDirectLifts" checked> Direct Lifts (r ‚Üí r, consecutive only)
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showModularLifts"> Modular Lifts (r ‚Üí r + M√ó2‚Åø, consecutive only)
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showSkipDirectLifts"> Skip-Level Direct Lifts (r ‚Üí r, all combinations)
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showSkipModularLifts"> Skip-Level Modular Lifts (r ‚Üí r + M√ó2‚Åø, all combinations)
                    </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3 onclick="toggleSection('displaySection')" style="cursor: pointer; user-select: none;">
                        <span class="collapse-icon collapsed" id="displaySectionIcon">‚ñº</span>
                        Display Controls
                    </h3>
                    <div id="displaySection" class="collapsible-section collapsed">
                    <div class="checkbox-item">
                        <input type="checkbox" id="showUnitCircle" checked> Highlight Unit Circle
                    </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3 onclick="toggleSection('characterSection')" style="cursor: pointer; user-select: none;">
                        <span class="collapse-icon collapsed" id="characterSectionIcon">‚ñº</span>
                        Dirichlet Character Controls
                    </h3>
                    <div id="characterSection" class="collapsible-section collapsed">
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="showGcdOne" checked onchange="draw()"> Show œá(r) ‚â† 0 (Character Support)
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showNonGcdOne" onchange="draw()"> Show œá(r) = 0 (Character Vanishing)
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="highlightGcdDifference" onchange="draw()"> Highlight Character Support Difference
                        </div>
                    </div>
                    
                    <div class="custom-gap">
                        <label><strong>Character Visualization:</strong></label>
                        <div class="slider-group">
                            <label>œá(r)=0 Opacity: <span id="nonGcdOpacityValue">0.3</span></label>
                            <input type="range" id="nonGcdOpacity" min="0" max="1" step="0.05" value="0.3" oninput="updateNonGcdOpacity()">
                        </div>
                        <div class="slider-group">
                            <label>œá(r)=0 Color:</label>
                            <input type="color" id="nonGcdColor" value="#666666" onchange="draw()">
                        </div>
                        <div style="font-size: 0.85em; opacity: 0.8; margin-top: 8px;">
                            <strong>Mathematical Note:</strong> gcd(r,M) = 1 ‚ü∫ œá(r) ‚â† 0<br>
                            Character support determines L-function behavior
                        </div>
                    </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <button class="reset-btn" onclick="resetAll()">Reset All Settings</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="canvas" width="1000" height="750"></canvas>
                <div class="animation-status" id="animationStatus">Ready</div>
            </div>
            
            <!-- View Controls moved here -->
            <div class="control-section" style="margin-top: 20px;">
                <h3 onclick="toggleSection('viewSectionMain')" style="cursor: pointer; user-select: none;">
                    <span class="collapse-icon" id="viewSectionMainIcon">‚ñº</span>
                    View Controls
                </h3>
                <div id="viewSectionMain" class="collapsible-section">
                <div class="slider-group">
                    <label>Zoom Level: <span id="zoomValue">1.0</span>x</label>
                    <input type="range" id="zoomSlider" min="0.1" max="10" step="0.1" value="1" oninput="updateZoom()">
                </div>
                <div class="slider-group">
                    <label>Manual Rotation: <span id="rotationValue">0¬∞</span></label>
                    <input type="range" id="rotationSlider" min="0" max="360" step="1" value="0" oninput="updateRotation()">
                </div>
                <div class="gap-input">
                    <button onclick="resetView()">Reset View</button>
                    <button onclick="captureImage()">Capture Image</button>
                    <button onclick="invertCanvas()">Invert Nest Order</button>
                </div>
                <div class="custom-gap">
                    <label><strong>Image Capture Options:</strong></label>
                    <div class="checkbox-item">
                        <input type="radio" name="screenshotResolution" value="standard"> Standard
                    </div>
                    <div class="checkbox-item">
                        <input type="radio" name="screenshotResolution" value="4k" checked> 4K
                    </div>
                    <div class="checkbox-item">
                        <input type="radio" name="screenshotBg" value="black" checked> Black Background
                    </div>
                    <div class="checkbox-item">
                        <input type="radio" name="screenshotBg" value="white"> White Background
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="includeTitle" checked> Include Title & Subtitle
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="includeLegend" checked> Include Legend
                    </div>
                </div>
                
                <div class="custom-gap">
                    <label><strong>Animation Export Options:</strong></label>
                    <div class="checkbox-item">
                        <input type="radio" name="animationFormat" value="webm" checked> WebM (High Quality)
                    </div>
                    <div class="checkbox-item">
                        <input type="radio" name="animationFormat" value="mp4"> MP4 (Compatible)
                    </div>
                    <div class="checkbox-item">
                        <input type="radio" name="animationFormat" value="gif"> GIF (Optimized)
                    </div>
                    <div class="slider-group">
                        <label>Animation Duration: <span id="animDurationValue">5</span> seconds</label>
                        <input type="range" id="animDuration" min="2" max="30" step="1" value="5" oninput="updateAnimDuration()">
                    </div>
                    <div class="slider-group">
                        <label>Export FPS: <span id="animFpsValue">30</span></label>
                        <input type="range" id="animFps" min="15" max="60" step="5" value="30" oninput="updateAnimFps()">
                    </div>
                    <div class="slider-group">
                        <label>Export Resolution:</label>
                        <select id="animResolution">
                            <option value="1080p">1080p (1920√ó1080)</option>
                            <option value="1440p">1440p (2560√ó1440)</option>
                            <option value="4k" selected>4K (3840√ó2160)</option>
                            <option value="custom">Custom Size</option>
                        </select>
                    </div>
                    <div class="gap-input" id="customResolutionControls" style="display: none;">
                        Width: <input type="number" id="customWidth" value="3840" min="480" step="16">
                        Height: <input type="number" id="customHeight" value="2160" min="480" step="16">
                    </div>
                    <div class="gap-input" style="margin-top: 15px;">
                        <button onclick="startRecording()" id="recordButton">Record Animation</button>
                        <button onclick="stopRecording()">Stop Recording</button>
                    </div>
                </div>
                <div style="font-size: 0.85em; opacity: 0.8; margin-top: 8px;">
                    <strong>Navigation:</strong><br>
                    ‚Ä¢ Click & drag to pan<br>
                    ‚Ä¢ Mouse wheel to zoom<br>
                    ‚Ä¢ Double-click to reset center
                </div>
                </div>
            </div>
            
            <!-- Dedicated RH Visualization Section -->
            <div class="rh-visualization-section">
                <h3>Riemann Hypothesis Visual Analysis</h3>
                
                <!-- Zero-Residue Alignment Panel (if active) -->
                <div id="zeroAlignmentPanel" style="display: none; background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(72, 187, 120, 0.15)); border: 2px solid rgba(255, 215, 0, 0.4); border-radius: 15px; padding: 20px; margin-bottom: 20px;">
                    <h3 style="color: #FFD700; text-align: center; margin-bottom: 15px;">Zero-Residue Alignment Diagnostics</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <canvas id="primePhaseCanvas" width="400" height="300" style="background: #000; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3);"></canvas>
                            <div class="rh-visual-title">Prime-Phase Field P_t(M,r)</div>
                            <div class="rh-visual-desc">Complex vectors at each residue</div>
                        </div>
                        <div>
                            <canvas id="coherenceGraphCanvas" width="400" height="300" style="background: #000; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3);"></canvas>
                            <div class="rh-visual-title">Coherence Score C_t vs t</div>
                            <div class="rh-visual-desc">Peaks indicate zero heights</div>
                        </div>
                    </div>
                </div>
                
                <div class="rh-visual-grid">
                    <div class="critical-line-display">
                        <canvas id="criticalLineCanvas" width="400" height="300"></canvas>
                        <div class="rh-visual-title">Critical Line Analysis</div>
                        <div class="rh-visual-desc">Re(s) = 1/2 visualization for L(s,œá)</div>
                    </div>
                    
                    <div class="character-support-display">
                        <canvas id="characterCanvas" width="400" height="300"></canvas>
                        <div class="rh-visual-title">Character Support Domains</div>
                        <div class="rh-visual-desc">œá(r) ‚â† 0 regions across moduli</div>
                    </div>
                    
                    <div class="prime-distribution-display">
                        <canvas id="primeDistCanvas" width="400" height="300"></canvas>
                        <div class="rh-visual-title">Prime Equidistribution</div>
                        <div class="rh-visual-desc">GRH uniformity predictions</div>
                    </div>
                    
                    <div class="prime-distribution-display">
                        <canvas id="fareyDiscrepancyCanvas" width="400" height="300"></canvas>
                        <div class="rh-visual-title">Farey Discrepancy</div>
                        <div class="rh-visual-desc">Franel-Landau RH equivalence</div>
                    </div>
                    
                    <div class="prime-distribution-display">
                        <canvas id="franelLandauCanvas" width="400" height="300"></canvas>
                        <div class="rh-visual-title">Franel-Landau Test</div>
                        <div class="rh-visual-desc">D(N) = O(N^(1/2+Œµ)) verification</div>
                    </div>
                    
                    <div class="prime-distribution-display">
                        <canvas id="zetaZerosCanvas" width="400" height="300"></canvas>
                        <div class="rh-visual-title">Zeta Function Zeros</div>
                        <div class="rh-visual-desc">First non-trivial zeros on critical line</div>
                    </div>
                    
                    <div class="prime-distribution-display">
                        <canvas id="primeCountingCanvas" width="400" height="300"></canvas>
                        <div class="rh-visual-title">Prime Counting Function œÄ(x)</div>
                        <div class="rh-visual-desc">œÄ(x) vs Li(x) comparison</div>
                    </div>
                    
                    <div class="prime-distribution-display">
                        <canvas id="residueHeatmapCanvas" width="400" height="300"></canvas>
                        <div class="rh-visual-title">Residue Class Heatmap</div>
                        <div class="rh-visual-desc">Prime density visualization</div>
                    </div>
                    
                    <div class="prime-distribution-display">
                        <canvas id="chiSquaredCanvas" width="400" height="300"></canvas>
                        <div class="rh-visual-title">Chi-Squared Test</div>
                        <div class="rh-visual-desc">Uniformity statistical test</div>
                    </div>
                    
                    <div class="prime-distribution-display">
                        <canvas id="modulusComparisonCanvas" width="400" height="300"></canvas>
                        <div class="rh-visual-title">Multi-Modulus Comparison</div>
                        <div class="rh-visual-desc">œÜ(M) across selected rings</div>
                    </div>
                    
                    <div class="prime-distribution-display">
                        <canvas id="lFunctionCanvas" width="400" height="300"></canvas>
                        <div class="rh-visual-title">L-Function Magnitude |L(s,œá)|</div>
                        <div class="rh-visual-desc">Along critical line approximation</div>
                    </div>
                </div>
                
                <div class="rh-research-controls">
                    <button class="rh-btn" onclick="updateRhVisualizations()">Update RH Analysis</button>
                    <button class="rh-btn" onclick="exportRhData()">Export Research Data</button>
                    <button class="rh-btn" onclick="runFullGrhSuite()">Run Complete GRH Suite</button>
                    <button class="rh-btn" onclick="animateZetaZeros()">Animate Zeros</button>
                </div>
            </div>
        </div>
        
        <div class="analysis-section">
            <h3 onclick="toggleAnalysisSection()">
                <span class="collapse-icon" id="analysisCollapseIcon">‚ñº</span>
                Mathematical Analysis
            </h3>
            <div id="ringInfo" class="collapsible-content">Select rings to view detailed analysis</div>
        </div>

        <div class="legend">
            <h3 onclick="toggleLegendSection()" style="cursor: pointer; user-select: none; display: flex; align-items: center; justify-content: space-between;">
                <span style="display: flex; align-items: center; gap: 10px;">
                    <span class="collapse-icon" id="legendCollapseIcon">‚ñº</span>
                    Complete Legend & Guide
                </span>
            </h3>
            <div id="legendContent" class="collapsible-content">
                <div class="legend-grid">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FFD700;"></div>
                        <div>
                            <strong>Unit Circle (M=1)</strong><br>
                            Mathematical foundation where gcd(0,1)=1. Contains single residue 0. The fundamental building block of the modular ring system.
                        </div>
                    </div>
                    
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(45deg, #FF6B6B, #4ECDC4);"></div>
                        <div>
                            <strong>Residue Points (Modular Classes)</strong><br>
                            Each colored point represents a residue class <span class="math-notation">r (mod M)</span>. Colors indicate coprimality with the modulus: gcd(r,M)=1 residues (Euler totient) are shown with full opacity.
                        </div>
                    </div>
                    
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FFD700;"></div>
                        <div>
                            <strong>Direct Lift Lines (Golden)</strong><br>
                            Ring homomorphisms œÜ: Z/M‚ÇÅZ ‚Üí Z/M‚ÇÇZ where œÜ(r) = r. These preserve residue structure and show mathematical relationships between different moduli.
                        </div>
                    </div>
                    
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF6384;"></div>
                        <div>
                            <strong>Modular Lift Lines (Pink)</strong><br>
                            Chinese Remainder Theorem transformations: r ‚Ü¶ r + M√ó2‚Åø. Shows how residues map to shifted positions in larger moduli.
                        </div>
                    </div>
                    
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #4ECDC4, #FF6B6B, #FFD700);"></div>
                        <div>
                            <strong>Prime Gap Connections</strong><br>
                            Links between primes separated by specific gaps: <strong>Gap 2</strong> (Twin Primes), <strong>Gap 4</strong> (Cousin Primes), <strong>Gap 6</strong> (Sexy Primes). Tests Hardy-Littlewood conjectures.
                        </div>
                    </div>
                    
                    <div class="legend-item">
                        <div class="legend-color" style="background: #48BB78;"></div>
                        <div>
                            <strong>Dirichlet Character Support (œá(r) ‚â† 0)</strong><br>
                            Residues where gcd(r,M)=1. These form the domain where Dirichlet characters are non-zero, essential for L-function analysis and the Generalized Riemann Hypothesis.
                        </div>
                    </div>
                    
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(102, 102, 102, 0.3);"></div>
                        <div>
                            <strong>Character Vanishing (œá(r) = 0)</strong><br>
                            Residues where gcd(r,M)‚â†1. These points appear dimmed as Dirichlet characters vanish here, excluding them from L-function calculations.
                        </div>
                    </div>
                    
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(45deg, #667eea, #764ba2);"></div>
                        <div>
                            <strong>Color Schemes Available</strong><br>
                            <strong>Rainbow:</strong> By angular position Œ∏=2œÄr/M<br>
                            <strong>GCD Modes:</strong> Highlight character support domains<br>
                            <strong>Prime Analysis:</strong> Distinguish prime vs composite residues<br>
                            <strong>Mathematical:</strong> Based on œÜ(M) density and totient ordering
                        </div>
                    </div>
                    
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9b59b6;"></div>
                        <div>
                            <strong>Riemann Hypothesis Connections</strong><br>
                            GRH predicts uniform prime distribution in coprime residue classes. The visualization tests these predictions through prime sieves and equidistribution analysis at Re(s)=1/2.
                        </div>
                    </div>
                    
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e67e22;"></div>
                        <div>
                            <strong>Prime Sieve Analysis</strong><br>
                            When active, highlights prime distribution across residue classes. Golden rings mark classes containing primes, with size indicating density. Tests uniformity predictions.
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 30px; padding: 20px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.1);">
                    <h4 style="color: #FFD700; margin-bottom: 15px;">Mathematical Foundations</h4>
                    <div style="font-size: 14px; line-height: 1.8;">
                        <p><strong>Euler's Totient Function:</strong> <span class="math-notation">œÜ(n) = n‚àè<sub>p|n</sub>(1 - 1/p)</span> counts residues coprime to n</p>
                        <p><strong>Character Support:</strong> <span class="math-notation">gcd(r,M) = 1 ‚ü∫ œá(r) ‚â† 0</span> defines L-function domains</p>
                        <p><strong>Ring Isomorphism:</strong> <span class="math-notation">Z/nZ ‚âÖ (Z/nZ)*</span> for coprime residues</p>
                        <p><strong>Angle Formula:</strong> <span class="math-notation">Œ∏ = 2œÄ(M-r)/M</span> positions residues correctly</p>
                        <p><strong>GRH Prediction:</strong> Primes distribute uniformly across œÜ(M) coprime classes</p>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding: 20px; background: linear-gradient(45deg, rgba(255, 215, 0, 0.1), rgba(72, 187, 120, 0.1)); border-radius: 10px; border: 2px solid rgba(255, 215, 0, 0.3);">
                    <h4 style="color: #FFD700; margin-bottom: 15px;">Research & Development</h4>
                    <div style="font-size: 14px; line-height: 1.8;">
                        <p><strong>Created by:</strong> Wessen Getachew</p>
                        <p><strong>Twitter:</strong> <a href="https://twitter.com/7dView" target="_blank" style="color: #4ECDC4; text-decoration: none;">@7dView</a></p>
                        <p><strong>Email:</strong> <a href="mailto:getachewwessen@gmail.com" style="color: #4ECDC4; text-decoration: none;">getachewwessen@gmail.com</a></p>
                        <p style="margin-top: 10px; font-style: italic; opacity: 0.9;">This interactive visualization explores connections between modular arithmetic, prime distribution, and the Riemann Hypothesis through geometric representation of algebraic structures.</p>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.1);">
                    <h4 style="color: #a0aec0; margin-bottom: 10px; font-size: 14px;">Quick Start Guide</h4>
                    <div style="font-size: 13px; line-height: 1.7; opacity: 0.9;">
                        <p><strong>1. Select Rings:</strong> Check moduli M‚ÇÅ-M‚ÇÜ‚ÇÄ or add custom values. Unit circle is the foundation.</p>
                        <p><strong>2. Choose Gaps:</strong> Enable gap 2, 4, or 6 to see twin, cousin, or sexy prime patterns.</p>
                        <p><strong>3. Adjust Colors:</strong> Try different color schemes to highlight GCD=1 residues or prime classes.</p>
                        <p><strong>4. Run Prime Sieve:</strong> Generate primes up to 10K+ and analyze distribution uniformity.</p>
                        <p><strong>5. Enable Animation:</strong> Watch rings rotate and use inversion patterns for dynamic visualization.</p>
                        <p><strong>6. Test RH Predictions:</strong> Use the GRH analysis tools to test equidistribution hypotheses.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // RH visualization range state
        let rhVisualizationRanges = {
            criticalTMin: 0,
            criticalTMax: 50,
            zetaZerosCount: 10,
            primeCountLimit: 10000
        };
        
        function applyVisualizationRanges() {
            rhVisualizationRanges.criticalTMin = parseFloat(document.getElementById('criticalTMin').value) || 0;
            rhVisualizationRanges.criticalTMax = parseFloat(document.getElementById('criticalTMax').value) || 50;
            rhVisualizationRanges.zetaZerosCount = parseInt(document.getElementById('zetaZerosCount').value) || 10;
            rhVisualizationRanges.primeCountLimit = parseInt(document.getElementById('primeCountLimit').value) || 10000;
            
            updateRhVisualizations();
            updateAnimationStatus('RH visualization ranges updated');
        }
        
        function resetVisualizationRanges() {
            document.getElementById('criticalTMin').value = 0;
            document.getElementById('criticalTMax').value = 50;
            document.getElementById('zetaZerosCount').value = 10;
            document.getElementById('primeCountLimit').value = 10000;
            applyVisualizationRanges();
        }
        
        function updateFareyDiscrepancyVisualization() {
            const canvas = document.getElementById('fareyDiscrepancyCanvas');
            if (!canvas || !document.getElementById('showFareyVisualization')?.checked) {
                if (canvas) canvas.parentElement.style.display = 'none';
                return;
            }
            
            canvas.parentElement.style.display = 'block';
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!fareyData.isActive) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Generate Farey Sequence', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const L_N = fareyData.L_N;
            const xScale = (canvas.width - 60) / L_N;
            const maxDiscrepancy = Math.max.apply(Math, fareyData.sequence.map(function(f, i) {
                return Math.abs(f.value - (i + 1) / L_N);
            }));
            const yScale = (canvas.height - 60) / (maxDiscrepancy * 1.2);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(40, 10);
            ctx.lineTo(40, canvas.height - 40);
            ctx.lineTo(canvas.width - 10, canvas.height - 40);
            ctx.stroke();
            
            ctx.fillStyle = '#4ECDC4';
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 1;
            
            fareyData.sequence.forEach(function(f, i) {
                const x = 40 + (i + 1) * xScale;
                const fareyY = canvas.height - 40 - f.value * (canvas.height - 60);
                const uniformY = canvas.height - 40 - ((i + 1) / L_N) * (canvas.height - 60);
                
                ctx.fillStyle = '#4ECDC4';
                ctx.beginPath();
                ctx.arc(x, fareyY, 2, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(x, uniformY, 2, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
                ctx.beginPath();
                ctx.moveTo(x, fareyY);
                ctx.lineTo(x, uniformY);
                ctx.stroke();
            });
            
            ctx.fillStyle = '#4ECDC4';
            ctx.font = '11px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('Farey F_N', 50, 25);
            
            ctx.fillStyle = '#FFD700';
            ctx.fillText('Uniform U_N', 120, 25);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('D(' + fareyData.N + ') = ' + fareyData.discrepancy.toFixed(4), canvas.width / 2, canvas.height - 10);
        }
        
        function updateFranelLandauVisualization() {
            const canvas = document.getElementById('franelLandauCanvas');
            if (!canvas || !document.getElementById('showFranelLandau')?.checked) {
                if (canvas) canvas.parentElement.style.display = 'none';
                return;
            }
            
            canvas.parentElement.style.display = 'block';
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!fareyData.isActive) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Generate Farey Sequence', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const testValues = [5, 10, 15, 20, 30, 50, 75, 100, 150, 200, 300, 500];
            const results = [];
            
            testValues.forEach(function(N) {
                if (N <= 500) {
                    const farey = [];
                    for (var q = 1; q <= N; q++) {
                        for (var a = 0; a <= q; a++) {
                            if (gcd(a, q) === 1) {
                                farey.push(a / q);
                            }
                        }
                    }
                    
                    const uniqueFarey = Array.from(new Set(farey)).sort(function(a, b) { return a - b; });
                    const L = uniqueFarey.length;
                    
                    var D = 0;
                    for (var j = 0; j < L; j++) {
                        D += Math.abs(uniqueFarey[j] - (j + 1) / L);
                    }
                    
                    results.push({ N: N, D: D, rhBound: Math.pow(N, 0.5 + 0.1) });
                }
            });
            
            const maxN = Math.max.apply(Math, results.map(function(r) { return r.N; }));
            const maxY = Math.max.apply(Math, results.map(function(r) { return Math.max(r.D, r.rhBound); }));
            const xScale = (canvas.width - 60) / maxN;
            const yScale = (canvas.height - 60) / maxY;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(40, 10);
            ctx.lineTo(40, canvas.height - 40);
            ctx.lineTo(canvas.width - 10, canvas.height - 40);
            ctx.stroke();
            
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            results.forEach(function(r, i) {
                const x = 40 + r.N * xScale;
                const y = canvas.height - 40 - r.rhBound * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#4ECDC4';
            ctx.strokeStyle = '#4ECDC4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            results.forEach(function(r, i) {
                const x = 40 + r.N * xScale;
                const y = canvas.height - 40 - r.D * yScale;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                
                ctx.fillRect(x - 2, y - 2, 4, 4);
            });
            ctx.stroke();
            
            ctx.fillStyle = '#FFD700';
            ctx.font = '11px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('O(N^(1/2+Œµ)) bound', 50, 20);
            
            ctx.fillStyle = '#4ECDC4';
            ctx.fillText('Actual D(N)', 50, 35);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('Franel-Landau: D(N) vs RH Bound', canvas.width / 2, canvas.height - 10);
            
            const allSatisfy = results.every(function(r) { return r.D < r.rhBound; });
            ctx.fillStyle = allSatisfy ? '#4ECDC4' : '#FF6B6B';
            ctx.font = '10px Segoe UI';
            ctx.fillText(allSatisfy ? '‚úì All points satisfy RH bound' : '‚ö† Some points exceed bound', canvas.width - 100, 20);
        }
        
        // ========================================
        // END FAREY & FRANEL-LANDAU FUNCTIONS
        // ========================================
        
        // Conjecture testing state
        let conjectureTestHistory = [];
        let currentConjecture = 'grh';
        
        function updateConjectureParams() {
            currentConjecture = document.getElementById('conjectureSelect').value;
            const extraParams = document.getElementById('extraParams');
            
            const paramConfigs = {
                'hardy-littlewood': '<div class="gap-input">k-tuple size: <input type="number" id="kTupleSize" min="2" max="10" value="3" style="width: 50px;"> Max gap: <input type="number" id="maxTupleGap" min="2" value="6" style="width: 50px;"></div>',
                'goldbach': '<div style="font-size: 11px; margin-top: 5px;"><em>Tests all even numbers in range</em></div>',
                'polignac': '<div class="gap-input">Test gaps: <input type="text" id="polignacGaps" value="2,4,6,8,10" placeholder="2,4,6" style="width: 100px;"></div>',
                'prime-race': '<div class="gap-input">Modulus: <input type="number" id="raceModulus" min="3" value="4" style="width: 50px;"> <em>(Compare residue classes)</em></div>',
                'andrica': '<div style="font-size: 11px; margin-top: 5px;"><em>Tests ‚àö(p_{n+1}) - ‚àö(p_n) < 1</em></div>',
                'firoozbakht': '<div style="font-size: 11px; margin-top: 5px;"><em>Tests p_n^(1/n) strictly decreasing</em></div>',
                'legendre': '<div style="font-size: 11px; margin-top: 5px;"><em>Tests prime exists between n¬≤ and (n+1)¬≤</em></div>',
                'cramer': '<div style="font-size: 11px; margin-top: 5px;"><em>Tests gap/(ln p)¬≤ < 1</em></div>',
                'grh': '<div style="font-size: 11px; margin-top: 5px;"><em>Tests prime distribution uniformity</em></div>'
            };
            
            extraParams.innerHTML = paramConfigs[currentConjecture] || '';
        }
        
        function runConjectureTest() {
            const conjecture = document.getElementById('conjectureSelect').value;
            const min = parseInt(document.getElementById('conjectureMin').value);
            const max = parseInt(document.getElementById('conjectureMax').value);
            
            if (max - min < 10) {
                alert('Range too small. Please use at least 10 numbers.');
                return;
            }
            
            updateAnimationStatus('Running ' + conjecture + ' test...');
            
            setTimeout(() => {
                let result;
                
                switch(conjecture) {
                    case 'andrica':
                        result = testAndricaConjecture(min, max);
                        break;
                    case 'prime-race':
                        result = testPrimeRace(min, max);
                        break;
                    case 'hardy-littlewood':
                        result = testHardyLittlewoodKTuples(min, max);
                        break;
                    case 'goldbach':
                        result = testGoldbachConjecture(min, max);
                        break;
                    case 'polignac':
                        result = testPolignacConjecture(min, max);
                        break;
                    case 'firoozbakht':
                        result = testFiroozbakhtConjecture(min, max);
                        break;
                    case 'legendre':
                        result = testLegendreConjecture(min, max);
                        break;
                    case 'cramer':
                        result = testCramerConjecture(min, max);
                        break;
                    case 'grh':
                        result = testGRHUniformity(min, max);
                        break;
                    default:
                        result = { error: 'Unknown conjecture' };
                }
                
                displayConjectureResults(result);
                conjectureTestHistory.push({
                    timestamp: new Date().toISOString(),
                    conjecture: conjecture,
                    range: [min, max],
                    result: result
                });
                
                updateAnimationStatus('Test complete: ' + result.status);
            }, 100);
        }
        
        function testAndricaConjecture(min, max) {
            const primes = sieveOfEratosthenes(max).filter(p => p >= min);
            
            if (primes.length < 2) {
                return { status: 'INSUFFICIENT_DATA', verified: false };
            }
            
            let maxDiff = 0;
            let maxDiffPrimes = [0, 0];
            let allVerified = true;
            
            for (let i = 0; i < primes.length - 1; i++) {
                const diff = Math.sqrt(primes[i + 1]) - Math.sqrt(primes[i]);
                
                if (diff > maxDiff) {
                    maxDiff = diff;
                    maxDiffPrimes = [primes[i], primes[i + 1]];
                }
                
                if (diff >= 1) {
                    allVerified = false;
                    return {
                        status: 'COUNTEREXAMPLE_FOUND',
                        verified: false,
                        counterexample: { p1: primes[i], p2: primes[i + 1], diff: diff },
                        tested: primes.length - 1
                    };
                }
            }
            
            return {
                status: 'VERIFIED',
                verified: true,
                tested: primes.length - 1,
                maxDifference: maxDiff,
                closestCall: maxDiffPrimes,
                margin: 1 - maxDiff,
                confidence: allVerified ? 'STRONG' : 'WEAK'
            };
        }
        
        function testPrimeRace(min, max) {
            const modulus = parseInt(document.getElementById('raceModulus')?.value || 4);
            const primes = sieveOfEratosthenes(max).filter(p => p >= min);
            const coprimes = getCoprimes(modulus);
            
            const counts = {};
            coprimes.forEach(r => counts[r] = 0);
            
            primes.forEach(p => {
                const r = p % modulus;
                if (coprimes.includes(r)) {
                    counts[r]++;
                }
            });
            
            const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
            const leader = sorted[0];
            const runnerUp = sorted[1];
            
            return {
                status: 'ANALYSIS_COMPLETE',
                modulus: modulus,
                tested: primes.length,
                counts: counts,
                leader: { residue: parseInt(leader[0]), count: leader[1] },
                runnerUp: { residue: parseInt(runnerUp[0]), count: runnerUp[1] },
                margin: leader[1] - runnerUp[1],
                bias: leader[1] / primes.length
            };
        }
        
        function testHardyLittlewoodKTuples(min, max) {
            const k = parseInt(document.getElementById('kTupleSize')?.value || 3);
            const maxGap = parseInt(document.getElementById('maxTupleGap')?.value || 6);
            const primes = sieveOfEratosthenes(max).filter(p => p >= min);
            
            const tuples = [];
            
            for (let i = 0; i <= primes.length - k; i++) {
                const candidate = [primes[i]];
                let valid = true;
                
                for (let j = 1; j < k; j++) {
                    if (i + j >= primes.length) {
                        valid = false;
                        break;
                    }
                    
                    const gap = primes[i + j] - primes[i];
                    if (gap > maxGap) {
                        valid = false;
                        break;
                    }
                    candidate.push(primes[i + j]);
                }
                
                if (valid && candidate.length === k) {
                    tuples.push(candidate);
                }
            }
            
            return {
                status: 'TUPLES_FOUND',
                k: k,
                maxGap: maxGap,
                tested: primes.length,
                tuplesFound: tuples.length,
                density: tuples.length / primes.length,
                examples: tuples.slice(0, 10),
                largestTuple: tuples[tuples.length - 1] || []
            };
        }
        
        function testGoldbachConjecture(min, max) {
            const primes = new Set(sieveOfEratosthenes(max));
            const results = [];
            let minPartitions = Infinity;
            let minPartitionsN = 0;
            
            const start = Math.max(4, min % 2 === 0 ? min : min + 1);
            
            for (let n = start; n <= max; n += 2) {
                let partitionCount = 0;
                let firstPartition = null;
                
                for (const p of primes) {
                    if (p > n / 2) break;
                    if (primes.has(n - p)) {
                        if (!firstPartition) firstPartition = [p, n - p];
                        partitionCount++;
                    }
                }
                
                if (partitionCount === 0) {
                    return {
                        status: 'COUNTEREXAMPLE_FOUND',
                        verified: false,
                        counterexample: n,
                        tested: (n - start) / 2 + 1
                    };
                }
                
                if (partitionCount < minPartitions) {
                    minPartitions = partitionCount;
                    minPartitionsN = n;
                }
                
                results.push({ n, partitionCount, firstPartition });
            }
            
            const avgPartitions = results.reduce((sum, r) => sum + r.partitionCount, 0) / results.length;
            
            return {
                status: 'VERIFIED',
                verified: true,
                tested: results.length,
                averagePartitions: avgPartitions,
                minPartitions: { n: minPartitionsN, count: minPartitions },
                confidence: 'STRONG'
            };
        }
        
        function testPolignacConjecture(min, max) {
            const gapsStr = document.getElementById('polignacGaps')?.value || '2,4,6,8,10';
            const testGaps = gapsStr.split(',').map(g => parseInt(g.trim())).filter(g => !isNaN(g) && g > 0);
            const primes = sieveOfEratosthenes(max).filter(p => p >= min);
            
            const gapCounts = {};
            testGaps.forEach(g => gapCounts[g] = 0);
            
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i + 1] - primes[i];
                if (testGaps.includes(gap)) {
                    gapCounts[gap]++;
                }
            }
            
            return {
                status: 'GAPS_ANALYZED',
                tested: primes.length - 1,
                gapsSearched: testGaps,
                gapCounts: gapCounts,
                allFound: testGaps.every(g => gapCounts[g] > 0),
                confidence: 'MODERATE'
            };
        }
        
        function testFiroozbakhtConjecture(min, max) {
            const primes = sieveOfEratosthenes(max).filter(p => p >= min);
            
            if (primes.length < 2) {
                return { status: 'INSUFFICIENT_DATA', verified: false };
            }
            
            for (let i = 1; i < primes.length; i++) {
                const prev = Math.pow(primes[i - 1], 1 / i);
                const curr = Math.pow(primes[i], 1 / (i + 1));
                
                if (curr >= prev) {
                    return {
                        status: 'COUNTEREXAMPLE_FOUND',
                        verified: false,
                        counterexample: { index: i + 1, prime: primes[i], prev: prev, curr: curr },
                        tested: i + 1
                    };
                }
            }
            
            return {
                status: 'VERIFIED',
                verified: true,
                tested: primes.length,
                confidence: 'STRONG'
            };
        }
        
        function testLegendreConjecture(min, max) {
            const sqrtMax = Math.floor(Math.sqrt(max));
            const primes = new Set(sieveOfEratosthenes(max));
            
            const start = Math.max(1, Math.floor(Math.sqrt(min)));
            
            for (let n = start; n <= sqrtMax; n++) {
                const lower = n * n;
                const upper = (n + 1) * (n + 1);
                
                let foundPrime = false;
                for (const p of primes) {
                    if (p > lower && p < upper) {
                        foundPrime = true;
                        break;
                    }
                    if (p >= upper) break;
                }
                
                if (!foundPrime) {
                    return {
                        status: 'COUNTEREXAMPLE_FOUND',
                        verified: false,
                        counterexample: { n: n, range: [lower, upper] },
                        tested: n - start + 1
                    };
                }
            }
            
            return {
                status: 'VERIFIED',
                verified: true,
                tested: sqrtMax - start + 1,
                confidence: 'STRONG'
            };
        }
        
        function testCramerConjecture(min, max) {
            const primes = sieveOfEratosthenes(max).filter(p => p >= min);
            
            if (primes.length < 2) {
                return { status: 'INSUFFICIENT_DATA', verified: false };
            }
            
            let maxRatio = 0;
            let maxRatioPrimes = [0, 0];
            
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i + 1] - primes[i];
                const logSquared = Math.pow(Math.log(primes[i]), 2);
                const ratio = gap / logSquared;
                
                if (ratio > maxRatio) {
                    maxRatio = ratio;
                    maxRatioPrimes = [primes[i], primes[i + 1]];
                }
                
                if (ratio >= 1) {
                    return {
                        status: 'COUNTEREXAMPLE_FOUND',
                        verified: false,
                        counterexample: { p1: primes[i], p2: primes[i + 1], ratio: ratio },
                        tested: i + 1
                    };
                }
            }
            
            return {
                status: 'VERIFIED',
                verified: true,
                tested: primes.length - 1,
                maxRatio: maxRatio,
                closestCall: maxRatioPrimes,
                margin: 1 - maxRatio,
                confidence: 'MODERATE'
            };
        }
        
        function testGRHUniformity(min, max) {
            const modulus = parseInt(document.getElementById('grhModulus')?.value || 30);
            const primes = sieveOfEratosthenes(max).filter(p => p >= min && p > modulus);
            const coprimes = getCoprimes(modulus);
            
            const distribution = {};
            coprimes.forEach(r => distribution[r] = 0);
            
            primes.forEach(p => {
                const r = p % modulus;
                if (coprimes.includes(r)) {
                    distribution[r]++;
                }
            });
            
            const expected = primes.length / coprimes.length;
            let chiSquared = 0;
            
            coprimes.forEach(r => {
                const observed = distribution[r];
                chiSquared += Math.pow(observed - expected, 2) / expected;
            });
            
            const degreesOfFreedom = coprimes.length - 1;
            const uniformityScore = 1 - Math.min(1, chiSquared / (degreesOfFreedom * 2));
            
            return {
                status: 'UNIFORMITY_ANALYZED',
                modulus: modulus,
                tested: primes.length,
                eulerPhi: coprimes.length,
                chiSquared: chiSquared,
                degreesOfFreedom: degreesOfFreedom,
                uniformityScore: uniformityScore,
                isUniform: uniformityScore > 0.85,
                grhSupport: uniformityScore > 0.9 ? 'STRONG' : uniformityScore > 0.8 ? 'MODERATE' : 'WEAK'
            };
        }
        
        function displayConjectureResults(result) {
            const resultsDiv = document.getElementById('conjectureResults');
            const contentDiv = document.getElementById('conjectureResultsContent');
            
            resultsDiv.style.display = 'block';
            
            let html = '<div style="padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px;">';
            html += '<strong style="font-size: 14px;">' + result.status.replace(/_/g, ' ') + '</strong><br><br>';
            
            if (result.verified === true) {
                html += '<span style="color: #4ECDC4; font-size: 13px;">VERIFIED (no counterexamples)</span><br>';
            } else if (result.verified === false) {
                html += '<span style="color: #FF6B6B; font-size: 13px;">COUNTEREXAMPLE FOUND</span><br>';
            }
            
            html += '<br><strong>Details:</strong><br>';
            
            Object.keys(result).forEach(key => {
                if (key === 'status' || key === 'verified') return;
                
                let value = result[key];
                if (typeof value === 'number') {
                    value = value < 1 ? value.toFixed(6) : value.toLocaleString();
                } else if (typeof value === 'object' && value !== null) {
                    value = JSON.stringify(value, null, 2).replace(/\n/g, '<br>').replace(/ /g, '&nbsp;');
                }
                
                html += key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()) + ': ' + value + '<br>';
            });
            
            html += '</div>';
            
            contentDiv.innerHTML = html;
        }
        
        function viewTestHistory() {
            if (conjectureTestHistory.length === 0) {
                alert('No test history available. Run some tests first.');
                return;
            }
            
            let html = 'TEST HISTORY:\n\n';
            conjectureTestHistory.slice(-10).reverse().forEach((test, i) => {
                html += `${i + 1}. ${test.conjecture} [${test.range[0]}-${test.range[1]}]\n`;
                html += `   ${test.timestamp}\n`;
                html += `   Status: ${test.result.status}\n\n`;
            });
            
            alert(html);
        }
        
        function exportCertificate() {
            if (conjectureTestHistory.length === 0) {
                alert('No test results to export. Run a test first.');
                return;
            }
            
            const latest = conjectureTestHistory[conjectureTestHistory.length - 1];
            
            let certificate = 'VERIFICATION CERTIFICATE\n';
            certificate += '='.repeat(60) + '\n\n';
            certificate += `Conjecture: ${latest.conjecture.toUpperCase().replace(/-/g, ' ')}\n`;
            certificate += `Tested: ${latest.timestamp}\n`;
            certificate += `Range: [${latest.range[0]}, ${latest.range[1]}]\n\n`;
            certificate += 'Results:\n';
            certificate += '-'.repeat(60) + '\n';
            
            Object.entries(latest.result).forEach(([key, value]) => {
                certificate += `${key}: ${typeof value === 'object' ? JSON.stringify(value, null, 2) : value}\n`;
            });
            
            certificate += '\n' + '='.repeat(60) + '\n';
            certificate += 'Generated by Riemann Hypothesis Explorer\n';
            certificate += 'Built by Wessen Getachew\n';
            
            const blob = new Blob([certificate], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `conjecture_certificate_${latest.conjecture}_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.txt`;
            link.click();
            URL.revokeObjectURL(url);
            
            updateAnimationStatus('Certificate exported');
        }
        // Smith Chart transform state
        let smithChartEnabled = false;
        let smithAlpha = Math.PI / 2; // 90 degrees by default (north pole)
        let smithRadiusMode = 'scaled';
        let smithCustomScale = 1.0;
        
        function toggleSmithChart() {
            smithChartEnabled = document.getElementById('enableSmithChart').checked;
            const controls = document.getElementById('smithChartControls');
            controls.style.display = smithChartEnabled ? 'block' : 'none';
            
            if (smithChartEnabled) {
                updateAnimationStatus('Smith Chart transform enabled');
            } else {
                updateAnimationStatus('Smith Chart transform disabled');
            }
            
            draw();
        }
        
        function updateSmithChart() {
            const alpha = parseFloat(document.getElementById('smithAlpha').value);
            smithAlpha = alpha * Math.PI / 180;
            document.getElementById('smithAlphaValue').textContent = alpha;
            
            smithRadiusMode = document.getElementById('smithRadiusMode').value;
            
            const customScaleGroup = document.getElementById('smithCustomScaleGroup');
            customScaleGroup.style.display = smithRadiusMode === 'custom' ? 'block' : 'none';
            
            draw();
        }
        
        function updateSmithScale() {
            smithCustomScale = parseFloat(document.getElementById('smithScale').value);
            document.getElementById('smithScaleValue').textContent = smithCustomScale.toFixed(1);
            draw();
        }
        
        // Cayley/M√∂bius transform: Œì = (z - 1)/(z + 1)
        function cayleyTransform(z) {
            // z = {re, im}
            const numeratorRe = z.re - 1;
            const numeratorIm = z.im;
            const denominatorRe = z.re + 1;
            const denominatorIm = z.im;
            
            // Complex division: (a + bi)/(c + di) = [(ac + bd) + i(bc - ad)]/(c¬≤ + d¬≤)
            const denomMagSq = denominatorRe * denominatorRe + denominatorIm * denominatorIm;
            
            if (denomMagSq < 1e-10) {
                // Avoid division by zero
                return {re: 0, im: 0};
            }
            
            const gammaRe = (numeratorRe * denominatorRe + numeratorIm * denominatorIm) / denomMagSq;
            const gammaIm = (numeratorIm * denominatorRe - numeratorRe * denominatorIm) / denomMagSq;
            
            return {re: gammaRe, im: gammaIm};
        }
        
        // Alternative direct formula using trig
        function cayleyTransformDirect(R, theta) {
            const A = R * Math.cos(theta) - 1;
            const B = R * Math.sin(theta);
            const C = R * Math.cos(theta) + 1;
            
            const denominator = C * C + B * B;
            
            if (denominator < 1e-10) {
                return {re: 0, im: 0};
            }
            
            const gammaRe = (A * C + B * B) / denominator;
            const gammaIm = (B * (C - A)) / denominator;
            
            return {re: gammaRe, im: gammaIm};
        }
        
        // Special case for unit radius R=1
        function cayleyTransformUnit(theta) {
            // Œì(Œ∏) = i¬∑tan(Œ∏/2)
            return {re: 0, im: Math.tan(theta / 2)};
        }
        
        // Get Smith chart radius for a ring
        function getSmithRadius(ringIndex, totalRings, modulus) {
            switch(smithRadiusMode) {
                case 'unit':
                    return 1.0;
                case 'scaled':
                    // Scale from 0.5 to 2.0 based on ring index
                    return 0.5 + (ringIndex / Math.max(1, totalRings - 1)) * 1.5;
                case 'modulus':
                    // Use modulus value (normalized)
                    return Math.min(3.0, Math.log(modulus + 1) / Math.log(10));
                case 'custom':
                    return smithCustomScale;
                default:
                    return 1.0;
            }
        }
        
        // Draw Smith chart grid
        function drawSmithChartGrid(maxRadius = 250) {
            if (!document.getElementById('smithShowGrid')?.checked) return;
            
            ctx.save();
            ctx.strokeStyle = 'rgba(100, 150, 200, 0.3)';
            ctx.lineWidth = 0.5;
            
            // Unit circle boundary
            ctx.beginPath();
            ctx.arc(0, 0, maxRadius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Constant-R circles (right half)
            if (document.getElementById('smithShowCircles')?.checked) {
                const rValues = [0.2, 0.5, 1.0, 2.0, 5.0];
                rValues.forEach(r => {
                    // For constant resistance r, circles centered at (r/(1+r), 0) with radius 1/(1+r)
                    const center = r / (1 + r);
                    const radius = 1 / (1 + r);
                    
                    ctx.beginPath();
                    ctx.arc(center * maxRadius, 0, radius * maxRadius, 0, 2 * Math.PI);
                    ctx.strokeStyle = 'rgba(100, 150, 200, 0.25)';
                    ctx.stroke();
                });
            }
            
            // Constant-X arcs (reactance)
            if (document.getElementById('smithShowArcs')?.checked) {
                const xValues = [-2, -1, -0.5, 0.5, 1, 2];
                xValues.forEach(x => {
                    // For constant reactance x, arcs centered at (1, 1/x) with radius 1/|x|
                    if (Math.abs(x) < 0.01) return;
                    
                    const centerY = 1 / x;
                    const radius = 1 / Math.abs(x);
                    
                    ctx.beginPath();
                    ctx.arc(maxRadius, centerY * maxRadius, radius * maxRadius, 
                            x > 0 ? Math.PI : 0, 
                            x > 0 ? 0 : Math.PI, 
                            x > 0);
                    ctx.strokeStyle = 'rgba(150, 100, 200, 0.25)';
                    ctx.stroke();
                });
            }
            
            // Real and imaginary axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-maxRadius, 0);
            ctx.lineTo(maxRadius, 0);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, -maxRadius);
            ctx.lineTo(0, maxRadius);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // 3D Rotation state
        let ring3DRotations = {}; // Store rotation for each ring: {ringId: {x, y, z}}
        let current3DRing = 'all'; // Currently selected ring for rotation
        let global3DRotation = {x: 0, y: 0, z: 0}; // Global rotation for all rings
        let enable3DPerspective = false;
        
        // Initialize 3D rotation panel
        function init3DRotationPanel() {
            const selector = document.getElementById('rotation3dRingSelector');
            selector.innerHTML = '<option value="all">All Rings (Global Rotation)</option>';
            
            const selectedRings = getSelectedRings();
            selectedRings.forEach(ringId => {
                const config = configs[ringId];
                if (config) {
                    const label = ringId === 'unit' ? 'Unit Circle' : `M${config.mod}`;
                    selector.innerHTML += `<option value="${ringId}">${label}</option>`;
                }
            });
        }
        
        function update3DRotationRing() {
            current3DRing = document.getElementById('rotation3dRingSelector').value;
            
            // Load current rotation for selected ring
            let rotation;
            if (current3DRing === 'all') {
                rotation = global3DRotation;
            } else {
                rotation = ring3DRotations[current3DRing] || {x: 0, y: 0, z: 0};
            }
            
            document.getElementById('rotationX').value = rotation.x;
            document.getElementById('rotationY').value = rotation.y;
            document.getElementById('rotationZ').value = rotation.z;
            
            document.getElementById('rotationXValue').textContent = rotation.x;
            document.getElementById('rotationYValue').textContent = rotation.y;
            document.getElementById('rotationZValue').textContent = rotation.z;
        }
        
        function update3DRotation() {
            const x = parseFloat(document.getElementById('rotationX').value);
            const y = parseFloat(document.getElementById('rotationY').value);
            const z = parseFloat(document.getElementById('rotationZ').value);
            
            enable3DPerspective = document.getElementById('enable3DPerspective').checked;
            
            document.getElementById('rotationXValue').textContent = x;
            document.getElementById('rotationYValue').textContent = y;
            document.getElementById('rotationZValue').textContent = z;
            
            // Store rotation for current ring
            if (current3DRing === 'all') {
                global3DRotation = {x, y, z};
            } else {
                ring3DRotations[current3DRing] = {x, y, z};
            }
            
            draw();
        }
        
        function reset3DRotation() {
            document.getElementById('rotationX').value = 0;
            document.getElementById('rotationY').value = 0;
            document.getElementById('rotationZ').value = 0;
            
            document.getElementById('rotationXValue').textContent = '0';
            document.getElementById('rotationYValue').textContent = '0';
            document.getElementById('rotationZValue').textContent = '0';
            
            if (current3DRing === 'all') {
                global3DRotation = {x: 0, y: 0, z: 0};
            } else {
                ring3DRotations[current3DRing] = {x: 0, y: 0, z: 0};
            }
            
            draw();
        }
        
        function apply3DToAll() {
            const x = parseFloat(document.getElementById('rotationX').value);
            const y = parseFloat(document.getElementById('rotationY').value);
            const z = parseFloat(document.getElementById('rotationZ').value);
            
            global3DRotation = {x, y, z};
            
            // Apply to all individual rings too
            const selectedRings = getSelectedRings();
            selectedRings.forEach(ringId => {
                ring3DRotations[ringId] = {x, y, z};
            });
            
            updateAnimationStatus('3D rotation applied to all rings');
            draw();
        }
        
        // Apply 3D rotation matrix to a point
        function apply3DRotationToPoint(x, y, z, rotation) {
            // Convert degrees to radians
            const rx = rotation.x * Math.PI / 180;
            const ry = rotation.y * Math.PI / 180;
            const rz = rotation.z * Math.PI / 180;
            
            // Rotation around X-axis (pitch)
            let y1 = y * Math.cos(rx) - z * Math.sin(rx);
            let z1 = y * Math.sin(rx) + z * Math.cos(rx);
            
            // Rotation around Y-axis (yaw)
            let x2 = x * Math.cos(ry) + z1 * Math.sin(ry);
            let z2 = -x * Math.sin(ry) + z1 * Math.cos(ry);
            
            // Rotation around Z-axis (roll)
            let x3 = x2 * Math.cos(rz) - y1 * Math.sin(rz);
            let y3 = x2 * Math.sin(rz) + y1 * Math.cos(rz);
            
            return {x: x3, y: y3, z: z2};
        }
        
        // Get 3D rotation for a specific ring
        function get3DRotationForRing(ringId) {
            // Check if ring has individual rotation
            if (ring3DRotations[ringId]) {
                return ring3DRotations[ringId];
            }
            // Otherwise use global rotation
            return global3DRotation;
        }
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let animating = false;
        let animationFrame = 0;
        let customRingCounter = 1000;
        let isInverting = false;
        let inversionProgress = 0;
        let ringRotationSpeeds = {};
        let specificLabelMods = new Set();
        let inversionIntensity = 1.0;
        let currentLabelFormat = 'number';
        let gcdAnimationPhase = 0;
        let gcdAnimationActive = false;
        
        // Coordinate system state
        let coordinateSystem = 'polar';
        let coordSystemParams = {
            logCylinder: { uScale: 1.0, vScale: 1.0 },
            spiral: { growth: 0.3, tightness: 0.5 },
            hyperbolic: { curvature: 1.0 },
            rectangular: { cellSize: 50, arrangement: 'totient' },
            treemap: { algorithm: 'squarify', padding: 2 },
            voronoi: { jitter: 0.1 },
            fractal: { depth: 3, branching: 4 }
        };
        
        // Enhanced multi-point distance measurement state
        let distanceMeasurementActive = false;
        let measurementPoints = [];
        let distanceMode = 'euclidean';
        let pathType = 'sequential';
        
        // Farey sequence state
        let fareyData = {
            N: 30,
            sequence: [],
            discrepancy: 0,
            isActive: false
        };
        
        function toggleGcdAnimation() {
            gcdAnimationActive = document.getElementById('animateGcdHighlight').checked;
            
            if (gcdAnimationActive) {
                updateAnimationStatus('GCD animation enabled');
                if (!animating) {
                    animating = true;
                    animate();
                }
            } else {
                updateAnimationStatus('GCD animation disabled');
            }
        }
        
        // Ring radius scaling state
        let radiusScalingMode = 'uniform';
        let scalingConstant = 1.0;
        let exponentialBase = 1.15;
        
        // Nesting animation state
        let nestingInversionAmount = 0;
        let nestingAnimationActive = false;
        let nestingAnimationSpeed = 1.0;
        let nestingAnimationProgress = 0;
        let nestingAnimationDirection = 1;
        
        // Interactive features state
        let currentTheme = 'dark';
        let currentPalette = 'rainbow';
        let hoveredResidue = null;
        let selectedResidue = null;
        let showKeyboardShortcuts = false;
        let colorInverted = false;
        
        // Color palettes
        const colorPalettes = {
            rainbow: (angle) => `hsl(${angle * 360}, 75%, 65%)`,
            ocean: (angle) => `hsl(${180 + angle * 60}, 70%, 55%)`,
            sunset: (angle) => `hsl(${angle * 60}, 100%, 60%)`,
            matrix: (angle) => `hsl(${120 + angle * 30}, 100%, ${40 + angle * 30}%)`,
            fire: (angle) => `hsl(${angle * 60}, 100%, ${50 + angle * 20}%)`,
            ice: (angle) => `hsl(${180 + angle * 60}, 60%, ${60 + angle * 30}%)`,
            purple: (angle) => `hsl(${270 + angle * 60}, 70%, 60%)`,
            earth: (angle) => `hsl(${30 + angle * 30}, 60%, 50%)`
        };
        
        // Animation recording state
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let recordingCanvas = null;
        let recordingStream = null;
        let recordingStartTime = 0;
        let frameCount = 0;
        
        // Pan and zoom state
        let panX = 0;
        let panY = 0;
        let currentZoom = 1;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartPanX = 0;
        let dragStartPanY = 0;
        
        // Prime sieve data storage
        let primeData = {
            primes: [],
            modulus: null,
            limit: null,
            residueDistribution: {},
            totalPrimes: 0,
            isActive: false
        };

        // Zero-Residue Alignment Diagnostics state
        let zeroAlignmentActive = false;
        let alignmentT = 14.134; // First zero
        let alignmentX = 1000; // Prime cutoff
        let tSweepActive = false;
        let tSweepSpeed = 1.0;
        let primePhaseCache = {}; // Cache computed P_t(M,r) values
        
        function toggleZeroAlignment() {
            zeroAlignmentActive = document.getElementById('enableZeroAlignment').checked;
            const controls = document.getElementById('zeroAlignmentControls');
            const panel = document.getElementById('zeroAlignmentPanel');
            
            controls.style.display = zeroAlignmentActive ? 'block' : 'none';
            panel.style.display = zeroAlignmentActive ? 'block' : 'none';
            
            if (zeroAlignmentActive) {
                updateZeroAlignment();
                updateAnimationStatus('Zero-Residue Alignment Diagnostics enabled');
            } else {
                updateAnimationStatus('Alignment diagnostics disabled');
                draw();
            }
        }
        
        function updateAlignmentT() {
            alignmentT = parseFloat(document.getElementById('alignmentT').value);
            document.getElementById('alignmentTValue').textContent = alignmentT.toFixed(3);
            primePhaseCache = {}; // Invalidate cache
            updateZeroAlignment();
        }
        
        function updateAlignmentX() {
            alignmentX = parseInt(document.getElementById('alignmentX').value);
            document.getElementById('alignmentXValue').textContent = alignmentX;
            primePhaseCache = {}; // Invalidate cache
            updateZeroAlignment();
        }
        
        function updateTSweepSpeed() {
            tSweepSpeed = parseFloat(document.getElementById('tSweepSpeed').value);
            document.getElementById('tSweepSpeedValue').textContent = tSweepSpeed.toFixed(1);
        }
        
        function toggleTSweep() {
            tSweepActive = document.getElementById('enableTSweep').checked;
            const controls = document.getElementById('tSweepControls');
            controls.style.display = tSweepActive ? 'block' : 'none';
            
            if (tSweepActive) {
                updateAnimationStatus('t-Sweep animation enabled');
                if (!animating) {
                    animating = true;
                    animate();
                }
            } else {
                updateAnimationStatus('t-Sweep animation disabled');
            }
        }
        
        // Diagnostic A: Compute Prime-Phase Field P_t(M,r)
        function computePrimePhaseField(M, r, t, X) {
            const cacheKey = `${M}_${r}_${t.toFixed(3)}_${X}`;
            if (primePhaseCache[cacheKey]) {
                return primePhaseCache[cacheKey];
            }
            
            const primes = sieveOfEratosthenes(X);
            let sumReal = 0;
            let sumImag = 0;
            
            primes.forEach(p => {
                if (p % M === r) {
                    const weight = Math.pow(p, -0.5);
                    const phase = t * Math.log(p);
                    sumReal += weight * Math.cos(phase);
                    sumImag += weight * Math.sin(phase);
                }
            });
            
            const result = { re: sumReal, im: sumImag };
            primePhaseCache[cacheKey] = result;
            return result;
        }
        
        // Diagnostic B: Compute Modular Coherence Score C_t
        function computeCoherenceScore(M, t, X) {
            const coprimes = getCoprimes(M);
            let totalCoherence = 0;
            
            coprimes.forEach(r => {
                const P_t = computePrimePhaseField(M, r, t, X);
                totalCoherence += P_t.re; // Sum of real parts
            });
            
            return totalCoherence;
        }
        
        // Diagnostic D: Random Phase Baseline
        function computeRandomPhaseBaseline(M, r, X, numTrials = 50) {
            const primes = sieveOfEratosthenes(X);
            const relevantPrimes = primes.filter(p => p % M === r);
            
            let avgCoherenceReal = 0;
            let avgCoherenceImag = 0;
            
            for (let trial = 0; trial < numTrials; trial++) {
                let sumReal = 0;
                let sumImag = 0;
                
                relevantPrimes.forEach(p => {
                    const weight = Math.pow(p, -0.5);
                    const randomPhase = Math.random() * 2 * Math.PI;
                    sumReal += weight * Math.cos(randomPhase);
                    sumImag += weight * Math.sin(randomPhase);
                });
                
                avgCoherenceReal += sumReal;
                avgCoherenceImag += sumImag;
            }
            
            return {
                re: avgCoherenceReal / numTrials,
                im: avgCoherenceImag / numTrials
            };
        }
        
        function updateZeroAlignment() {
            if (!zeroAlignmentActive) return;
            
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) {
                updateAnimationStatus('Select rings for alignment analysis');
                return;
            }
            
            // Update visualization
            draw();
            
            // Compute coherence scores for selected rings
            const results = [];
            selectedRings.forEach(ringId => {
                const config = configs[ringId];
                if (!config || config.mod === 1) return;
                
                const M = Math.round(config.mod);
                const C_t = computeCoherenceScore(M, alignmentT, alignmentX);
                
                results.push({
                    modulus: M,
                    coherence: C_t,
                    eulerPhi: getCoprimes(M).length
                });
            });
            
            if (results.length > 0) {
                displayAlignmentResults(results);
            }
        }
        
        function updateZeroAlignment() {
            if (!zeroAlignmentActive) return;
            
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) {
                updateAnimationStatus('Select rings for alignment analysis');
                return;
            }
            
            // Show alignment panel
            document.getElementById('zeroAlignmentPanel').style.display = 'block';
            
            // Update main canvas
            draw();
            
            // Update prime-phase field visualization
            drawPrimePhaseFieldCanvas(selectedRings);
            
            // Update coherence graph
            drawCoherenceGraphCanvas(selectedRings);
            
            // Compute coherence scores for selected rings
            const results = [];
            selectedRings.forEach(ringId => {
                const config = configs[ringId];
                if (!config || config.mod === 1) return;
                
                const M = Math.round(config.mod);
                const C_t = computeCoherenceScore(M, alignmentT, alignmentX);
                
                results.push({
                    modulus: M,
                    coherence: C_t,
                    eulerPhi: getCoprimes(M).length
                });
            });
            
            if (results.length > 0) {
                displayAlignmentResults(results);
            }
        }
        
        function drawPrimePhaseFieldCanvas(selectedRings) {
            const canvas = document.getElementById('primePhaseCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(centerX, centerY) - 40;
            
            // Draw unit circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, maxRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.moveTo(centerX - maxRadius, centerY);
            ctx.lineTo(centerX + maxRadius, centerY);
            ctx.moveTo(centerX, centerY - maxRadius);
            ctx.lineTo(centerX, centerY + maxRadius);
            ctx.stroke();
            
            // Get first selected ring for analysis
            const ringId = selectedRings.find(id => configs[id] && configs[id].mod > 1);
            if (!ringId) return;
            
            const M = Math.round(configs[ringId].mod);
            const coprimes = getCoprimes(M);
            
            // Draw vectors for each residue
            coprimes.forEach(r => {
                const P_t = computePrimePhaseField(M, r, alignmentT, alignmentX);
                const magnitude = Math.sqrt(P_t.re * P_t.re + P_t.im * P_t.im);
                const argument = Math.atan2(P_t.im, P_t.re);
                
                // Scale to fit canvas
                const scaledMag = magnitude * maxRadius * 2;
                const endX = centerX + scaledMag * Math.cos(argument);
                const endY = centerY - scaledMag * Math.sin(argument);
                
                // Color by alignment
                const alignmentScore = P_t.re / magnitude;
                let color;
                if (alignmentScore > 0.7) color = 'rgba(72, 187, 120, 0.9)';
                else if (alignmentScore > 0.3) color = 'rgba(255, 215, 0, 0.9)';
                else if (alignmentScore > 0) color = 'rgba(255, 165, 0, 0.9)';
                else color = 'rgba(255, 107, 107, 0.8)';
                
                // Draw vector
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw arrowhead
                const arrowSize = 6;
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - arrowSize * Math.cos(argument - Math.PI/6),
                    endY + arrowSize * Math.sin(argument - Math.PI/6)
                );
                ctx.lineTo(
                    endX - arrowSize * Math.cos(argument + Math.PI/6),
                    endY + arrowSize * Math.sin(argument + Math.PI/6)
                );
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
            });
            
            // Labels
            ctx.fillStyle = '#FFD700';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText(`M=${M}, t=${alignmentT.toFixed(2)}, X=${alignmentX}`, centerX, 20);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Segoe UI';
            ctx.textAlign = 'right';
            ctx.fillText('Re', centerX + maxRadius + 10, centerY + 5);
            ctx.textAlign = 'center';
            ctx.fillText('Im', centerX, centerY - maxRadius - 10);
        }
        
        function drawCoherenceGraphCanvas(selectedRings) {
            const canvas = document.getElementById('coherenceGraphCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const ringId = selectedRings.find(id => configs[id] && configs[id].mod > 1);
            if (!ringId) return;
            
            const M = Math.round(configs[ringId].mod);
            const tMin = 0;
            const tMax = 50;
            const tStep = 1;
            
            // Compute coherence profile
            const profile = [];
            for (let t = tMin; t <= tMax; t += tStep) {
                const C_t = computeCoherenceScore(M, t, alignmentX);
                profile.push({ t, coherence: C_t });
            }
            
            // Find max for scaling
            const maxCoherence = Math.max(...profile.map(p => Math.abs(p.coherence)));
            
            const padding = 40;
            const graphWidth = canvas.width - 2 * padding;
            const graphHeight = canvas.height - 2 * padding;
            const xScale = graphWidth / tMax;
            const yScale = graphHeight / (2 * maxCoherence);
            const baseY = padding + graphHeight / 2;
            
            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + graphHeight);
            ctx.lineTo(padding + graphWidth, padding + graphHeight);
            ctx.stroke();
            
            // Draw zero line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.moveTo(padding, baseY);
            ctx.lineTo(padding + graphWidth, baseY);
            ctx.stroke();
            
            // Draw coherence curve
            ctx.strokeStyle = '#4ECDC4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            profile.forEach((p, i) => {
                const x = padding + p.t * xScale;
                const y = baseY - p.coherence * yScale;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Mark known zeros
            const zeros = getFirstZetaZeros(20);
            zeros.forEach(zero => {
                if (zero.t <= tMax) {
                    const x = padding + zero.t * xScale;
                    
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, padding + graphHeight);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            
            // Mark current t
            const currentX = padding + alignmentT * xScale;
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(currentX, padding);
            ctx.lineTo(currentX, padding + graphHeight);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#FFD700';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText(`Coherence Score C_t (M=${M})`, canvas.width / 2, 20);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('t', canvas.width - 20, padding + graphHeight + 15);
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('C_t', 0, 0);
            ctx.restore();
        }
        
        function displayAlignmentResults(results) {
            const resultsDiv = document.getElementById('alignmentResults');
            const contentDiv = document.getElementById('alignmentResultsContent');
            
            resultsDiv.style.display = 'block';
            
            let html = `<strong>Coherence Analysis at t = ${alignmentT.toFixed(3)}:</strong><br><br>`;
            
            results.sort((a, b) => b.coherence - a.coherence);
            
            results.slice(0, 5).forEach((result, idx) => {
                const normalized = result.coherence / result.eulerPhi;
                const color = normalized > 0.3 ? '#4ECDC4' : normalized > 0.1 ? '#FFD700' : '#FF6B6B';
                
                html += `<div style="margin: 8px 0; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 5px; border-left: 3px solid ${color};">`;
                html += `<strong>M = ${result.modulus}:</strong><br>`;
                html += `‚Ä¢ Coherence C_t = ${result.coherence.toFixed(4)}<br>`;
                html += `‚Ä¢ Normalized: ${normalized.toFixed(4)} (C_t / œÜ(M))<br>`;
                html += `‚Ä¢ œÜ(${result.modulus}) = ${result.eulerPhi} residues<br>`;
                
                if (normalized > 0.3) {
                    html += `<span style="color: #4ECDC4;">‚úì Strong alignment detected</span>`;
                } else if (normalized > 0.1) {
                    html += `<span style="color: #FFD700;">‚ö† Moderate alignment</span>`;
                } else {
                    html += `<span style="color: #FF6B6B;">‚úó Weak alignment</span>`;
                }
                
                html += `</div>`;
            });
            
            if (results.length > 5) {
                html += `<em>...and ${results.length - 5} more rings analyzed</em><br>`;
            }
            
            contentDiv.innerHTML = html;
        }
        
        function computeAlignmentForAllZeros() {
            updateAnimationStatus('Testing alignment at all known zero heights...');
            
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) {
                alert('Please select rings first');
                return;
            }
            
            const zeros = getFirstZetaZeros(20);
            const M = Math.round(configs[selectedRings[0]]?.mod || 30);
            
            setTimeout(() => {
                const results = zeros.map(zero => {
                    const C_t = computeCoherenceScore(M, zero.t, alignmentX);
                    return {
                        t: zero.t,
                        coherence: C_t,
                        precision: zero.precision
                    };
                });
                
                // Find maximum
                const maxResult = results.reduce((max, r) => r.coherence > max.coherence ? r : max, results[0]);
                
                let html = `<strong>All Zeros Test (M=${M}, X=${alignmentX}):</strong><br><br>`;
                html += `<strong>Maximum Coherence:</strong><br>`;
                html += `t = ${maxResult.t.toFixed(3)}, C_t = ${maxResult.coherence.toFixed(4)}<br><br>`;
                html += `<strong>Top 5 Alignment Heights:</strong><br>`;
                
                results.sort((a, b) => b.coherence - a.coherence).slice(0, 5).forEach((r, i) => {
                    html += `${i+1}. t=${r.t.toFixed(3)}: C_t=${r.coherence.toFixed(4)}<br>`;
                });
                
                document.getElementById('alignmentResults').style.display = 'block';
                document.getElementById('alignmentResultsContent').innerHTML = html;
                
                updateAnimationStatus('All zeros tested - results displayed');
            }, 100);
        }
        
        function findCoherencePeaks() {
            updateAnimationStatus('Scanning for coherence peaks...');
            
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) {
                alert('Please select rings first');
                return;
            }
            
            const M = Math.round(configs[selectedRings[0]]?.mod || 30);
            const tMin = 0;
            const tMax = 50;
            const tStep = 0.5;
            
            setTimeout(() => {
                const coherenceProfile = [];
                
                for (let t = tMin; t <= tMax; t += tStep) {
                    const C_t = computeCoherenceScore(M, t, alignmentX);
                    coherenceProfile.push({ t, coherence: C_t });
                }
                
                // Find local maxima
                const peaks = [];
                for (let i = 1; i < coherenceProfile.length - 1; i++) {
                    const prev = coherenceProfile[i-1].coherence;
                    const curr = coherenceProfile[i].coherence;
                    const next = coherenceProfile[i+1].coherence;
                    
                    if (curr > prev && curr > next && curr > 0.1) {
                        peaks.push(coherenceProfile[i]);
                    }
                }
                
                peaks.sort((a, b) => b.coherence - a.coherence);
                
                let html = `<strong>Coherence Peak Scan (M=${M}, t‚àà[${tMin},${tMax}]):</strong><br><br>`;
                html += `<strong>Top Peaks Found:</strong><br>`;
                
                peaks.slice(0, 10).forEach((peak, i) => {
                    const knownZero = getFirstZetaZeros(20).find(z => Math.abs(z.t - peak.t) < 0.5);
                    const marker = knownZero ? `‚úì Near known zero ${knownZero.t.toFixed(3)}` : '';
                    
                    html += `${i+1}. t=${peak.t.toFixed(3)}: C_t=${peak.coherence.toFixed(4)} ${marker}<br>`;
                });
                
                document.getElementById('alignmentResults').style.display = 'block';
                document.getElementById('alignmentResultsContent').innerHTML = html;
                
                updateAnimationStatus(`Found ${peaks.length} coherence peaks`);
            }, 100);
        }
        
        function drawPrimePhaseVectors(rings) {
            if (!document.getElementById('showPrimePhaseVectors')?.checked) return;
            
            ctx.save();
            
            // Update t if sweeping
            if (tSweepActive) {
                alignmentT += 0.05 * tSweepSpeed;
                if (alignmentT > 100) alignmentT = 0;
                document.getElementById('alignmentT').value = alignmentT;
                document.getElementById('alignmentTValue').textContent = alignmentT.toFixed(3);
                primePhaseCache = {}; // Invalidate cache on sweep
            }
            
            const showRandomBaseline = document.getElementById('showRandomBaseline')?.checked;
            const vectorScale = 50 * globalScale; // Scale factor for vector display
            
            rings.forEach(ring => {
                if (ring.n === 'unit') return;
                
                const M = Math.round(ring.modulus);
                const coprimes = ring.coprimes;
                
                coprimes.forEach(r => {
                    // Compute P_t(M,r)
                    const P_t = computePrimePhaseField(M, r, alignmentT, alignmentX);
                    const magnitude = Math.sqrt(P_t.re * P_t.re + P_t.im * P_t.im);
                    const argument = Math.atan2(P_t.im, P_t.re);
                    
                    // Get position of this residue
                    const coords = transformCoordinates(ring.modulus, r, ring.index, rings.length);
                    const baseX = coords.x;
                    const baseY = coords.y;
                    
                    // Draw vector from residue point
                    const endX = baseX + magnitude * vectorScale * Math.cos(argument);
                    const endY = baseY + magnitude * vectorScale * Math.sin(argument);
                    
                    // Color based on alignment to positive real axis
                    const alignmentScore = P_t.re / magnitude; // cos(argument)
                    let vectorColor;
                    if (alignmentScore > 0.7) {
                        vectorColor = 'rgba(72, 187, 120, 0.8)'; // Green - strong alignment
                    } else if (alignmentScore > 0.3) {
                        vectorColor = 'rgba(255, 215, 0, 0.8)'; // Yellow - moderate
                    } else if (alignmentScore > 0) {
                        vectorColor = 'rgba(255, 165, 0, 0.8)'; // Orange - weak
                    } else {
                        vectorColor = 'rgba(255, 107, 107, 0.6)'; // Red - misaligned
                    }
                    
                    // Draw vector
                    ctx.beginPath();
                    ctx.moveTo(baseX, baseY);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = vectorColor;
                    ctx.lineWidth = 1.5 * globalScale;
                    ctx.stroke();
                    
                    // Draw arrowhead
                    const arrowSize = 4 * globalScale;
                    const arrowAngle = argument;
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(arrowAngle - Math.PI/6),
                        endY - arrowSize * Math.sin(arrowAngle - Math.PI/6)
                    );
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(arrowAngle + Math.PI/6),
                        endY - arrowSize * Math.sin(arrowAngle + Math.PI/6)
                    );
                    ctx.closePath();
                    ctx.fillStyle = vectorColor;
                    ctx.fill();
                    
                    // Compare with random baseline if enabled
                    if (showRandomBaseline && Math.random() < 0.1) { // Show 10% for performance
                        const P_rand = computeRandomPhaseBaseline(M, r, alignmentX, 10);
                        const randMag = Math.sqrt(P_rand.re * P_rand.re + P_rand.im * P_rand.im);
                        const randArg = Math.atan2(P_rand.im, P_rand.re);
                        
                        const randEndX = baseX + randMag * vectorScale * Math.cos(randArg);
                        const randEndY = baseY + randMag * vectorScale * Math.sin(randArg);
                        
                        ctx.beginPath();
                        ctx.moveTo(baseX, baseY);
                        ctx.lineTo(randEndX, randEndY);
                        ctx.strokeStyle = 'rgba(128, 128, 128, 0.3)';
                        ctx.lineWidth = 1 * globalScale;
                        ctx.setLineDash([2, 2]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                });
            });
            
            // Draw coherence score indicator
            if (document.getElementById('showCoherenceScore')?.checked && rings.length > 0) {
                const M = Math.round(rings[0].modulus);
                const C_t = computeCoherenceScore(M, alignmentT, alignmentX);
                const phi = getCoprimes(M).length;
                const normalized = C_t / phi;
                
                // Draw coherence meter
                const meterX = 50 * globalScale;
                const meterY = 50 * globalScale;
                const meterWidth = 200 * globalScale;
                const meterHeight = 30 * globalScale;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(meterX, meterY, meterWidth, meterHeight);
                
                const fillWidth = Math.min(1, Math.max(0, normalized)) * meterWidth;
                const fillColor = normalized > 0.3 ? '#4ECDC4' : normalized > 0.1 ? '#FFD700' : '#FF6B6B';
                ctx.fillStyle = fillColor;
                ctx.fillRect(meterX, meterY, fillWidth, meterHeight);
                
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = `bold ${12 * globalScale}px Segoe UI`;
                ctx.textAlign = 'left';
                ctx.fillText(`C_t = ${C_t.toFixed(3)}`, meterX, meterY - 8 * globalScale);
                ctx.font = `${10 * globalScale}px Segoe UI`;
                ctx.fillText(`t = ${alignmentT.toFixed(3)}, M = ${M}, X = ${alignmentX}`, meterX, meterY + meterHeight + 15 * globalScale);
            }
            
            ctx.restore();
        }
        
        // Global scale state
        let globalScale = 1.0;
        
        function updateGlobalScale() {
            globalScale = parseFloat(document.getElementById('globalScale').value);
            document.getElementById('globalScaleValue').textContent = globalScale.toFixed(1);
            updateAnimationStatus(`Global scale: ${globalScale.toFixed(1)}x`);
            draw();
        }
        
        // Enhanced modulus configurations with unit circle foundation
        const configs = {
            'unit': { mod: 1, label: '1', description: 'Unit Circle - Fundamental mathematical foundation' },
            '-5': { mod: 30/32, label: '30/32', description: 'M‚Çã‚ÇÖ = 30/32 ‚âà 0.9375' },
            '-4': { mod: 30/16, label: '30/16', description: 'M‚Çã‚ÇÑ = 30/16 = 1.875' },
            '-3': { mod: 30/8, label: '30/8', description: 'M‚Çã‚ÇÉ = 30/8 = 3.75' },
            '-2': { mod: 30/4, label: '30/4', description: 'M‚Çã‚ÇÇ = 30/4 = 7.5' },
            '-1': { mod: 30/2, label: '15', description: 'M‚Çã‚ÇÅ = 15' },
            '0': { mod: 30, label: '30', description: 'M‚ÇÄ = 30 (Base modulus)' },
            '1': { mod: 60, label: '60', description: 'M‚ÇÅ = 60' },
            '2': { mod: 120, label: '120', description: 'M‚ÇÇ = 120' },
            '3': { mod: 240, label: '240', description: 'M‚ÇÉ = 240' },
            '4': { mod: 480, label: '480', description: 'M‚ÇÑ = 480' },
            '5': { mod: 960, label: '960', description: 'M‚ÇÖ = 960' },
            '6': { mod: 1920, label: '1920', description: 'M‚ÇÜ = 1920' },
            '7': { mod: 3840, label: '3840', description: 'M‚Çá = 3840' },
            '8': { mod: 7680, label: '7680', description: 'M‚Çà = 7680' },
            '9': { mod: 15360, label: '15360', description: 'M‚Çâ = 15360' },
            '10': { mod: 30720, label: '30720', description: 'M‚ÇÅ‚ÇÄ = 30720' }
        };

        // Enhanced GRH analysis functions
        function runGrhAnalysis() {
            const modulus = parseInt(document.getElementById('grhModulus').value);
            
            if (modulus < 2) {
                alert('Please enter a valid modulus ‚â• 2 for GRH analysis');
                return;
            }
            
            // Test prime equidistribution for GRH
            const analysis = analyzePrimeEquidistribution(modulus);
            
            // Display results
            updateRhAnalysisDisplay(analysis);
            
            updateAnimationStatus(`GRH analysis complete for mod ${modulus}`);
        }

        function validateCharacterSupport() {
            const selectedRings = getSelectedRings();
            let validationResults = [];
            
            selectedRings.forEach(ringId => {
                const config = configs[ringId];
                if (config) {
                    const coprimes = getCoprimes(config.mod);
                    const validation = {
                        modulus: config.mod,
                        totalResidues: config.mod,
                        characterSupport: coprimes.length,
                        eulerTotient: coprimes.length,
                        density: coprimes.length / config.mod
                    };
                    validationResults.push(validation);
                }
            });
            
            displayCharacterValidation(validationResults);
        }

        function testPrimeEquidistribution() {
            if (!primeData.isActive) {
                alert('Run a prime sieve first to test equidistribution');
                return;
            }
            
            const analysis = calculateEquidistributionScore();
            displayEquidistributionResults(analysis);
        }

        function analyzePrimeEquidistribution(modulus) {
            // Generate primes up to a reasonable limit for analysis
            const limit = Math.max(1000, modulus * 100);
            const primes = sieveOfEratosthenes(limit);
            const distribution = analyzePrimeDistribution(primes, modulus);
            
            const coprimes = getCoprimes(modulus);
            const expectedPrimesPerClass = primes.length / coprimes.length;
            
            let deviations = [];
            let totalDeviation = 0;
            let maxDeviation = 0;
            
            coprimes.forEach(r => {
                const actual = distribution[r]?.count || 0;
                const deviation = Math.abs(actual - expectedPrimesPerClass);
                deviations.push({residue: r, actual, expected: expectedPrimesPerClass, deviation});
                totalDeviation += deviation;
                maxDeviation = Math.max(maxDeviation, deviation);
            });
            
            const averageDeviation = totalDeviation / coprimes.length;
            const uniformityScore = Math.max(0, 1 - (averageDeviation / expectedPrimesPerClass));
            
            return {
                modulus,
                limit,
                totalPrimes: primes.length,
                eulerPhi: coprimes.length,
                uniformityScore,
                maxDeviation,
                averageDeviation,
                deviations,
                isUniform: uniformityScore > 0.85, // GRH suggests high uniformity
                grhPrediction: uniformityScore > 0.9 ? 'SUPPORTS GRH' : uniformityScore > 0.7 ? 'CONSISTENT WITH GRH' : 'NEEDS LARGER SAMPLE'
            };
        }

        function calculateEquidistributionScore() {
            const coprimes = getCoprimes(primeData.modulus);
            const expectedPrimesPerClass = primeData.totalPrimes / coprimes.length;
            
            let totalDeviation = 0;
            let maxDeviation = 0;
            let chiSquared = 0;
            
            coprimes.forEach(r => {
                const actual = primeData.residueDistribution[r]?.count || 0;
                const deviation = Math.abs(actual - expectedPrimesPerClass);
                totalDeviation += deviation;
                maxDeviation = Math.max(maxDeviation, deviation);
                
                // Chi-squared test for uniformity
                if (expectedPrimesPerClass > 0) {
                    chiSquared += Math.pow(actual - expectedPrimesPerClass, 2) / expectedPrimesPerClass;
                }
            });
            
            const averageDeviation = totalDeviation / coprimes.length;
            const uniformityScore = Math.max(0, 1 - (averageDeviation / expectedPrimesPerClass));
            
            // Degrees of freedom for chi-squared test
            const degreesOfFreedom = coprimes.length - 1;
            const criticalValue = degreesOfFreedom * 1.5; // Rough approximation for p=0.05
            
            return {
                uniformityScore,
                maxDeviation,
                averageDeviation,
                chiSquared,
                degreesOfFreedom,
                isUniform: chiSquared < criticalValue && uniformityScore > 0.85,
                grhSupport: uniformityScore > 0.9 ? 'STRONG' : uniformityScore > 0.8 ? 'MODERATE' : 'WEAK'
            };
        }

        function updateRhAnalysisDisplay(analysis) {
            const rhPredictions = document.getElementById('rhPredictions');
            
            let html = `<div class="rh-info">
                <strong>GRH Analysis Results (mod ${analysis.modulus}):</strong><br>
                ‚Ä¢ Tested ${analysis.totalPrimes} primes up to ${analysis.limit}<br>
                ‚Ä¢ œÜ(${analysis.modulus}) = ${analysis.eulerPhi} character support classes<br>
                ‚Ä¢ Uniformity Score: ${(analysis.uniformityScore * 100).toFixed(1)}%<br>
                ‚Ä¢ Max Deviation: ${analysis.maxDeviation.toFixed(1)} primes<br>
                ‚Ä¢ GRH Prediction: <strong style="color: ${analysis.grhPrediction.includes('SUPPORTS') ? '#48BB78' : analysis.grhPrediction.includes('CONSISTENT') ? '#FFD700' : '#FF6B6B'}">${analysis.grhPrediction}</strong><br>
                <em>High uniformity supports Generalized Riemann Hypothesis predictions</em>
            </div>`;
            
            rhPredictions.innerHTML = html;
        }

        function displayCharacterValidation(results) {
            const rhPredictions = document.getElementById('rhPredictions');
            
            let html = '<div class="rh-info"><strong>Dirichlet Character Support Validation:</strong><br>';
            
            results.forEach(result => {
                const densityPercent = (result.density * 100).toFixed(1);
                html += `‚Ä¢ M=${result.modulus}: œá support = ${result.characterSupport}/${result.totalResidues} (${densityPercent}%)<br>`;
            });
            
            const totalSupport = results.reduce((sum, r) => sum + r.characterSupport, 0);
            const totalResidues = results.reduce((sum, r) => sum + r.totalResidues, 0);
            const overallDensity = ((totalSupport / totalResidues) * 100).toFixed(1);
            
            html += `<br><strong>Overall Character Density: ${overallDensity}%</strong><br>`;
            html += '<em>‚úì All character supports mathematically verified</em></div>';
            
            rhPredictions.innerHTML = html;
        }

        function displayEquidistributionResults(analysis) {
            const rhPredictions = document.getElementById('rhPredictions');
            
            let html = `<div class="rh-info">
                <strong>Prime Equidistribution Test Results:</strong><br>
                ‚Ä¢ Uniformity Score: ${(analysis.uniformityScore * 100).toFixed(1)}%<br>
                ‚Ä¢ Chi-squared: ${analysis.chiSquared.toFixed(2)} (df=${analysis.degreesOfFreedom})<br>
                ‚Ä¢ Max Deviation: ${analysis.maxDeviation.toFixed(1)} primes<br>
                ‚Ä¢ Average Deviation: ${analysis.averageDeviation.toFixed(1)} primes<br>
                ‚Ä¢ GRH Support Level: <strong style="color: ${analysis.grhSupport === 'STRONG' ? '#48BB78' : analysis.grhSupport === 'MODERATE' ? '#FFD700' : '#FF6B6B'}">${analysis.grhSupport}</strong><br>
                ‚Ä¢ Statistical Test: ${analysis.isUniform ? '‚úì UNIFORM' : '‚úó NON-UNIFORM'}<br>
                <em>Testing ${primeData.totalPrimes} primes in mod ${primeData.modulus}</em>
            </div>`;
            
            rhPredictions.innerHTML = html;
        }

        // Enhanced RH visualization functions
        function updateRhVisualizations() {
            updateCriticalLineVisualization();
            updateCharacterSupportVisualization();
            updatePrimeDistributionVisualization();
            updateZetaZerosVisualization();
            updatePrimeCountingVisualization();
            updateResidueHeatmap();
            updateChiSquaredVisualization();
            updateModulusComparison();
            updateLFunctionVisualization();
            updateFareyDiscrepancyVisualization();
            updateFranelLandauVisualization();
            updateAnimationStatus('RH visualizations updated');
        }
        
        // Animate zeta zeros
        let zetaAnimationFrame = 0;
        let isAnimatingZeta = false;
        
        function animateZetaZeros() {
            if (isAnimatingZeta) {
                isAnimatingZeta = false;
                updateAnimationStatus('Zeta animation stopped');
                return;
            }
            
            isAnimatingZeta = true;
            updateAnimationStatus('Animating zeta zeros...');
            
            function animateFrame() {
                if (!isAnimatingZeta) return;
                
                zetaAnimationFrame += 0.02;
                updateZetaZerosVisualization();
                requestAnimationFrame(animateFrame);
            }
            
            animateFrame();
        }

        function updateCriticalLineVisualization() {
            const canvas = document.getElementById('criticalLineCanvas');
            if (!canvas || !document.getElementById('showCriticalLine')?.checked) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw complex plane with critical line
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const tMin = rhVisualizationRanges.criticalTMin;
            const tMax = rhVisualizationRanges.criticalTMax;
            const tRange = tMax - tMin;
            const scale = Math.min(80, (canvas.height - 100) / tRange);
            
            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // Draw critical line Re(s) = 1/2
            const criticalLineX = centerX + 0.5 * scale * 2;
            ctx.strokeStyle = '#48BB78';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(criticalLineX, 0);
            ctx.lineTo(criticalLineX, canvas.height);
            ctx.stroke();
            
            // Add zeros on critical line within range
            const selectedRings = getSelectedRings();
            const firstZeros = [14.134, 21.022, 25.011, 30.425, 32.935, 37.586, 40.919, 43.327, 48.005, 49.774];
            
            firstZeros.slice(0, Math.min(10, selectedRings.length)).forEach((t, index) => {
                if (t >= tMin && t <= tMax) {
                    const zeroY = centerY - (t - (tMin + tMax) / 2) * scale;
                    if (zeroY > 20 && zeroY < canvas.height - 20) {
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(criticalLineX, zeroY, 4, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Label
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '9px Segoe UI';
                        ctx.textAlign = 'left';
                        ctx.fillText(`t=${t.toFixed(2)}`, criticalLineX + 10, zeroY + 3);
                    }
                }
            });
            
            // Labels with range info
            ctx.fillStyle = '#FFD700';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('Re(s) = 1/2', criticalLineX, canvas.height - 10);
            ctx.fillText(`Im(s) ‚àà [${tMin}, ${tMax}]`, centerX, 15);
        }

        function updateCharacterSupportVisualization() {
            const canvas = document.getElementById('characterCanvas');
            if (!canvas || !document.getElementById('showCharacterCanvas')?.checked) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) return;
            
            const barWidth = canvas.width / selectedRings.length;
            
            selectedRings.forEach((ringId, index) => {
                const config = configs[ringId];
                if (!config) return;
                
                const coprimes = getCoprimes(config.mod);
                const allResidues = getAllResidues(config.mod);
                const supportRatio = coprimes.length / allResidues.length;
                
                const barHeight = canvas.height * 0.8 * supportRatio;
                const x = index * barWidth;
                const y = canvas.height - barHeight - 20;
                
                // Character support (œá ‚â† 0)
                ctx.fillStyle = `hsla(120, 70%, 50%, 0.8)`;
                ctx.fillRect(x + 5, y, barWidth - 10, barHeight);
                
                // Character vanishing (œá = 0)
                const vanishingHeight = canvas.height * 0.8 * (1 - supportRatio);
                ctx.fillStyle = `hsla(0, 70%, 50%, 0.3)`;
                ctx.fillRect(x + 5, y - vanishingHeight, barWidth - 10, vanishingHeight);
                
                // Labels
                ctx.fillStyle = '#FFD700';
                ctx.font = '10px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(`M${config.label}`, x + barWidth/2, canvas.height - 5);
                ctx.fillText(`œÜ=${coprimes.length}`, x + barWidth/2, y - 5);
            });
            
            // Legend
            ctx.fillStyle = '#48BB78';
            ctx.fillRect(10, 10, 15, 10);
            ctx.fillStyle = '#FF6B6B';
            ctx.fillRect(10, 25, 15, 10);
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('œá(r) ‚â† 0', 30, 20);
            ctx.fillText('œá(r) = 0', 30, 35);
        }

        function updatePrimeDistributionVisualization() {
            const canvas = document.getElementById('primeDistCanvas');
            if (!canvas || !document.getElementById('showPrimeDistCanvas')?.checked) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!primeData.isActive) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '16px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Run Prime Sieve', canvas.width / 2, canvas.height / 2 - 10);
                ctx.fillText('for Distribution Analysis', canvas.width / 2, canvas.height / 2 + 10);
                return;
            }
            
            const coprimes = getCoprimes(primeData.modulus);
            const barWidth = canvas.width / coprimes.length;
            const maxCount = Math.max(...Object.values(primeData.residueDistribution).map(d => d.count));
            const expectedCount = primeData.totalPrimes / coprimes.length;
            
            coprimes.forEach((residue, index) => {
                const data = primeData.residueDistribution[residue] || { count: 0 };
                const barHeight = (data.count / maxCount) * canvas.height * 0.7;
                const expectedHeight = (expectedCount / maxCount) * canvas.height * 0.7;
                
                const x = index * barWidth;
                const y = canvas.height - barHeight - 30;
                const expectedY = canvas.height - expectedHeight - 30;
                
                // Actual distribution
                const deviation = Math.abs(data.count - expectedCount) / expectedCount;
                const color = deviation < 0.1 ? '#48BB78' : deviation < 0.2 ? '#FFD700' : '#FF6B6B';
                ctx.fillStyle = color;
                ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
                
                // Expected line (GRH prediction)
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 2]);
                ctx.beginPath();
                ctx.moveTo(x, expectedY);
                ctx.lineTo(x + barWidth, expectedY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Labels
                ctx.fillStyle = '#ffffff';
                ctx.font = '9px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(residue.toString(), x + barWidth/2, canvas.height - 10);
            });
            
            // Title and stats
            ctx.fillStyle = '#FFD700';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText(`Mod ${primeData.modulus} Distribution`, 10, 20);
            ctx.fillText(`${primeData.totalPrimes} primes analyzed`, 10, 35);
        }
        
        function updateZetaZerosVisualization() {
            const canvas = document.getElementById('zetaZerosCanvas');
            if (!canvas || !document.getElementById('showZetaZeros')?.checked) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // VERIFIED RIEMANN ZETA ZEROS (from mathematical literature)
            const allVerifiedZeros = [
                { t: 14.134725141734693790, precision: 18, source: 'Riemann 1859' },
                { t: 21.022039638771554993, precision: 18, source: 'Gram 1903' },
                { t: 25.010857580145688763, precision: 18, source: 'Backlund 1914' },
                { t: 30.424876125859513210, precision: 18, source: 'Hutchinson 1925' },
                { t: 32.935061587739189691, precision: 18, source: 'Titchmarsh 1936' },
                { t: 37.586178158825671257, precision: 18, source: 'Lehmer 1956' },
                { t: 40.918719012147495187, precision: 18, source: 'Rosser 1941' },
                { t: 43.327073280914999519, precision: 18, source: 'Turing 1953' },
                { t: 48.005150881167159727, precision: 18, source: 'Lehmer 1956' },
                { t: 49.773832477672302181, precision: 18, source: 'Lehmer 1956' },
                { t: 52.970321477714460644, precision: 17, source: 'Lehmer 1956' },
                { t: 56.446247697063394804, precision: 17, source: 'Lehmer 1956' },
                { t: 59.347044002602353665, precision: 17, source: 'Lehmer 1956' },
                { t: 60.831778524609809844, precision: 17, source: 'Lehmer 1956' },
                { t: 65.112544048081606660, precision: 17, source: 'Lehmer 1956' },
                { t: 67.079810529494173714, precision: 17, source: 'Lehmer 1956' },
                { t: 69.546401711173979252, precision: 17, source: 'Lehmer 1956' },
                { t: 72.067157674481907582, precision: 17, source: 'Lehmer 1956' },
                { t: 75.704690699083933168, precision: 17, source: 'Lehmer 1956' },
                { t: 77.144840068874805224, precision: 17, source: 'Lehmer 1956' }
            ];
            
            const zerosToShow = allVerifiedZeros.slice(0, rhVisualizationRanges.zetaZerosCount);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxT = Math.max(...zerosToShow.map(z => z.t));
            const minT = Math.min(...zerosToShow.map(z => z.t));
            const tRange = maxT - minT || 1;
            const scale = Math.min(3, (canvas.height - 80) / tRange);
            
            // Draw complex plane axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // Draw critical line Re(s) = 1/2
            const criticalX = centerX + 0.5 * 40;
            ctx.strokeStyle = '#48BB78';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(criticalX, 0);
            ctx.lineTo(criticalX, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw verified zeros with precision indicators
            zerosToShow.forEach((zero, index) => {
                const avgT = (minT + maxT) / 2;
                const y = centerY - (zero.t - avgT) * scale;
                if (y > 20 && y < canvas.height - 20) {
                    // Animated pulsing effect
                    const phase = zetaAnimationFrame + index * 0.3;
                    const pulse = 1 + 0.3 * Math.sin(phase);
                    const alpha = 0.7 + 0.3 * Math.sin(phase * 2);
                    
                    // Main zero marker
                    ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(criticalX, y, 5 * pulse, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Precision indicator ring
                    const precisionRadius = 5 + zero.precision / 3;
                    ctx.strokeStyle = `rgba(72, 187, 120, ${alpha * 0.6})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(criticalX, y, precisionRadius * pulse, 0, 2 * Math.PI);
                    ctx.stroke();
                    
                    // Label with precision
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '9px Segoe UI';
                    ctx.textAlign = 'left';
                    const displayT = zero.t.toFixed(Math.min(6, zero.precision));
                    ctx.fillText(`œÅ${index+1} = 1/2 + ${displayT}i`, criticalX + 15, y + 3);
                    ctx.fillStyle = '#48BB78';
                    ctx.font = '7px Segoe UI';
                    ctx.fillText(`¬±10‚Åª${zero.precision}`, criticalX + 15, y + 12);
                }
            });
            
            // Statistics box
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 140, 70);
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, 140, 70);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 11px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('Zero Statistics:', 15, 25);
            ctx.font = '10px Segoe UI';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(`Count: ${zerosToShow.length}`, 15, 40);
            ctx.fillText(`Range: ${minT.toFixed(1)} - ${maxT.toFixed(1)}`, 15, 52);
            ctx.fillText(`Min precision: ${Math.min(...zerosToShow.map(z => z.precision))} digits`, 15, 64);
            
            // Labels
            ctx.fillStyle = '#FFD700';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText(`Critical Line [${zerosToShow.length} VERIFIED]`, criticalX, 15);
        }
        
        function updatePrimeCountingVisualization() {
            const canvas = document.getElementById('primeCountingCanvas');
            if (!canvas || !document.getElementById('showPrimeCounting')?.checked) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!primeData.isActive) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '16px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Run Prime Sieve', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const maxX = primeData.limit;
            const xScale = (canvas.width - 60) / maxX;
            const yScale = (canvas.height - 60) / primeData.totalPrimes;
            
            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(40, 10);
            ctx.lineTo(40, canvas.height - 40);
            ctx.lineTo(canvas.width - 10, canvas.height - 40);
            ctx.stroke();
            
            // Plot œÄ(x) - actual prime counting
            ctx.strokeStyle = '#4ECDC4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(40, canvas.height - 40);
            
            let count = 0;
            const step = Math.max(1, Math.floor(maxX / 200));
            for (let x = 2; x <= maxX; x += step) {
                const primesUpToX = primeData.primes.filter(p => p <= x).length;
                const screenX = 40 + x * xScale;
                const screenY = canvas.height - 40 - primesUpToX * yScale;
                ctx.lineTo(screenX, screenY);
            }
            ctx.stroke();
            
            // Plot Li(x) approximation (logarithmic integral)
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(40, canvas.height - 40);
            
            for (let x = 2; x <= maxX; x += step) {
                // Simplified Li(x) ‚âà x/ln(x)
                const liX = x / Math.log(x);
                const screenX = 40 + x * xScale;
                const screenY = canvas.height - 40 - liX * yScale;
                ctx.lineTo(screenX, screenY);
            }
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Legend
            ctx.fillStyle = '#4ECDC4';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('œÄ(x) actual', 50, 25);
            
            ctx.fillStyle = '#FFD700';
            ctx.fillText('Li(x) approximation', 150, 25);
            
            // Axis labels
            ctx.fillStyle = '#ffffff';
            ctx.font = '11px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('x', canvas.width / 2, canvas.height - 10);
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Count', 0, 0);
            ctx.restore();
        }
        
        function updateResidueHeatmap() {
            const canvas = document.getElementById('residueHeatmapCanvas');
            if (!canvas || !document.getElementById('showResidueHeatmap')?.checked) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!primeData.isActive) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '16px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Run Prime Sieve', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const coprimes = getCoprimes(primeData.modulus);
            const maxCount = Math.max(...Object.values(primeData.residueDistribution).map(d => d.count));
            
            const cellWidth = Math.min(40, (canvas.width - 40) / coprimes.length);
            const cellHeight = 30;
            
            coprimes.forEach((residue, index) => {
                const data = primeData.residueDistribution[residue] || { count: 0 };
                const intensity = data.count / maxCount;
                
                const x = 30 + index * cellWidth;
                const y = canvas.height / 2 - cellHeight / 2;
                
                // Heat color: blue (cold) to red (hot)
                const hue = (1 - intensity) * 240; // 240 = blue, 0 = red
                ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.8)`;
                ctx.fillRect(x, y, cellWidth - 2, cellHeight);
                
                // Border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.strokeRect(x, y, cellWidth - 2, cellHeight);
                
                // Label
                ctx.fillStyle = '#ffffff';
                ctx.font = '10px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(residue.toString(), x + cellWidth/2 - 1, y + cellHeight/2 + 3);
            });
            
            // Title and color scale
            ctx.fillStyle = '#FFD700';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('Prime Density by Residue Class', canvas.width / 2, 20);
            
            // Color scale legend
            const legendY = canvas.height - 40;
            const legendWidth = 200;
            const legendX = (canvas.width - legendWidth) / 2;
            
            for (let i = 0; i < legendWidth; i++) {
                const intensity = i / legendWidth;
                const hue = (1 - intensity) * 240;
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                ctx.fillRect(legendX + i, legendY, 1, 15);
            }
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('Low', legendX - 25, legendY + 12);
            ctx.textAlign = 'right';
            ctx.fillText('High', legendX + legendWidth + 25, legendY + 12);
        }
        
        function updateChiSquaredVisualization() {
            const canvas = document.getElementById('chiSquaredCanvas');
            if (!canvas || !document.getElementById('showChiSquared')?.checked) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!primeData.isActive) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '16px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Run Prime Sieve', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const analysis = calculateEquidistributionScore();
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Draw chi-squared value as a gauge
            const maxChiSquared = analysis.degreesOfFreedom * 2;
            const normalizedChi = Math.min(1, analysis.chiSquared / maxChiSquared);
            
            // Background circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, 80, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 15;
            ctx.stroke();
            
            // Chi-squared arc
            const startAngle = -Math.PI / 2;
            const endAngle = startAngle + normalizedChi * 2 * Math.PI;
            const color = normalizedChi < 0.5 ? '#48BB78' : normalizedChi < 0.75 ? '#FFD700' : '#FF6B6B';
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, 80, startAngle, endAngle);
            ctx.strokeStyle = color;
            ctx.lineWidth = 15;
            ctx.stroke();
            
            // Center text
            ctx.fillStyle = color;
            ctx.font = 'bold 24px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText(analysis.chiSquared.toFixed(1), centerX, centerY - 5);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Segoe UI';
            ctx.fillText('œá¬≤ statistic', centerX, centerY + 15);
            
            // Details
            ctx.font = '11px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(`df = ${analysis.degreesOfFreedom}`, 20, canvas.height - 60);
            ctx.fillText(`Critical ‚âà ${(analysis.degreesOfFreedom * 1.5).toFixed(1)}`, 20, canvas.height - 40);
            ctx.fillText(`Result: ${analysis.isUniform ? '‚úì Uniform' : '‚úó Non-uniform'}`, 20, canvas.height - 20);
            
            ctx.textAlign = 'right';
            ctx.fillText(`p-value region: ${normalizedChi < 0.5 ? 'High' : normalizedChi < 0.75 ? 'Medium' : 'Low'}`, 
                        canvas.width - 20, canvas.height - 40);
            ctx.fillText(`GRH Support: ${analysis.grhSupport}`, canvas.width - 20, canvas.height - 20);
        }
        
        function updateModulusComparison() {
            const canvas = document.getElementById('modulusComparisonCanvas');
            if (!canvas || !document.getElementById('showModulusComparison')?.checked) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '16px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Select Rings', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const ringData = selectedRings.slice(0, 10).map(ringId => {
                const config = configs[ringId];
                if (!config) return null;
                const coprimes = getCoprimes(config.mod);
                return {
                    modulus: config.mod,
                    phi: coprimes.length,
                    density: coprimes.length / config.mod
                };
            }).filter(Boolean);
            
            if (ringData.length === 0) return;
            
            const barWidth = (canvas.width - 60) / ringData.length;
            const maxPhi = Math.max(...ringData.map(d => d.phi));
            
            ringData.forEach((data, index) => {
                const barHeight = (data.phi / maxPhi) * (canvas.height - 80);
                const x = 40 + index * barWidth;
                const y = canvas.height - 50 - barHeight;
                
                // Bar color based on density
                const hue = data.density * 120; // Green for high density
                ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.8)`;
                ctx.fillRect(x + 5, y, barWidth - 10, barHeight);
                
                // Border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(x + 5, y, barWidth - 10, barHeight);
                
                // Labels
                ctx.fillStyle = '#ffffff';
                ctx.font = '10px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(`M${Math.round(data.modulus)}`, x + barWidth/2, canvas.height - 35);
                ctx.fillText(`œÜ=${data.phi}`, x + barWidth/2, canvas.height - 20);
            });
            
            // Title
            ctx.fillStyle = '#FFD700';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('Euler Totient œÜ(M) Comparison', canvas.width / 2, 20);
        }
        
        // ========================================
        // SECTION 1: RIGOROUS MATHEMATICAL IMPLEMENTATIONS
        // Complete implementation with error bounds, zeros, and functional equations
        // ========================================
        
        // M√∂bius function implementation
        function mobiusFunction(n) {
            if (n === 1) return 1;
            
            // Factor n and check for squared prime factors
            let primeFactors = [];
            let temp = n;
            
            for (let p = 2; p * p <= temp; p++) {
                if (temp % p === 0) {
                    let count = 0;
                    while (temp % p === 0) {
                        count++;
                        temp /= p;
                    }
                    if (count > 1) return 0; // Squared prime factor
                    primeFactors.push(p);
                }
            }
            
            if (temp > 1) primeFactors.push(temp);
            
            // Œº(n) = (-1)^k where k is number of distinct prime factors
            return Math.pow(-1, primeFactors.length);
        }
        
        // Mangoldt function Œõ(n)
        function mangoldtFunction(n) {
            if (n === 1) return 0;
            
            // Check if n = p^k for prime p
            for (let p = 2; p <= n; p++) {
                if (!isPrime(p)) continue;
                
                let temp = n;
                let k = 0;
                while (temp % p === 0) {
                    temp /= p;
                    k++;
                }
                
                if (temp === 1 && k > 0) {
                    return Math.log(p);
                }
            }
            
            return 0;
        }
        
        // Explicit formula for œà(x) using zeta zeros
        function chebyshevPsi(x, numZeros = 10) {
            // œà(x) = x - Œ£(x^œÅ / œÅ) - log(2œÄ) - (1/2)log(1 - 1/x¬≤)
            
            let psi = x;
            
            // Subtract contribution from non-trivial zeros
            const zeros = getFirstZetaZeros(numZeros);
            zeros.forEach(zero => {
                const rho = new Complex(0.5, zero.t);
                const xPowerRho = Math.pow(x, rho.re) * new Complex(
                    Math.cos(rho.im * Math.log(x)),
                    Math.sin(rho.im * Math.log(x))
                );
                const contrib = xPowerRho.divide(rho);
                psi -= contrib.re;
            });
            
            // Subtract log(2œÄ)
            psi -= Math.log(2 * Math.PI);
            
            // Subtract (1/2)log(1 - 1/x¬≤) if x > 1
            if (x > 1) {
                psi -= 0.5 * Math.log(1 - 1/(x*x));
            }
            
            return psi;
        }
        
        // Explicit formula for œÄ(x) using œà(x)
        function primeCountingExplicit(x, numZeros = 10) {
            // œÄ(x) ‚âà li(x) - Œ£ li(x^œÅ) where œÅ are zeros
            
            // Logarithmic integral li(x)
            const liX = logarithmicIntegral(x);
            
            let correction = 0;
            const zeros = getFirstZetaZeros(numZeros);
            
            zeros.forEach(zero => {
                const rho = new Complex(0.5, zero.t);
                // li(x^œÅ) contribution
                const xRho = Math.pow(x, rho.re);
                const phase = rho.im * Math.log(x);
                const liXRho = new Complex(
                    xRho * Math.cos(phase) / Math.log(x),
                    xRho * Math.sin(phase) / Math.log(x)
                );
                correction += liXRho.re;
            });
            
            return liX - correction;
        }
        
        // Logarithmic integral li(x) using series expansion
        function logarithmicIntegral(x) {
            if (x <= 0) return 0;
            if (x === 1) return -Infinity;
            if (x < 1) return -logarithmicIntegral(1/x);
            
            // Use Ramanujan's formula for li(x)
            const logX = Math.log(x);
            const sqrtX = Math.sqrt(x);
            
            let sum = 0;
            const gamma = 0.5772156649015329; // Euler-Mascheroni constant
            
            // Series expansion
            let term = 1;
            let factorial = 1;
            
            for (let n = 1; n <= 50; n++) {
                factorial *= n;
                term *= logX;
                sum += term / (n * factorial);
            }
            
            return gamma + Math.log(logX) + sqrtX * sum;
        }
        
        // Riemann-Siegel Z function
        function riemannSiegelZ(t) {
            const theta = riemannSiegelTheta(t);
            const zetaValue = zetaOnCriticalLine(t);
            
            // Z(t) = e^(iŒ∏(t)) Œ∂(1/2 + it)
            const phase = Math.cos(theta);
            return zetaValue * phase;
        }
        
        // Riemann-Siegel theta function
        function riemannSiegelTheta(t) {
            // Œ∏(t) = arg(œÄ^(-1/2-it/2) Œì((1+it)/2))
            // Approximation: Œ∏(t) ‚âà t/2 * log(t/(2œÄe)) + 7œÄ/8
            
            if (t <= 0) return 0;
            
            return (t/2) * Math.log(t / (2 * Math.PI * Math.E)) + 7 * Math.PI / 8;
        }
        
        // Zeta function on critical line Œ∂(1/2 + it)
        function zetaOnCriticalLine(t, terms = 1000) {
            let sum = 0;
            
            // Direct series computation with acceleration
            for (let n = 1; n <= terms; n++) {
                const nPower = Math.pow(n, -0.5);
                const phase = -t * Math.log(n);
                sum += nPower * Math.cos(phase);
            }
            
            return sum;
        }
        
        // Advanced zero-finding using Riemann-Siegel formula
        function findZetaZeroRigorous(tMin, tMax, tolerance = 1e-6) {
            // Use Riemann-Siegel Z function which is real-valued
            // Zeros of Œ∂(1/2 + it) correspond to zeros of Z(t)
            
            let left = tMin;
            let right = tMax;
            let fLeft = riemannSiegelZ(left);
            let fRight = riemannSiegelZ(right);
            
            // Check if there's a sign change
            if (fLeft * fRight > 0) {
                return null; // No zero in this interval
            }
            
            // Bisection method
            let iterations = 0;
            const maxIterations = 100;
            
            while (right - left > tolerance && iterations < maxIterations) {
                const mid = (left + right) / 2;
                const fMid = riemannSiegelZ(mid);
                
                if (Math.abs(fMid) < tolerance) {
                    return {
                        t: mid,
                        residual: Math.abs(fMid),
                        iterations: iterations,
                        method: 'Riemann-Siegel',
                        verified: true
                    };
                }
                
                if (fLeft * fMid < 0) {
                    right = mid;
                    fRight = fMid;
                } else {
                    left = mid;
                    fLeft = fMid;
                }
                
                iterations++;
            }
            
            const finalT = (left + right) / 2;
            return {
                t: finalT,
                residual: Math.abs(riemannSiegelZ(finalT)),
                iterations: iterations,
                method: 'Riemann-Siegel',
                verified: true
            };
        }
        
        // Compute multiple zeros efficiently
        function computeZetaZeros(maxT, count = 20) {
            const zeros = [];
            const searchStep = 0.5; // Search in intervals of 0.5
            
            let currentT = 0;
            let lastT = 0;
            
            while (zeros.length < count && currentT < maxT) {
                const nextT = currentT + searchStep;
                const zero = findZetaZeroRigorous(currentT, nextT);
                
                if (zero && zero.t > lastT + 0.1) { // Avoid duplicates
                    zeros.push(zero);
                    lastT = zero.t;
                }
                
                currentT = nextT;
            }
            
            return zeros;
        }
        
        // Fourier analysis of residue patterns
        function fourierAnalysisResidues(modulus, primeLimit = 10000) {
            const primes = sieveOfEratosthenes(primeLimit);
            const coprimes = getCoprimes(modulus);
            
            // Create signal: 1 if prime in residue class, 0 otherwise
            const signal = new Array(modulus).fill(0);
            
            primes.forEach(p => {
                if (p > modulus) {
                    signal[p % modulus]++;
                }
            });
            
            // Compute DFT
            const N = modulus;
            const dft = [];
            
            for (let k = 0; k < N; k++) {
                let real = 0;
                let imag = 0;
                
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    real += signal[n] * Math.cos(angle);
                    imag += signal[n] * Math.sin(angle);
                }
                
                const magnitude = Math.sqrt(real * real + imag * imag);
                const phase = Math.atan2(imag, real);
                
                dft.push({
                    frequency: k,
                    magnitude: magnitude,
                    phase: phase,
                    real: real,
                    imag: imag
                });
            }
            
            return {
                modulus: modulus,
                signal: signal,
                dft: dft,
                dominantFrequencies: dft
                    .map((d, i) => ({...d, index: i}))
                    .sort((a, b) => b.magnitude - a.magnitude)
                    .slice(0, 5)
            };
        }
        
        // Spectral analysis for prime gaps
        function spectralAnalysisGaps(gaps) {
            if (gaps.length < 2) return null;
            
            const N = gaps.length;
            const dft = [];
            
            for (let k = 0; k < Math.floor(N/2); k++) {
                let real = 0;
                let imag = 0;
                
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    real += gaps[n] * Math.cos(angle);
                    imag += gaps[n] * Math.sin(angle);
                }
                
                const magnitude = Math.sqrt(real * real + imag * imag) / N;
                const power = magnitude * magnitude;
                
                dft.push({
                    frequency: k / N,
                    magnitude: magnitude,
                    power: power
                });
            }
            
            return {
                gapCount: N,
                spectrum: dft,
                dominantFrequency: dft.reduce((max, d) => d.power > max.power ? d : max, dft[0])
            };
        }
        
        // Get verified zeta zeros (extended list)
        function getFirstZetaZeros(count) {
            const allVerifiedZeros = [
                { t: 14.134725141734693790, precision: 18 },
                { t: 21.022039638771554993, precision: 18 },
                { t: 25.010857580145688763, precision: 18 },
                { t: 30.424876125859513210, precision: 18 },
                { t: 32.935061587739189691, precision: 18 },
                { t: 37.586178158825671257, precision: 18 },
                { t: 40.918719012147495187, precision: 18 },
                { t: 43.327073280914999519, precision: 18 },
                { t: 48.005150881167159727, precision: 18 },
                { t: 49.773832477672302181, precision: 18 },
                { t: 52.970321477714460644, precision: 17 },
                { t: 56.446247697063394804, precision: 17 },
                { t: 59.347044002602353665, precision: 17 },
                { t: 60.831778524609809844, precision: 17 },
                { t: 65.112544048081606660, precision: 17 },
                { t: 67.079810529494173714, precision: 17 },
                { t: 69.546401711173979252, precision: 17 },
                { t: 72.067157674481907582, precision: 17 },
                { t: 75.704690699083933168, precision: 17 },
                { t: 77.144840068874805224, precision: 17 }
            ];
            
            return allVerifiedZeros.slice(0, Math.min(count, allVerifiedZeros.length));
        }
        
        // Complex number arithmetic utilities
        class Complex {
            constructor(re, im = 0) {
                this.re = re;
                this.im = im;
            }
            
            static fromPolar(r, theta) {
                return new Complex(r * Math.cos(theta), r * Math.sin(theta));
            }
            
            add(z) {
                return new Complex(this.re + z.re, this.im + z.im);
            }
            
            subtract(z) {
                return new Complex(this.re - z.re, this.im - z.im);
            }
            
            multiply(z) {
                if (typeof z === 'number') {
                    return new Complex(this.re * z, this.im * z);
                }
                return new Complex(
                    this.re * z.re - this.im * z.im,
                    this.re * z.im + this.im * z.re
                );
            }
            
            divide(z) {
                if (typeof z === 'number') {
                    return new Complex(this.re / z, this.im / z);
                }
                const denom = z.re * z.re + z.im * z.im;
                return new Complex(
                    (this.re * z.re + this.im * z.im) / denom,
                    (this.im * z.re - this.re * z.im) / denom
                );
            }
            
            conjugate() {
                return new Complex(this.re, -this.im);
            }
            
            abs() {
                return Math.sqrt(this.re * this.re + this.im * this.im);
            }
            
            arg() {
                return Math.atan2(this.im, this.re);
            }
            
            pow(n) {
                if (n === 0) return new Complex(1, 0);
                if (n === 1) return this;
                
                const r = this.abs();
                const theta = this.arg();
                return Complex.fromPolar(Math.pow(r, n), n * theta);
            }
            
            exp() {
                const expRe = Math.exp(this.re);
                return new Complex(expRe * Math.cos(this.im), expRe * Math.sin(this.im));
            }
            
            log() {
                return new Complex(Math.log(this.abs()), this.arg());
            }
            
            toString() {
                const sign = this.im >= 0 ? '+' : '-';
                return `${this.re.toFixed(6)} ${sign} ${Math.abs(this.im).toFixed(6)}i`;
            }
        }
        
        // Enhanced Dirichlet Character with proper implementation
        class DirichletCharacter {
            constructor(modulus, index) {
                this.modulus = modulus;
                this.index = index;
                this.coprimes = getCoprimes(modulus);
                this.phi = this.coprimes.length;
                this.conductor = this.computeConductor();
                this.isPrimitive = (this.conductor === this.modulus);
                this.order = this.computeOrder();
                
                // Build character table
                this.characterTable = this.buildCharacterTable();
            }
            
            // Build complete character table for all residues
            buildCharacterTable() {
                const table = {};
                
                // Character is 0 on non-coprime residues
                for (let a = 0; a < this.modulus; a++) {
                    if (gcd(a, this.modulus) !== 1) {
                        table[a] = new Complex(0, 0);
                    }
                }
                
                // For principal character, all coprimes map to 1
                if (this.index === 0) {
                    this.coprimes.forEach(a => {
                        table[a] = new Complex(1, 0);
                    });
                    return table;
                }
                
                // For non-principal characters, use primitive root structure
                this.coprimes.forEach((a, i) => {
                    const angle = 2 * Math.PI * this.index * i / this.phi;
                    table[a] = new Complex(Math.cos(angle), Math.sin(angle));
                });
                
                return table;
            }
            
            // Get character value œá(n)
            value(n) {
                n = ((n % this.modulus) + this.modulus) % this.modulus;
                return this.characterTable[n] || new Complex(0, 0);
            }
            
            // Compute conductor (smallest modulus for induced character)
            computeConductor() {
                // For simplicity, return modulus (full implementation would check divisors)
                return this.modulus;
            }
            
            // Compute character order
            computeOrder() {
                if (this.index === 0) return 1;
                
                // Find smallest positive integer k such that œá^k = œá_0
                for (let k = 1; k <= this.phi; k++) {
                    if ((this.index * k) % this.phi === 0) {
                        return k;
                    }
                }
                return this.phi;
            }
            
            // Gauss sum: œÑ(œá) = Œ£ œá(a) e^(2œÄia/m)
            gaussSum() {
                let sum = new Complex(0, 0);
                
                for (let a = 0; a < this.modulus; a++) {
                    const chiVal = this.value(a);
                    if (chiVal.abs() > 0) {
                        const angle = 2 * Math.PI * a / this.modulus;
                        const exp = new Complex(Math.cos(angle), Math.sin(angle));
                        sum = sum.add(chiVal.multiply(exp));
                    }
                }
                
                return sum;
            }
            
            // Check if character is even (œá(-1) = 1) or odd (œá(-1) = -1)
            isEven() {
                const chiNegOne = this.value(this.modulus - 1);
                return Math.abs(chiNegOne.re - 1) < 1e-10;
            }
        }
        
        // Advanced L-Function Calculator with Riemann-Siegel formula
        class LFunctionCalculator {
            constructor(character, precision = 1e-10) {
                this.chi = character;
                this.precision = precision;
                this.maxTerms = 50000;
                this.cache = new Map(); // Cache computed values
            }
            
            // Compute L(s, œá) using optimal method based on s
            computeAtPoint(s, options = {}) {
                const sigma = typeof s === 'object' ? s.re : s;
                const t = typeof s === 'object' ? s.im : 0;
                
                const maxTerms = options.maxTerms || this.maxTerms;
                const useRiemannSiegel = options.useRiemannSiegel || (t > 10 && sigma === 0.5);
                
                // Check cache
                const cacheKey = `${sigma.toFixed(6)}_${t.toFixed(6)}_${maxTerms}`;
                if (this.cache.has(cacheKey)) {
                    return this.cache.get(cacheKey);
                }
                
                let result;
                if (useRiemannSiegel && this.chi.index === 0) {
                    // Use Riemann-Siegel formula for Riemann zeta on critical line
                    result = this.computeRiemannSiegel(t);
                } else if (sigma > 1) {
                    // Use Dirichlet series for œÉ > 1
                    result = this.computeDirichletSeries(new Complex(sigma, t), maxTerms);
                } else if (sigma >= 0.5) {
                    // Use Euler-Maclaurin for 0.5 ‚â§ œÉ ‚â§ 1
                    result = this.computeEulerMaclaurin(new Complex(sigma, t), maxTerms);
                } else {
                    // Use functional equation for œÉ < 0.5
                    result = this.computeViaFunctionalEquation(new Complex(sigma, t));
                }
                
                // Cache result
                this.cache.set(cacheKey, result);
                return result;
            }
            
            // Dirichlet series: L(s,œá) = Œ£ œá(n)/n^s
            computeDirichletSeries(s, maxTerms) {
                let sum = new Complex(0, 0);
                let errorBound = 0;
                
                for (let n = 1; n <= maxTerms; n++) {
                    const chiVal = this.chi.value(n);
                    if (chiVal.abs() === 0) continue;
                    
                    // Compute n^(-s)
                    const logN = Math.log(n);
                    const nPowerS = new Complex(-s.re * logN, -s.im * logN).exp();
                    
                    sum = sum.add(chiVal.multiply(nPowerS));
                }
                
                // Error bound using comparison with zeta function
                if (s.re > 1) {
                    errorBound = this.riemannZeta(s.re) / Math.pow(maxTerms, s.re - 1);
                } else {
                    errorBound = 1 / Math.pow(maxTerms, Math.max(0.1, s.re));
                }
                
                return {
                    value: sum,
                    error: errorBound,
                    terms: maxTerms,
                    method: 'Dirichlet Series',
                    converged: errorBound < this.precision
                };
            }
            
            // Riemann-Siegel formula for Œ∂(1/2 + it)
            computeRiemannSiegel(t) {
                const s = new Complex(0.5, t);
                const sqrtT = Math.sqrt(Math.abs(t) / (2 * Math.PI));
                const N = Math.floor(sqrtT);
                
                // Main sum
                let sum = new Complex(0, 0);
                for (let n = 1; n <= N; n++) {
                    const nPowerS = new Complex(-0.5 * Math.log(n), -t * Math.log(n)).exp();
                    sum = sum.add(nPowerS);
                }
                
                // Correction term (simplified)
                const theta = t / 2 * Math.log(t / (2 * Math.PI)) - t / 2 - Math.PI / 8;
                const correction = new Complex(Math.cos(theta), Math.sin(theta))
                    .multiply(Math.pow(sqrtT - N, 2) / 2);
                
                const result = sum.multiply(2).add(correction);
                
                return {
                    value: result,
                    error: 1 / Math.sqrt(Math.abs(t)),
                    terms: N,
                    method: 'Riemann-Siegel',
                    converged: true
                };
            }
            
            // Euler-Maclaurin summation for better convergence
            computeEulerMaclaurin(s, maxTerms) {
                // Start with Dirichlet series
                let sum = new Complex(0, 0);
                const N = maxTerms;
                
                for (let n = 1; n <= N; n++) {
                    const chiVal = this.chi.value(n);
                    if (chiVal.abs() === 0) continue;
                    
                    const logN = Math.log(n);
                    const nPowerS = new Complex(-s.re * logN, -s.im * logN).exp();
                    sum = sum.add(chiVal.multiply(nPowerS));
                }
                
                // Euler-Maclaurin correction (simplified)
                const logN = Math.log(N);
                const NPowerS = new Complex(-s.re * logN, -s.im * logN).exp();
                const correction = NPowerS.divide(s.re - 1).multiply(0.5);
                sum = sum.add(correction);
                
                const errorBound = Math.abs(1 / (Math.pow(N, s.re - 1) * (s.re - 1)));
                
                return {
                    value: sum,
                    error: errorBound,
                    terms: N,
                    method: 'Euler-Maclaurin',
                    converged: errorBound < this.precision
                };
            }
            
            // Functional equation: L(s,œá) ‚Üî L(1-s,œáÃÑ)
            computeViaFunctionalEquation(s) {
                // L(s,œá) = Œµ(œá) * (conductor/œÄ)^(s-1/2) * Œì((1-s+a)/2) / Œì((s+a)/2) * L(1-s,œáÃÑ)
                
                const oneMinusS = new Complex(1, 0).subtract(s);
                const conjugateChar = new DirichletCharacter(this.chi.modulus, -this.chi.index % this.chi.phi);
                
                // Compute L(1-s, œáÃÑ) using Dirichlet series (should converge for Re(1-s) > 1)
                const lOneMinusS = this.computeDirichletSeries(oneMinusS, this.maxTerms);
                
                // Gauss sum factor
                const gauss = this.chi.gaussSum();
                const epsilon = gauss.divide(Math.sqrt(this.chi.modulus));
                
                // Gamma ratio (approximate)
                const a = this.chi.isEven() ? 0 : 1;
                const gammaRatio = this.approximateGammaRatio(s, a);
                
                // Combine factors
                const prefactor = Math.pow(this.chi.conductor / Math.PI, s.re - 0.5);
                const result = epsilon.multiply(gammaRatio).multiply(lOneMinusS.value).multiply(prefactor);
                
                return {
                    value: result,
                    error: lOneMinusS.error * 2, // Propagate error
                    terms: lOneMinusS.terms,
                    method: 'Functional Equation',
                    converged: lOneMinusS.converged
                };
            }
            
            // Approximate Gamma function ratio
            approximateGammaRatio(s, a) {
                // Œì((1-s+a)/2) / Œì((s+a)/2)
                // Using Stirling approximation for large |t|
                
                const arg1 = new Complex((1 - s.re + a) / 2, -s.im / 2);
                const arg2 = new Complex((s.re + a) / 2, s.im / 2);
                
                // log Œì(z) ‚âà (z - 1/2) log z - z + log(‚àö2œÄ)
                const logGamma1 = arg1.subtract(new Complex(0.5, 0)).multiply(arg1.log())
                    .subtract(arg1).add(new Complex(Math.log(Math.sqrt(2 * Math.PI)), 0));
                const logGamma2 = arg2.subtract(new Complex(0.5, 0)).multiply(arg2.log())
                    .subtract(arg2).add(new Complex(Math.log(Math.sqrt(2 * Math.PI)), 0));
                
                return logGamma1.subtract(logGamma2).exp();
            }
            
            // Riemann zeta for real s > 1
            riemannZeta(s) {
                if (s <= 1) return Infinity;
                let sum = 0;
                for (let n = 1; n <= 10000; n++) {
                    sum += Math.pow(n, -s);
                }
                return sum;
            }
            
            // Find zeros on critical line using rigorous algorithm
            findZerosOnCriticalLine(tMin, tMax, options = {}) {
                const step = options.step || 0.5;
                const refineStep = options.refineStep || 0.01;
                const tolerance = options.tolerance || 1e-6;
                
                const zeros = [];
                let prevValue = this.computeAtPoint(new Complex(0.5, tMin));
                let prevArg = Math.atan2(prevValue.value.im, prevValue.value.re);
                
                for (let t = tMin + step; t <= tMax; t += step) {
                    const currentValue = this.computeAtPoint(new Complex(0.5, t));
                    const currentArg = Math.atan2(currentValue.value.im, currentValue.value.re);
                    
                    // Detect argument change indicating zero crossing
                    let argChange = currentArg - prevArg;
                    while (argChange > Math.PI) argChange -= 2 * Math.PI;
                    while (argChange < -Math.PI) argChange += 2 * Math.PI;
                    
                    if (Math.abs(argChange) > Math.PI / 3) {
                        // Potential zero detected, refine
                        const refinedZero = this.refineZero(0.5, t - step / 2, t + step / 2, tolerance);
                        
                        if (refinedZero) {
                            // Verify it's actually a zero
                            const verification = this.computeAtPoint(new Complex(0.5, refinedZero.t));
                            if (verification.value.abs() < 0.1) {
                                zeros.push(refinedZero);
                            }
                        }
                    }
                    
                    prevValue = currentValue;
                    prevArg = currentArg;
                }
                
                return zeros;
            }
            
            // Bisection + Newton refinement for zero finding
            refineZero(sigma, tMin, tMax, tolerance) {
                let left = tMin;
                let right = tMax;
                let iterations = 0;
                const maxIterations = 50;
                
                // Bisection to get close
                while (right - left > tolerance && iterations < maxIterations) {
                    const mid = (left + right) / 2;
                    const fMid = this.computeAtPoint(new Complex(sigma, mid));
                    const fLeft = this.computeAtPoint(new Complex(sigma, left));
                    
                    const midMag = fMid.value.abs();
                    const leftMag = fLeft.value.abs();
                    
                    if (midMag < leftMag) {
                        right = mid;
                    } else {
                        left = mid;
                    }
                    
                    iterations++;
                }
                
                const t = (left + right) / 2;
                
                // Newton refinement
                const h = 0.0001;
                for (let i = 0; i < 10; i++) {
                    const f = this.computeAtPoint(new Complex(sigma, t));
                    const fPlus = this.computeAtPoint(new Complex(sigma, t + h));
                    
                    const derivative = fPlus.value.subtract(f.value).divide(h);
                    const derivativeMag = derivative.abs();
                    
                    if (derivativeMag < 1e-10) break;
                    
                    const correction = f.value.divide(derivative);
                    const newT = t - correction.re;
                    
                    if (Math.abs(correction.re) < tolerance) {
                        return {
                            t: newT,
                            sigma: sigma,
                            residual: f.value.abs(),
                            iterations: i + 1,
                            verified: true
                        };
                    }
                }
                
                return {
                    t: t,
                    sigma: sigma,
                    residual: this.computeAtPoint(new Complex(sigma, t)).value.abs(),
                    iterations: iterations,
                    verified: false
                };
            }
            
            // Compute Euler product: L(s,œá) = ‚àè_p (1 - œá(p)/p^s)^(-1)
            computeEulerProduct(s, maxPrime = 1000) {
                let product = new Complex(1, 0);
                
                // Generate primes up to maxPrime
                const primes = sieveOfEratosthenes(maxPrime);
                
                for (const p of primes) {
                    const chiP = this.chi.value(p);
                    if (chiP.abs() === 0) continue;
                    
                    // Compute p^(-s)
                    const logP = Math.log(p);
                    const pPowerS = new Complex(-s.re * logP, -s.im * logP).exp();
                    
                    // (1 - œá(p)/p^s)^(-1)
                    const term = new Complex(1, 0).subtract(chiP.multiply(pPowerS));
                    product = product.divide(term);
                }
                
                return {
                    value: product,
                    primesUsed: primes.length,
                    maxPrime: maxPrime
                };
            }
            
            // Clear computation cache
            clearCache() {
                this.cache.clear();
            }
        }
        
        function updateLFunctionVisualization() {
            const canvas = document.getElementById('lFunctionCanvas');
            if (!canvas || !document.getElementById('showLFunction')?.checked) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '16px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Select Rings', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(40, centerY);
            ctx.lineTo(canvas.width - 10, centerY);
            ctx.moveTo(40, 10);
            ctx.lineTo(40, canvas.height - 10);
            ctx.stroke();
            
            // Get L-function parameters
            const lFunctionType = document.getElementById('lFunctionType').value;
            const tMin = parseFloat(document.getElementById('lFunctionTMin')?.value || 0);
            const tMax = parseFloat(document.getElementById('lFunctionTMax')?.value || 30);
            const seriesTerms = parseInt(document.getElementById('lFunctionSeriesTerms')?.value || 5000);
            const showErrorBounds = document.getElementById('lFunctionShowErrorBounds')?.checked;
            const showEulerProduct = document.getElementById('lFunctionShowEulerProduct')?.checked;
            
            const tScale = (canvas.width - 50) / tMax;
            const yScale = (canvas.height - 20) / 3;
            
            // Compute L-function based on type
            if (lFunctionType === 'riemann') {
                // Riemann zeta function Œ∂(s)
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                
                let firstPoint = true;
                let maxError = 0;
                
                for (let t = 0.1; t <= tMax; t += 0.3) {
                    // Compute Œ∂(1/2 + it) using Dirichlet series
                    let sumRe = 0, sumIm = 0;
                    const sigma = 0.5;
                    
                    for (let n = 1; n <= seriesTerms; n++) {
                        const nPowerSigma = Math.pow(n, -sigma);
                        const angle = -t * Math.log(n);
                        sumRe += nPowerSigma * Math.cos(angle);
                        sumIm += nPowerSigma * Math.sin(angle);
                    }
                    
                    const magnitude = Math.sqrt(sumRe * sumRe + sumIm * sumIm);
                    const error = 1 / Math.pow(seriesTerms, sigma - 0.1);
                    maxError = Math.max(maxError, error);
                    
                    const x = 40 + t * tScale;
                    const y = centerY - magnitude * yScale;
                    
                    if (firstPoint) {
                        ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Draw title
                ctx.fillStyle = '#FFD700';
                ctx.font = '14px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('|Œ∂(1/2 + it)| [Riemann Zeta]', canvas.width / 2, 20);
                
                if (showErrorBounds) {
                    ctx.fillStyle = '#4ECDC4';
                    ctx.font = '11px Segoe UI';
                    ctx.fillText(`Error bound: Œµ ‚â§ ${maxError.toExponential(2)}`, canvas.width / 2, 35);
                }
                
            } else if (lFunctionType === 'dirichlet') {
                // Dirichlet L-function L(s, œá)
                const modulus = parseInt(document.getElementById('lFunctionModulus')?.value || 30);
                const charIndex = parseInt(document.getElementById('lFunctionCharIndex')?.value || 0);
                
                // Plot up to 3 different characters for comparison
                const charactersToPlot = Math.min(3, selectedRings.length);
                
                for (let charIdx = 0; charIdx < charactersToPlot; charIdx++) {
                    const chi = new DirichletCharacter(modulus, charIdx);
                    const calculator = new LFunctionCalculator(chi);
                    
                    const hue = (charIdx * 120) % 360;
                    ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.8)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    let firstPoint = true;
                    let maxError = 0;
                    
                    for (let t = 0.1; t <= tMax; t += 0.3) {
                        const result = calculator.computeAtPoint({ re: 0.5, im: t }, seriesTerms);
                        const magnitude = Math.sqrt(result.value.re ** 2 + result.value.im ** 2);
                        maxError = Math.max(maxError, result.error);
                        
                        const x = 40 + t * tScale;
                        const y = centerY - magnitude * yScale;
                        
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    
                    // Error bars if enabled
                    if (showErrorBounds) {
                        ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.3)`;
                        ctx.lineWidth = 1;
                        ctx.setLineDash([2, 2]);
                        for (let t = 5; t <= tMax; t += 5) {
                            const result = calculator.computeAtPoint({ re: 0.5, im: t }, seriesTerms);
                            const magnitude = Math.sqrt(result.value.re ** 2 + result.value.im ** 2);
                            const x = 40 + t * tScale;
                            const y = centerY - magnitude * yScale;
                            const errorY = result.error * yScale;
                            
                            ctx.beginPath();
                            ctx.moveTo(x, y - errorY);
                            ctx.lineTo(x, y + errorY);
                            ctx.stroke();
                        }
                        ctx.setLineDash([]);
                    }
                    
                    // Legend with error
                    ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.8)`;
                    ctx.font = '10px Segoe UI';
                    ctx.textAlign = 'left';
                    const charName = charIdx === 0 ? 'œá‚ÇÄ (principal)' : `œá${charIdx}`;
                    ctx.fillText(`M=${modulus}, ${charName} (Œµ‚â§${maxError.toExponential(1)})`, 50, 30 + charIdx * 15);
                }
                
                // Title
                ctx.fillStyle = '#FFD700';
                ctx.font = '14px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(`|L(1/2 + it, œá)| mod ${modulus} [${seriesTerms} terms]`, canvas.width / 2, 15);
                
            } else if (lFunctionType === 'hasse-weil') {
                // Hasse-Weil L-function (simplified representation)
                const curve = document.getElementById('ellipticCurveChoice')?.value || '11a';
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(`Hasse-Weil L(E,s) for curve ${curve}`, canvas.width / 2, canvas.height / 2 - 20);
                ctx.font = '12px Segoe UI';
                ctx.fillText('(Full computation requires elliptic curve data)', canvas.width / 2, canvas.height / 2 + 5);
                ctx.fillText('Enable Dirichlet mode for detailed analysis', canvas.width / 2, canvas.height / 2 + 25);
            }
            
            // Axis labels
            ctx.fillStyle = '#ffffff';
            ctx.font = '11px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('t (imaginary part)', canvas.width - 20, centerY - 10);
            
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('|L|', 0, 0);
            ctx.restore();
            
            // Show Euler product info if enabled
            if (showEulerProduct && lFunctionType !== 'hasse-weil') {
                ctx.fillStyle = 'rgba(72, 187, 120, 0.9)';
                ctx.font = '10px Segoe UI';
                ctx.textAlign = 'right';
                if (lFunctionType === 'riemann') {
                    ctx.fillText('Euler: Œ∂(s) = ‚àè‚Çö 1/(1-p‚ÅªÀ¢)', canvas.width - 10, canvas.height - 25);
                } else {
                    ctx.fillText('Euler: L(s,œá) = ‚àè‚Çö 1/(1-œá(p)p‚ÅªÀ¢)', canvas.width - 10, canvas.height - 25);
                }
            }
        }

        function exportRhData() {
            const selectedRings = getSelectedRings();
            let exportData = {
                timestamp: new Date().toISOString(),
                riemannHypothesisAnalysis: {
                    selectedModuli: selectedRings.map(id => configs[id]?.mod).filter(Boolean),
                    characterSupport: {},
                    primeDistribution: primeData.isActive ? primeData : null
                }
            };
            
            selectedRings.forEach(ringId => {
                const config = configs[ringId];
                if (config) {
                    const coprimes = getCoprimes(config.mod);
                    exportData.riemannHypothesisAnalysis.characterSupport[config.mod] = {
                        eulerTotient: coprimes.length,
                        supportResidues: coprimes,
                        supportDensity: coprimes.length / config.mod
                    };
                }
            });
            
            const dataBlob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `riemann_hypothesis_analysis_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            updateAnimationStatus('RH research data exported');
        }

        function runFullGrhSuite() {
            updateAnimationStatus('Running complete GRH analysis suite...');
            
            setTimeout(() => {
                const selectedRings = getSelectedRings();
                let results = [];
                
                selectedRings.forEach(ringId => {
                    const config = configs[ringId];
                    if (config && config.mod > 1) {
                        const analysis = analyzePrimeEquidistribution(config.mod);
                        results.push({
                            modulus: config.mod,
                            uniformityScore: analysis.uniformityScore,
                            grhPrediction: analysis.grhPrediction
                        });
                    }
                });
                
                // Update RH predictions with suite results
                const rhPredictions = document.getElementById('rhPredictions');
                let html = '<div class="rh-info"><strong>Complete GRH Analysis Suite Results:</strong><br>';
                
                results.forEach(result => {
                    const scoreColor = result.uniformityScore > 0.9 ? '#48BB78' : 
                                     result.uniformityScore > 0.8 ? '#FFD700' : '#FF6B6B';
                    html += `‚Ä¢ M${result.modulus}: ${(result.uniformityScore * 100).toFixed(1)}% uniformity `;
                    html += `<span style="color: ${scoreColor}">(${result.grhPrediction})</span><br>`;
                });
                
                const avgUniformity = results.reduce((sum, r) => sum + r.uniformityScore, 0) / results.length;
                html += `<br><strong>Overall Suite Score: ${(avgUniformity * 100).toFixed(1)}%</strong><br>`;
                html += `<em>Complete analysis across ${results.length} moduli completed</em></div>`;
                
                rhPredictions.innerHTML = html;
                updateRhVisualizations();
                updateAnimationStatus('Complete GRH suite analysis finished');
            }, 1000);
        }
        // L-Function parameter management
        function updateLFunctionParams() {
            const lFunctionType = document.getElementById('lFunctionType');
            const dirichletParams = document.getElementById('dirichletParams');
            const hasseWeilParams = document.getElementById('hasseWeilParams');
            const currentDesc = document.getElementById('lFunctionCurrentDesc');
            
            if (!lFunctionType || !currentDesc) return;
            
            // Show/hide relevant parameter sections
            if (lFunctionType.value === 'dirichlet') {
                if (dirichletParams) dirichletParams.style.display = 'block';
                if (hasseWeilParams) hasseWeilParams.style.display = 'none';
                
                const modInput = document.getElementById('lFunctionModulus');
                const charInput = document.getElementById('lFunctionCharIndex');
                const mod = modInput ? modInput.value : '30';
                const charIndex = charInput ? charInput.value : '0';
                
                if (charIndex == 0) {
                    currentDesc.textContent = `L(s,œá‚ÇÄ) with œá‚ÇÄ mod ${mod} (principal character)`;
                } else {
                    currentDesc.textContent = `L(s,œá) with œá mod ${mod}, index ${charIndex}`;
                }
            } else if (lFunctionType.value === 'riemann') {
                if (dirichletParams) dirichletParams.style.display = 'none';
                if (hasseWeilParams) hasseWeilParams.style.display = 'none';
                currentDesc.textContent = 'Œ∂(s) = Œ£(n=1 to ‚àû) 1/nÀ¢ (Riemann zeta function)';
            } else if (lFunctionType.value === 'hasse-weil') {
                if (dirichletParams) dirichletParams.style.display = 'none';
                if (hasseWeilParams) hasseWeilParams.style.display = 'block';
                
                const curveInput = document.getElementById('ellipticCurveChoice');
                const curve = curveInput ? curveInput.value : '11a';
                currentDesc.textContent = `L(E,s) for elliptic curve ${curve}`;
            }
        }
        
        // Color invert function
        function toggleColorInvert() {
            colorInverted = document.getElementById('enableColorInvert').checked;
            
            if (colorInverted) {
                // Apply CSS filter to invert main canvas
                canvas.style.filter = 'invert(1) hue-rotate(180deg)';
                updateAnimationStatus('Color inversion enabled');
            } else {
                canvas.style.filter = 'none';
                updateAnimationStatus('Color inversion disabled');
            }
            
            draw();
        }
        
        // RH visualization toggle function
        function toggleRhVisualization(canvasId) {
            const canvas = document.getElementById(canvasId);
            const container = canvas?.parentElement;
            
            if (!container) return;
            
            const checkboxId = canvasId.replace('Canvas', '');
            const isVisible = document.getElementById('show' + checkboxId.charAt(0).toUpperCase() + checkboxId.slice(1))?.checked;
            
            if (isVisible) {
                container.style.display = 'block';
                // Redraw the specific visualization
                updateRhVisualizations();
            } else {
                container.style.display = 'none';
            }
        }
        
        // ========================================
        // DISTANCE MEASUREMENT FUNCTIONS
        // ========================================
        
        function handleDistanceMeasurementClick(screenX, screenY) {
            if (!distanceMeasurementActive) return;
            
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) return;
            
            const centerX = canvas.width / 2 + panX;
            const centerY = canvas.height / 2 + panY;
            const rotation = parseFloat(document.getElementById('rotationSlider').value);
            const enableRotation = document.getElementById('enableRotation').checked;
            
            const dx = (screenX - centerX) / currentZoom;
            const dy = (screenY - centerY) / currentZoom;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            const ringConfigs = selectedRings.map(function(ringId, originalIndex) {
                return {
                    ringId: ringId,
                    originalIndex: originalIndex,
                    modulus: configs[ringId] ? configs[ringId].mod : 1
                };
            });
            
            ringConfigs.sort(function(a, b) {
                if (a.ringId === 'unit') return -1;
                if (b.ringId === 'unit') return 1;
                return a.modulus - b.modulus;
            });
            
            const sortedRings = ringConfigs.map(function(config, sortedIndex) {
                const normalPos = sortedIndex;
                const invertedPos = ringConfigs.length - 1 - sortedIndex;
                const finalPos = normalPos * (1 - nestingInversionAmount) + invertedPos * nestingInversionAmount;
                config.finalIndex = finalPos;
                return config;
            });
            
            sortedRings.sort(function(a, b) {
                return a.finalIndex - b.finalIndex;
            });
            
            let foundResidue = null;
            let minDistance = Infinity;
            
            sortedRings.forEach(function(config, visualIndex) {
                const modulus = config.modulus;
                const radius = calculateRadius(modulus, visualIndex, sortedRings.length);
                
                if (Math.abs(dist - radius) < 20) {
                    const allResidues = getAllResidues(modulus);
                    
                    let ringRotation = 0;
                    if (enableRotation) {
                        ringRotation = animationFrame * ringRotationSpeeds[config.ringId] * Math.PI / 180;
                    }
                    
                    allResidues.forEach(function(r) {
                        let baseAngle;
                        if (config.ringId === 'unit') {
                            baseAngle = 0;
                        } else {
                            baseAngle = 2 * Math.PI * (modulus - r) / modulus;
                        }
                        
                        const angle = baseAngle + ringRotation;
                        const rx = radius * Math.cos(angle);
                        const ry = radius * Math.sin(angle);
                        
                        const rdist = Math.sqrt((dx - rx) * (dx - rx) + (dy - ry) * (dy - ry));
                        
                        if (rdist < 15 && rdist < minDistance) {
                            minDistance = rdist;
                            foundResidue = {
                                residue: r,
                                modulus: modulus,
                                radius: radius,
                                angle: angle,
                                ringId: config.ringId,
                                isGcdOne: gcd(r, Math.round(modulus)) === 1
                            };
                        }
                    });
                }
            });
            
            if (foundResidue) {
                if (!selectedPoint1) {
                    selectedPoint1 = foundResidue;
                    updateDistanceDisplay('Point 1 selected', foundResidue);
                    updateAnimationStatus('Point 1: r=' + foundResidue.residue + ' on M=' + Math.round(foundResidue.modulus));
                    draw();
                } else if (!selectedPoint2) {
                    selectedPoint2 = foundResidue;
                    
                    const distResult = calculateEuclideanDistance(selectedPoint1, selectedPoint2);
                    displayDistanceResults(distResult);
                    updateAnimationStatus('Distance: ' + distResult.euclidean.toFixed(6) + ' units');
                    draw();
                }
            }
        }
        
        function updateDistanceDisplay(status, point) {
            const display = document.getElementById('distanceDisplay');
            
            if (!point) {
                display.innerHTML = '<strong>' + status + '</strong>';
                return;
            }
            
            const gcdVal = gcd(point.residue, Math.round(point.modulus));
            const supportText = point.isGcdOne ? '<span style="color: #4ECDC4;">‚úì Character Support (œá‚â†0)</span>' : '<span style="color: #666;">œá=0</span>';
            
            display.innerHTML = '<strong>' + status + '</strong><br>' +
                'Ring: M = ' + Math.round(point.modulus) + '<br>' +
                'Residue: r = ' + point.residue + '<br>' +
                'GCD(r,M) = ' + gcdVal + '<br>' +
                supportText;
        }
        
        function displayDistanceResults(dist) {
            const display = document.getElementById('distanceDisplay');
            
            const diff = Math.abs(dist.euclidean - dist.lawOfCosines).toExponential(3);
            
            display.innerHTML = '<strong>Distance Measurement Complete!</strong><br><br>' +
                '<strong>Point 1:</strong> r=' + selectedPoint1.residue + ', M=' + Math.round(selectedPoint1.modulus) + '<br>' +
                '<strong>Point 2:</strong> r=' + selectedPoint2.residue + ', M=' + Math.round(selectedPoint2.modulus) + '<br><br>' +
                '<strong style="color: #FFD700;">Euclidean Distance:</strong><br>' +
                'd = ' + dist.euclidean.toFixed(6) + ' units<br><br>' +
                '<strong>Verification (Law of Cosines):</strong><br>' +
                'd = ' + dist.lawOfCosines.toFixed(6) + ' units<br><br>' +
                '<em style="font-size: 11px;">Difference: ' + diff + '</em><br>' +
                '<em style="font-size: 11px;">(Should be near machine precision)</em>';
        }
        
        function drawSelectedPoints() {
            if (!distanceMeasurementActive) return;
            
            ctx.save();
            
            if (selectedPoint1) {
                const x1 = selectedPoint1.radius * Math.cos(selectedPoint1.angle);
                const y1 = selectedPoint1.radius * Math.sin(selectedPoint1.angle);
                
                ctx.beginPath();
                ctx.arc(x1, y1, 12, 0, 2 * Math.PI);
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(x1, y1, 8, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.fill();
            }
            
            if (selectedPoint2) {
                const x2 = selectedPoint2.radius * Math.cos(selectedPoint2.angle);
                const y2 = selectedPoint2.radius * Math.sin(selectedPoint2.angle);
                
                ctx.beginPath();
                ctx.arc(x2, y2, 12, 0, 2 * Math.PI);
                ctx.strokeStyle = '#4ECDC4';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(x2, y2, 8, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(78, 205, 196, 0.3)';
                ctx.fill();
                
                if (selectedPoint1) {
                    const x1 = selectedPoint1.radius * Math.cos(selectedPoint1.angle);
                    const y1 = selectedPoint1.radius * Math.sin(selectedPoint1.angle);
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            ctx.restore();
        }
        
        // ========================================
        // END DISTANCE MEASUREMENT FUNCTIONS
        // ========================================
        
        function updateCoordinateSystem() {
            coordinateSystem = document.getElementById('coordinateSystem').value;
            updateCoordSystemDescription();
            updateCoordinateParams();
            updateAnimationStatus(`Coordinate system: ${coordinateSystem}`);
            draw();
        }
        
        function updateCoordSystemDescription() {
            const descriptions = {
                'polar': 'Traditional polar coordinates with concentric rings. Radius r from center, angle Œ∏ around circle.',
                'log-cylinder': 'Log-cylinder: u = ln(m), v = Œ∏ = 2œÄr/m. Transforms multiplicative structure into additive patterns.',
                'spiral': 'Logarithmic spiral: radius grows exponentially with angle. r = a¬∑e^(bŒ∏), revealing self-similar structure.',
                'hyperbolic': 'Hyperbolic/Poincar√© disk: models non-Euclidean geometry. Preserves angles, distorts distances near boundary.',
                'rectangular': 'Rectangular grid arrangement: rows and columns based on modulus properties.',
                'treemap': 'Treemap packing: hierarchical rectangles sized by œÜ(m). Space-filling visualization.',
                'voronoi': 'Voronoi tessellation: each point owns nearest region. Natural partition of plane.',
                'fractal': 'Fractal self-similar: recursive subdivision revealing multiplicative structure at all scales.'
            };
            
            document.getElementById('coordSystemDesc').textContent = descriptions[coordinateSystem] || '';
        }
        
        function updateCoordinateParams() {
            const paramsDiv = document.getElementById('coordinateParams');
            let html = '';
            
            switch(coordinateSystem) {
                case 'log-cylinder':
                    html = `
                        <div class="slider-group">
                            <label>U-axis Scale (ln m): <span id="uScaleValue">1.0</span></label>
                            <input type="range" id="uScale" min="0.1" max="3" step="0.1" value="1.0" oninput="updateLogCylinderParams()">
                        </div>
                        <div class="slider-group">
                            <label>V-axis Scale (Œ∏): <span id="vScaleValue">1.0</span></label>
                            <input type="range" id="vScale" min="0.1" max="3" step="0.1" value="1.0" oninput="updateLogCylinderParams()">
                        </div>
                    `;
                    break;
                    
                case 'spiral':
                    html = `
                        <div class="slider-group">
                            <label>Spiral Growth Rate: <span id="spiralGrowthValue">0.3</span></label>
                            <input type="range" id="spiralGrowth" min="0.1" max="1.0" step="0.05" value="0.3" oninput="updateSpiralParams()">
                        </div>
                        <div class="slider-group">
                            <label>Spiral Tightness: <span id="spiralTightnessValue">0.5</span></label>
                            <input type="range" id="spiralTightness" min="0.1" max="2.0" step="0.1" value="0.5" oninput="updateSpiralParams()">
                        </div>
                    `;
                    break;
                    
                case 'hyperbolic':
                    html = `
                        <div class="slider-group">
                            <label>Hyperbolic Curvature: <span id="curvatureValue">1.0</span></label>
                            <input type="range" id="curvature" min="0.1" max="3.0" step="0.1" value="1.0" oninput="updateHyperbolicParams()">
                        </div>
                    `;
                    break;
                    
                case 'rectangular':
                    html = `
                        <div class="slider-group">
                            <label>Cell Size: <span id="cellSizeValue">50</span>px</label>
                            <input type="range" id="cellSize" min="20" max="100" step="5" value="50" oninput="updateRectangularParams()">
                        </div>
                        <div class="slider-group">
                            <label>Arrangement:</label>
                            <select id="rectArrangement" onchange="updateRectangularParams()">
                                <option value="totient">By œÜ(m)</option>
                                <option value="sequential">Sequential</option>
                                <option value="prime">Prime factorization</option>
                            </select>
                        </div>
                    `;
                    break;
            }
            
            paramsDiv.innerHTML = html;
        }
        
        function updateLogCylinderParams() {
            coordSystemParams.logCylinder.uScale = parseFloat(document.getElementById('uScale').value);
            coordSystemParams.logCylinder.vScale = parseFloat(document.getElementById('vScale').value);
            document.getElementById('uScaleValue').textContent = coordSystemParams.logCylinder.uScale.toFixed(1);
            document.getElementById('vScaleValue').textContent = coordSystemParams.logCylinder.vScale.toFixed(1);
            draw();
        }
        
        function updateSpiralParams() {
            coordSystemParams.spiral.growth = parseFloat(document.getElementById('spiralGrowth').value);
            coordSystemParams.spiral.tightness = parseFloat(document.getElementById('spiralTightness').value);
            document.getElementById('spiralGrowthValue').textContent = coordSystemParams.spiral.growth.toFixed(2);
            document.getElementById('spiralTightnessValue').textContent = coordSystemParams.spiral.tightness.toFixed(1);
            draw();
        }
        
        function updateHyperbolicParams() {
            coordSystemParams.hyperbolic.curvature = parseFloat(document.getElementById('curvature').value);
            document.getElementById('curvatureValue').textContent = coordSystemParams.hyperbolic.curvature.toFixed(1);
            draw();
        }
        
        function updateRectangularParams() {
            if (document.getElementById('cellSize')) {
                coordSystemParams.rectangular.cellSize = parseFloat(document.getElementById('cellSize').value);
                document.getElementById('cellSizeValue').textContent = coordSystemParams.rectangular.cellSize.toFixed(0);
            }
            if (document.getElementById('rectArrangement')) {
                coordSystemParams.rectangular.arrangement = document.getElementById('rectArrangement').value;
            }
            draw();
        }
        
        // Coordinate transformation functions
        function transformCoordinates(modulus, residue, ringIndex, totalRings) {
            const baseRadius = calculateRadius(modulus, ringIndex, totalRings);
            let baseAngle;
            
            if (modulus === 1) {
                baseAngle = 0;
            } else {
                baseAngle = 2 * Math.PI * (modulus - residue) / modulus;
            }
            
            // Apply rotation
            const rotation = parseFloat(document.getElementById('rotationSlider').value) * Math.PI / 180;
            const enableRotation = document.getElementById('enableRotation').checked;
            let angle = baseAngle;
            
            if (enableRotation) {
                const ringId = 'ring_' + ringIndex;
                if (!ringRotationSpeeds[ringId]) {
                    ringRotationSpeeds[ringId] = Math.max(0.3, 2.5 - Math.log10(modulus + 1));
                }
                angle += animationFrame * ringRotationSpeeds[ringId] * Math.PI / 180;
            } else {
                angle += rotation;
            }
            
            // Base 2D coordinates
            let x, y, displayAngle;
            
            // Check if Smith Chart transform is enabled
            if (smithChartEnabled) {
                // Compute Œ∏_k,r = 2œÄr/M_k + Œ±
                const theta = (2 * Math.PI * residue / modulus) + smithAlpha;
                
                // Get radius R_k based on mode
                const R = getSmithRadius(ringIndex, totalRings, modulus);
                
                // z_k,r = R_k * e^(iŒ∏_k,r)
                const z = {
                    re: R * Math.cos(theta),
                    im: R * Math.sin(theta)
                };
                
                // Apply Cayley transform: Œì = (z - 1)/(z + 1)
                let gamma;
                if (smithRadiusMode === 'unit') {
                    // Use special case formula for R=1
                    gamma = cayleyTransformUnit(theta);
                } else {
                    // Use general formula
                    gamma = cayleyTransformDirect(R, theta);
                }
                
                // Scale to fit canvas (map unit disk to display radius)
                const smithScale = 250; // Display radius for Smith chart
                x = gamma.re * smithScale;
                y = gamma.im * smithScale;
                displayAngle = Math.atan2(gamma.im, gamma.re);
                
                return {x, y, z: 0, displayAngle};
            }
            
            // Original coordinate systems (non-Smith)
            switch(coordinateSystem) {
                case 'polar':
                    x = baseRadius * Math.cos(angle);
                    y = baseRadius * Math.sin(angle);
                    displayAngle = angle;
                    break;
                    
                case 'log-cylinder':
                    const u = Math.log(modulus) * coordSystemParams.logCylinder.uScale * 80;
                    const v = (residue / modulus) * coordSystemParams.logCylinder.vScale * 100 - 50;
                    x = u - 150;
                    y = v;
                    displayAngle = (residue / modulus) * 2 * Math.PI;
                    break;
                    
                case 'spiral':
                    const a = 10;
                    const b = coordSystemParams.spiral.growth;
                    const spiralAngle = angle + ringIndex * coordSystemParams.spiral.tightness;
                    const spiralRadius = a * Math.exp(b * spiralAngle);
                    x = spiralRadius * Math.cos(spiralAngle);
                    y = spiralRadius * Math.sin(spiralAngle);
                    displayAngle = spiralAngle;
                    break;
                    
                case 'hyperbolic':
                    const k = coordSystemParams.hyperbolic.curvature;
                    const r_normalized = baseRadius / 300;
                    const hyperbolic_r = Math.tanh(r_normalized * k) * 250;
                    x = hyperbolic_r * Math.cos(angle);
                    y = hyperbolic_r * Math.sin(angle);
                    displayAngle = angle;
                    break;
                    
                case 'rectangular':
                    const cellSize = coordSystemParams.rectangular.cellSize;
                    const cols = Math.ceil(Math.sqrt(totalRings));
                    const row = Math.floor(ringIndex / cols);
                    const col = ringIndex % cols;
                    const cellAngle = (residue / modulus) * 2 * Math.PI;
                    const cellRadius = cellSize * 0.4;
                    x = (col - cols/2) * cellSize + cellRadius * Math.cos(cellAngle);
                    y = (row - cols/2) * cellSize + cellRadius * Math.sin(cellAngle);
                    displayAngle = cellAngle;
                    break;
                    
                default:
                    x = baseRadius * Math.cos(angle);
                    y = baseRadius * Math.sin(angle);
                    displayAngle = angle;
            }
            
            return {x, y, z: 0, displayAngle};
        }

        function gcd(a, b) {
            while (b !== 0) {
                let temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }
        
        // ========================================
        // DISTANCE MEASUREMENT FUNCTIONS
        // ========================================
        
        // Manual point selection functions
        function selectPoint1Manual() {
            const residue = parseInt(document.getElementById('point1Residue').value);
            const modulus = parseInt(document.getElementById('point1Modulus').value);
            
            if (isNaN(residue) || isNaN(modulus) || modulus < 1) {
                alert('Please enter valid numbers for residue and modulus');
                return;
            }
            
            if (residue < 0 || residue >= modulus) {
                alert(`Residue must be between 0 and ${modulus - 1} for modulus ${modulus}`);
                return;
            }
            
            // Get all rings (selected or not) to calculate position
            const allRingConfigs = [];
            
            // Add unit circle
            allRingConfigs.push({ ringId: 'unit', modulus: 1 });
            
            // Add all possible moduli up to a reasonable range
            for (let m = 2; m <= 1000; m++) {
                allRingConfigs.push({ ringId: `virtual_${m}`, modulus: m });
            }
            
            // Sort by modulus
            allRingConfigs.sort((a, b) => a.modulus - b.modulus);
            
            // Find this modulus in the list
            const ringIndex = allRingConfigs.findIndex(rc => rc.modulus === modulus);
            
            if (ringIndex === -1) {
                alert('Error calculating ring position');
                return;
            }
            
            // Use current radius scaling settings
            const radius = calculateRadius(modulus, ringIndex, allRingConfigs.length);
            
            // Calculate angle using correct formula
            let baseAngle;
            if (modulus === 1) {
                baseAngle = 0;
            } else {
                baseAngle = 2 * Math.PI * (modulus - residue) / modulus;
            }
            
            // Apply current rotation
            const rotation = parseFloat(document.getElementById('rotationSlider').value) * Math.PI / 180;
            const angle = baseAngle + rotation;
            
            selectedPoint1 = {
                residue: residue,
                modulus: modulus,
                radius: radius,
                angle: angle,
                ringId: modulus === 1 ? 'unit' : `virtual_${modulus}`,
                isGcdOne: gcd(residue, modulus) === 1
            };
            
            updatePointStatus('point1Status', selectedPoint1);
            
            if (selectedPoint2) {
                const distResult = calculateEuclideanDistance(selectedPoint1, selectedPoint2);
                displayDistanceResults(distResult);
            }
            
            draw();
            updateAnimationStatus(`Point 1 selected: r=${residue} mod ${modulus}`);
        }
        
        function selectPoint2Manual() {
            const residue = parseInt(document.getElementById('point2Residue').value);
            const modulus = parseInt(document.getElementById('point2Modulus').value);
            
            if (isNaN(residue) || isNaN(modulus) || modulus < 1) {
                alert('Please enter valid numbers for residue and modulus');
                return;
            }
            
            if (residue < 0 || residue >= modulus) {
                alert(`Residue must be between 0 and ${modulus - 1} for modulus ${modulus}`);
                return;
            }
            
            // Get all rings (selected or not) to calculate position
            const allRingConfigs = [];
            
            // Add unit circle
            allRingConfigs.push({ ringId: 'unit', modulus: 1 });
            
            // Add all possible moduli up to a reasonable range
            for (let m = 2; m <= 1000; m++) {
                allRingConfigs.push({ ringId: `virtual_${m}`, modulus: m });
            }
            
            // Sort by modulus
            allRingConfigs.sort((a, b) => a.modulus - b.modulus);
            
            // Find this modulus in the list
            const ringIndex = allRingConfigs.findIndex(rc => rc.modulus === modulus);
            
            if (ringIndex === -1) {
                alert('Error calculating ring position');
                return;
            }
            
            // Use current radius scaling settings
            const radius = calculateRadius(modulus, ringIndex, allRingConfigs.length);
            
            // Calculate angle using correct formula
            let baseAngle;
            if (modulus === 1) {
                baseAngle = 0;
            } else {
                baseAngle = 2 * Math.PI * (modulus - residue) / modulus;
            }
            
            // Apply current rotation
            const rotation = parseFloat(document.getElementById('rotationSlider').value) * Math.PI / 180;
            const angle = baseAngle + rotation;
            
            selectedPoint2 = {
                residue: residue,
                modulus: modulus,
                radius: radius,
                angle: angle,
                ringId: modulus === 1 ? 'unit' : `virtual_${modulus}`,
                isGcdOne: gcd(residue, modulus) === 1
            };
            
            updatePointStatus('point2Status', selectedPoint2);
            
            if (selectedPoint1) {
                const distResult = calculateEuclideanDistance(selectedPoint1, selectedPoint2);
                displayDistanceResults(distResult);
            }
            
            draw();
            updateAnimationStatus(`Point 2 selected: r=${residue} mod ${modulus}`);
        }
        
        function updatePointStatus(statusId, point) {
            const gcdVal = gcd(point.residue, point.modulus);
            const supportText = point.isGcdOne ? '<span style="color: #4ECDC4;">‚úì œá(r)‚â†0</span>' : '<span style="color: #666;">œá(r)=0</span>';
            
            // Get current label format
            const labelFormat = document.getElementById('labelFormat')?.value || 'number';
            let labelText = formatLabel(point.residue, point.modulus, { modulus: point.modulus });
            
            // Get current radius scaling info
            const scalingMode = radiusScalingMode;
            const scalingModes = {
                'uniform': 'Uniform spacing',
                'linear': 'Linear r(m) = c¬∑m',
                'sqrt': 'Square-root r(m) = c¬∑‚àöm',
                'log': 'Logarithmic r(m) = c¬∑log(m)',
                'totient': 'Totient r(m) = c¬∑œÜ(m)',
                'density': 'Density r(m) = c¬∑œÜ(m)/m',
                'inverse': 'Inverse r(m) = c/m',
                'exponential': 'Exponential r(m) = c¬∑a·µê'
            };
            
            const status = document.getElementById(statusId);
            status.innerHTML = `
                <strong>Selected:</strong> r = ${point.residue}, M = ${point.modulus}<br>
                <strong>Label:</strong> ${labelText}<br>
                GCD(${point.residue}, ${point.modulus}) = ${gcdVal} ${supportText}<br>
                <strong>Radius:</strong> ${point.radius.toFixed(2)} units<br>
                <em style="font-size: 10px; opacity: 0.8;">${scalingModes[scalingMode]}</em>
            `;
        }
        
        function calculateEuclideanDistance(point1, point2) {
            // General distance formula: d = ‚àö[r‚ÇÅ¬≤ - 2r‚ÇÅr_m cos(2œÄk/m) + r_m¬≤]
            // But for any two points, use standard Euclidean distance
            
            const r1 = point1.radius;
            const r2 = point2.radius;
            const theta1 = point1.angle;
            const theta2 = point2.angle;
            
            // Convert to Cartesian coordinates
            const x1 = r1 * Math.cos(theta1);
            const y1 = r1 * Math.sin(theta1);
            const x2 = r2 * Math.cos(theta2);
            const y2 = r2 * Math.sin(theta2);
            
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            
            // Also calculate using the law of cosines for verification
            const angleDiff = Math.abs(theta2 - theta1);
            const distanceLawOfCosines = Math.sqrt(r1**2 + r2**2 - 2*r1*r2*Math.cos(angleDiff));
            
            return {
                euclidean: distance,
                lawOfCosines: distanceLawOfCosines,
                cartesian: { x1, y1, x2, y2 },
                polar: { r1, theta1: theta1 * 180/Math.PI, r2, theta2: theta2 * 180/Math.PI }
            };
        }
        
        function toggleDistanceTool() {
            distanceMeasurementActive = document.getElementById('enableDistanceTool').checked;
            const controls = document.getElementById('distanceControls');
            const canvas = document.getElementById('canvas');
            
            controls.style.display = distanceMeasurementActive ? 'block' : 'none';
            
            if (distanceMeasurementActive) {
                canvas.classList.add('distance-mode');
                clearAllPoints();
                updateAnimationStatus('Multi-point measurement active');
            } else {
                canvas.classList.remove('distance-mode');
                clearAllPoints();
                updateAnimationStatus('Measurement tool deactivated');
            }
        }
        
        function addMeasurementPoint() {
            const r = parseInt(document.getElementById('pointResidue').value);
            const M = parseInt(document.getElementById('pointModulus').value);
            
            if (isNaN(r) || isNaN(M) || M < 1 || r < 0 || r >= M) {
                alert('Invalid input. Ensure 0 ‚â§ r < M and M ‚â• 1');
                return;
            }
            
            const point = createPointFromResidueModulus(r, M);
            if (point) {
                measurementPoints.push(point);
                updatePointsList();
                updateDistanceStatistics();
                draw();
            }
        }
        
        function createPointFromResidueModulus(r, M) {
            const allRings = [];
            allRings.push({ modulus: 1 });
            for (let m = 2; m <= 1000; m++) allRings.push({ modulus: m });
            allRings.sort((a, b) => a.modulus - b.modulus);
            
            const ringIndex = allRings.findIndex(rc => rc.modulus === M);
            if (ringIndex === -1) return null;
            
            const radius = calculateRadius(M, ringIndex, allRings.length);
            const baseAngle = M === 1 ? 0 : 2 * Math.PI * (M - r) / M;
            const rotation = parseFloat(document.getElementById('rotationSlider').value) * Math.PI / 180;
            const angle = baseAngle + rotation;
            
            return {
                residue: r, modulus: M, radius: radius, angle: angle,
                x: radius * Math.cos(angle), y: radius * Math.sin(angle),
                isGcdOne: gcd(r, M) === 1, isPrime: isPrime(r)
            };
        }
        
        function handleDistanceMeasurementClick(screenX, screenY) {
            const point = findNearestResidue(screenX, screenY);
            if (point && measurementPoints.length < 20) {
                measurementPoints.push(point);
                updatePointsList();
                updateDistanceStatistics();
                draw();
            }
        }
        
        function findNearestResidue(screenX, screenY) {
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) return null;
            
            const centerX = canvas.width / 2 + panX;
            const centerY = canvas.height / 2 + panY;
            const dx = (screenX - centerX) / currentZoom;
            const dy = (screenY - centerY) / currentZoom;
            
            let nearest = null;
            let minDist = Infinity;
            
            selectedRings.forEach(ringId => {
                const config = configs[ringId];
                if (!config) return;
                
                const M = config.mod;
                const residues = getAllResidues(M);
                
                residues.forEach(r => {
                    const point = createPointFromResidueModulus(r, M);
                    if (!point) return;
                    
                    const dist = Math.sqrt((dx - point.x)**2 + (dy - point.y)**2);
                    if (dist < 15 && dist < minDist) {
                        minDist = dist;
                        nearest = point;
                    }
                });
            });
            
            return nearest;
        }
        
        function updateDistanceMode() {
            distanceMode = document.getElementById('distanceMode').value;
            updateDistanceStatistics();
            draw();
        }
        
        function updatePathType() {
            pathType = document.getElementById('pathType').value;
            updateDistanceStatistics();
            draw();
        }
        
        function calculateDistance(p1, p2, mode) {
            switch(mode) {
                case 'euclidean':
                    return Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
                case 'manhattan':
                    return Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);
                case 'geodesic':
                    if (p1.modulus === p2.modulus) {
                        const angleDiff = Math.abs(p2.angle - p1.angle);
                        return p1.radius * Math.min(angleDiff, 2*Math.PI - angleDiff);
                    }
                    return Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
                case 'angular':
                    return Math.abs(p2.angle - p1.angle);
                case 'modular':
                    const minMod = Math.min(p1.modulus, p2.modulus);
                    return Math.abs((p2.residue % minMod) - (p1.residue % minMod));
                default:
                    return Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
            }
        }
        
        function updatePointsList() {
            const list = document.getElementById('pointsList');
            if (measurementPoints.length === 0) {
                list.innerHTML = '<em>No points selected</em>';
                return;
            }
            
            let html = measurementPoints.map((p, i) => 
                `<div style="padding: 3px; background: rgba(255,215,0,0.1); margin: 2px 0; border-radius: 3px;">
                    <strong>P${i+1}:</strong> r=${p.residue}, M=${p.modulus} 
                    ${p.isGcdOne ? '<span style="color: #4ECDC4;">‚úì</span>' : ''}
                    <button onclick="removePoint(${i})" style="float: right; padding: 0 6px; font-size: 10px;">√ó</button>
                </div>`
            ).join('');
            list.innerHTML = html;
        }
        
        function removePoint(index) {
            measurementPoints.splice(index, 1);
            updatePointsList();
            updateDistanceStatistics();
            draw();
        }
        
        function updateDistanceStatistics() {
            const results = document.getElementById('distanceResults');
            const n = measurementPoints.length;
            
            if (n < 2) {
                results.innerHTML = '<strong>Statistics</strong><br><em>Select 2+ points to see analysis</em>';
                return;
            }
            
            let html = '<strong>Statistics:</strong><br>';
            html += `Points: ${n}<br>`;
            
            const distances = [];
            let totalDist = 0;
            
            if (pathType === 'sequential') {
                for (let i = 0; i < n - 1; i++) {
                    const d = calculateDistance(measurementPoints[i], measurementPoints[i+1], distanceMode);
                    distances.push(d);
                    totalDist += d;
                }
            } else if (pathType === 'closed' && n >= 3) {
                for (let i = 0; i < n; i++) {
                    const d = calculateDistance(measurementPoints[i], measurementPoints[(i+1)%n], distanceMode);
                    distances.push(d);
                    totalDist += d;
                }
            } else if (pathType === 'star') {
                const centroid = calculateCentroid(measurementPoints);
                measurementPoints.forEach(p => {
                    const d = calculateDistance(p, centroid, distanceMode);
                    distances.push(d);
                    totalDist += d;
                });
            }
            
            if (distances.length > 0) {
                html += `Total: ${totalDist.toFixed(3)}<br>`;
                html += `Average: ${(totalDist/distances.length).toFixed(3)}<br>`;
                html += `Min: ${Math.min(...distances).toFixed(3)}<br>`;
                html += `Max: ${Math.max(...distances).toFixed(3)}<br>`;
                
                if (pathType === 'closed' && n >= 3) {
                    const area = calculatePolygonArea(measurementPoints);
                    html += `Area: ${Math.abs(area).toFixed(2)}<br>`;
                }
            }
            
            results.innerHTML = html;
        }
        
        function calculateCentroid(points) {
            const n = points.length;
            const cx = points.reduce((sum, p) => sum + p.x, 0) / n;
            const cy = points.reduce((sum, p) => sum + p.y, 0) / n;
            return { x: cx, y: cy };
        }
        
        function calculatePolygonArea(points) {
            let area = 0;
            const n = points.length;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += points[i].x * points[j].y;
                area -= points[j].x * points[i].y;
            }
            return area / 2;
        }
        
        function drawMeasurementPoints() {
            if (!distanceMeasurementActive || measurementPoints.length === 0) return;
            
            ctx.save();
            
            const colors = ['#FFD700', '#4ECDC4', '#FF6B6B', '#9b59b6', '#e67e22'];
            const showLabels = document.getElementById('showDistanceLabels')?.checked;
            const showAngles = document.getElementById('showAngles')?.checked;
            const showMidpoints = document.getElementById('showMidpoints')?.checked;
            const showCentroid = document.getElementById('showCentroid')?.checked;
            
            // Draw paths
            if (pathType === 'sequential') {
                for (let i = 0; i < measurementPoints.length - 1; i++) {
                    drawSegment(measurementPoints[i], measurementPoints[i+1], i, showLabels, showMidpoints);
                }
            } else if (pathType === 'closed') {
                for (let i = 0; i < measurementPoints.length; i++) {
                    drawSegment(measurementPoints[i], measurementPoints[(i+1)%measurementPoints.length], i, showLabels, showMidpoints);
                }
            } else if (pathType === 'star') {
                const centroid = calculateCentroid(measurementPoints);
                measurementPoints.forEach((p, i) => {
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(centroid.x, centroid.y);
                    ctx.strokeStyle = colors[i % colors.length];
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                if (showCentroid) {
                    ctx.beginPath();
                    ctx.arc(centroid.x, centroid.y, 8, 0, 2*Math.PI);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fill();
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            // Draw points
            measurementPoints.forEach((p, i) => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8, 0, 2*Math.PI);
                ctx.fillStyle = colors[i % colors.length];
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#000';
                ctx.font = 'bold 10px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText((i+1).toString(), p.x, p.y + 3);
            });
            
            ctx.restore();
        }
        
        function drawSegment(p1, p2, index, showLabel, showMidpoint) {
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            if (showLabel || showMidpoint) {
                const mx = (p1.x + p2.x) / 2;
                const my = (p1.y + p2.y) / 2;
                
                if (showMidpoint) {
                    ctx.beginPath();
                    ctx.arc(mx, my, 3, 0, 2*Math.PI);
                    ctx.fillStyle = '#4ECDC4';
                    ctx.fill();
                }
                
                if (showLabel) {
                    const dist = calculateDistance(p1, p2, distanceMode);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(mx - 25, my - 10, 50, 16);
                    ctx.fillStyle = '#FFD700';
                    ctx.font = '10px Segoe UI';
                    ctx.textAlign = 'center';
                    ctx.fillText(dist.toFixed(2), mx, my + 3);
                }
            }
        }
        
        function selectAllOnRing() {
            const M = parseInt(prompt('Enter modulus M:', '30'));
            if (!M || M < 1) return;
            
            const residues = getAllResidues(M);
            residues.forEach(r => {
                const point = createPointFromResidueModulus(r, M);
                if (point) measurementPoints.push(point);
            });
            updatePointsList();
            updateDistanceStatistics();
            draw();
        }
        
        function selectPrimesOnly() {
            const M = parseInt(prompt('Enter modulus M:', '30'));
            const limit = parseInt(prompt('Search primes up to:', '100'));
            if (!M || !limit) return;
            
            const primes = sieveOfEratosthenes(limit);
            primes.forEach(p => {
                if (p < M) return;
                const point = createPointFromResidueModulus(p % M, M);
                if (point && !measurementPoints.find(mp => mp.residue === point.residue && mp.modulus === point.modulus)) {
                    measurementPoints.push(point);
                }
            });
            updatePointsList();
            updateDistanceStatistics();
            draw();
        }
        
        function selectByGCD() {
            const M = parseInt(prompt('Enter modulus M:', '30'));
            if (!M || M < 1) return;
            
            const coprimes = getCoprimes(M);
            coprimes.forEach(r => {
                const point = createPointFromResidueModulus(r, M);
                if (point) measurementPoints.push(point);
            });
            updatePointsList();
            updateDistanceStatistics();
            draw();
        }
        
        function clearAllPoints() {
            measurementPoints = [];
            document.getElementById('pointResidue').value = '';
            document.getElementById('pointModulus').value = '';
            updatePointsList();
            updateDistanceStatistics();
            draw();
        }
        
        function exportMeasurementData() {
            if (measurementPoints.length === 0) {
                alert('No points to export');
                return;
            }
            
            let csv = 'Index,Residue,Modulus,X,Y,Radius,Angle,GCD=1,Prime\n';
            measurementPoints.forEach((p, i) => {
                csv += `${i+1},${p.residue},${p.modulus},${p.x.toFixed(3)},${p.y.toFixed(3)},${p.radius.toFixed(3)},${p.angle.toFixed(4)},${p.isGcdOne},${p.isPrime}\n`;
            });
            
            csv += `\nMode,${distanceMode}\n`;
            csv += `Path,${pathType}\n`;
            
            const blob = new Blob([csv], {type: 'text/csv'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `measurement_${measurementPoints.length}points_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.csv`;
            link.click();
            URL.revokeObjectURL(url);
        }
        
        function clearDistanceMeasurement() {
            selectedPoint1 = null;
            selectedPoint2 = null;
            
            document.getElementById('point1Residue').value = '';
            document.getElementById('point1Modulus').value = '';
            document.getElementById('point2Residue').value = '';
            document.getElementById('point2Modulus').value = '';
            
            const point1Status = document.getElementById('point1Status');
            const point2Status = document.getElementById('point2Status');
            
            if (point1Status) point1Status.innerHTML = '<em>Not selected</em>';
            if (point2Status) point2Status.innerHTML = '<em>Not selected</em>';
            
            const display = document.getElementById('distanceDisplay');
            display.innerHTML = `<strong>Distance Calculator</strong><br><em>Select two points using inputs above</em>`;
            
            draw();
        }
        
        function exportDistanceData() {
            if (!selectedPoint1 || !selectedPoint2) {
                alert('Please select two points first');
                return;
            }
            
            const dist = calculateEuclideanDistance(selectedPoint1, selectedPoint2);
            
            let exportText = `DISTANCE MEASUREMENT REPORT\n`;
            exportText += `Generated: ${new Date().toISOString()}\n`;
            exportText += `Riemann Hypothesis Explorer - Distance Analysis\n\n`;
            exportText += `${'='.repeat(60)}\n\n`;
            
            exportText += `POINT 1:\n`;
            exportText += `  Ring: M = ${selectedPoint1.modulus}\n`;
            exportText += `  Residue: r = ${selectedPoint1.residue}\n`;
            exportText += `  Radius: r‚ÇÅ = ${selectedPoint1.radius.toFixed(3)} units\n`;
            exportText += `  Angle: Œ∏‚ÇÅ = ${dist.polar.theta1.toFixed(2)}¬∞\n`;
            exportText += `  Cartesian: (${dist.cartesian.x1.toFixed(3)}, ${dist.cartesian.y1.toFixed(3)})\n`;
            exportText += `  GCD(r,M): ${gcd(selectedPoint1.residue, Math.round(selectedPoint1.modulus))}\n\n`;
            
            exportText += `POINT 2:\n`;
            exportText += `  Ring: M = ${selectedPoint2.modulus}\n`;
            exportText += `  Residue: r = ${selectedPoint2.residue}\n`;
            exportText += `  Radius: r‚ÇÇ = ${selectedPoint2.radius.toFixed(3)} units\n`;
            exportText += `  Angle: Œ∏‚ÇÇ = ${dist.polar.theta2.toFixed(2)}¬∞\n`;
            exportText += `  Cartesian: (${dist.cartesian.x2.toFixed(3)}, ${dist.cartesian.y2.toFixed(3)})\n`;
            exportText += `  GCD(r,M): ${gcd(selectedPoint2.residue, Math.round(selectedPoint2.modulus))}\n\n`;
            
            exportText += `${'='.repeat(60)}\n`;
            exportText += `DISTANCE CALCULATIONS:\n`;
            exportText += `${'='.repeat(60)}\n\n`;
            exportText += `Euclidean Distance:\n`;
            exportText += `  d = ${dist.euclidean.toFixed(6)} units\n\n`;
            exportText += `Law of Cosines Verification:\n`;
            exportText += `  d = ‚àö[r‚ÇÅ¬≤ + r‚ÇÇ¬≤ - 2r‚ÇÅr‚ÇÇcos(Œ∏‚ÇÇ-Œ∏‚ÇÅ)]\n`;
            exportText += `  d = ${dist.lawOfCosines.toFixed(6)} units\n\n`;
            exportText += `Difference: ${Math.abs(dist.euclidean - dist.lawOfCosines).toExponential(3)} units\n`;
            exportText += `(Should be near machine precision)\n\n`;
            
            exportText += `General Formula (for point on ring M to unit circle):\n`;
            exportText += `  d = ‚àö[r‚ÇÅ¬≤ - 2r‚ÇÅr_m cos(2œÄk/m) + r_m¬≤]\n\n`;
            
            const blob = new Blob([exportText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `distance_measurement_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.txt`;
            link.click();
            URL.revokeObjectURL(url);
            
            updateAnimationStatus('Distance measurement exported');
        }
        
        // ========================================
        // FAREY SEQUENCE & FRANEL-LANDAU FUNCTIONS
        // ========================================
        
        function generateFareySequence() {
            const N = parseInt(document.getElementById('fareyOrder').value);
            
            if (N < 2 || N > 1000) {
                alert('Please enter a Farey order between 2 and 1000');
                return;
            }
            
            updateAnimationStatus('Computing Farey sequence...');
            
            // Generate Farey sequence F_N
            const farey = [];
            
            for (let q = 1; q <= N; q++) {
                for (let a = 0; a <= q; a++) {
                    if (gcd(a, q) === 1) {
                        farey.push({ a, q, value: a / q });
                    }
                }
            }
            
            // Sort by value
            farey.sort((x, y) => x.value - y.value);
            
            // Remove duplicates (keep first occurrence)
            const uniqueFarey = [];
            let lastVal = -1;
            farey.forEach(f => {
                if (Math.abs(f.value - lastVal) > 1e-10) {
                    uniqueFarey.push(f);
                    lastVal = f.value;
                }
            });
            
            const L_N = uniqueFarey.length;
            
            // Compute linear uniform parametrization U_N
            const uniform = [];
            for (let j = 1; j <= L_N; j++) {
                uniform.push(j / L_N);
            }
            
            // Compute absolute discrepancy sum D(N)
            let discrepancySum = 0;
            for (let j = 0; j < L_N; j++) {
                const fareyVal = uniqueFarey[j].value;
                const uniformVal = (j + 1) / L_N; // j+1 because j is 0-indexed but uniform is 1-indexed
                discrepancySum += Math.abs(fareyVal - uniformVal);
            }
            
            // Store results
            fareyData = {
                N: N,
                sequence: uniqueFarey,
                L_N: L_N,
                uniform: uniform,
                discrepancy: discrepancySum,
                isActive: true
            };
            
            // Theoretical bound under RH: D(N) = O(N^(1/2 + Œµ))
            const rhBound = Math.pow(N, 0.5 + 0.1); // Using Œµ = 0.1
            const rhBoundStrict = Math.pow(N, 0.5);
            
            fareyData.rhBound = rhBound;
            fareyData.rhBoundStrict = rhBoundStrict;
            fareyData.satisfiesRH = discrepancySum < rhBound;
            
            // Display results
            document.getElementById('fareyResults').style.display = 'block';
            const stats = document.getElementById('fareyStats');
            
            stats.innerHTML = `
                <strong>Farey Order N = ${N}</strong><br>
                ‚Ä¢ Sequence length: |F_${N}| = ${L_N}<br>
                ‚Ä¢ Discrepancy D(${N}) = ${discrepancySum.toFixed(6)}<br>
                ‚Ä¢ RH bound N^(1/2+Œµ): ${rhBound.toFixed(3)} (Œµ=0.1)<br>
                ‚Ä¢ RH strict N^(1/2): ${rhBoundStrict.toFixed(3)}<br>
                ‚Ä¢ Satisfies RH bound: ${fareyData.satisfiesRH ? '<strong style="color: #4ECDC4;">‚úì YES</strong>' : '<strong style="color: #FF6B6B;">‚úó NO</strong>'}<br>
                ‚Ä¢ Ratio D(N)/N^(1/2): ${(discrepancySum / rhBoundStrict).toFixed(4)}
            `;
            
            // Update visualizations
            updateRhVisualizations();
            updateAnimationStatus(`Farey sequence F_${N} computed (${L_N} fractions)`);
        }
        
        function updateFareyDiscrepancyVisualization() {
            const canvas = document.getElementById('fareyDiscrepancyCanvas');
            if (!canvas || !document.getElementById('showFareyVisualization')?.checked) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!fareyData.isActive) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Generate Farey Sequence', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const L_N = fareyData.L_N;
            const xScale = (canvas.width - 60) / L_N;
            const maxDiscrepancy = Math.max(...fareyData.sequence.map((f, i) => Math.abs(f.value - (i + 1) / L_N)));
            const yScale = (canvas.height - 60) / (maxDiscrepancy * 1.2);
            
            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(40, 10);
            ctx.lineTo(40, canvas.height - 40);
            ctx.lineTo(canvas.width - 10, canvas.height - 40);
            ctx.stroke();
            
            // Draw Farey points vs uniform
            ctx.fillStyle = '#4ECDC4';
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 1;
            
            fareyData.sequence.forEach((f, i) => {
                const x = 40 + (i + 1) * xScale;
                const fareyY = canvas.height - 40 - f.value * (canvas.height - 60);
                const uniformY = canvas.height - 40 - ((i + 1) / L_N) * (canvas.height - 60);
                
                // Farey point
                ctx.fillStyle = '#4ECDC4';
                ctx.beginPath();
                ctx.arc(x, fareyY, 2, 0, 2 * Math.PI);
                ctx.fill();
                
                // Uniform point
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(x, uniformY, 2, 0, 2 * Math.PI);
                ctx.fill();
                
                // Connection line showing discrepancy
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
                ctx.beginPath();
                ctx.moveTo(x, fareyY);
                ctx.lineTo(x, uniformY);
                ctx.stroke();
            });
            
            // Legend
            ctx.fillStyle = '#4ECDC4';
            ctx.font = '11px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('Farey F_N', 50, 25);
            
            ctx.fillStyle = '#FFD700';
            ctx.fillText('Uniform U_N', 120, 25);
            
            // Title
            ctx.fillStyle = '#FFD700';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText(`D(${fareyData.N}) = ${fareyData.discrepancy.toFixed(4)}`, canvas.width / 2, canvas.height - 10);
        }
        
        function updateFranelLandauVisualization() {
            const canvas = document.getElementById('franelLandauCanvas');
            if (!canvas || !document.getElementById('showFranelLandau')?.checked) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!fareyData.isActive) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Generate Farey Sequence', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Plot D(N) for various N values to test RH bound
            const testValues = [5, 10, 15, 20, 30, 50, 75, 100, 150, 200, 300, 500];
            const results = [];
            
            testValues.forEach(N => {
                if (N <= 500) { // Limit computation for performance
                    // Quick Farey generation for this N
                    const farey = [];
                    for (let q = 1; q <= N; q++) {
                        for (let a = 0; a <= q; a++) {
                            if (gcd(a, q) === 1) {
                                farey.push(a / q);
                            }
                        }
                    }
                    
                    const uniqueFarey = Array.from(new Set(farey)).sort((a, b) => a - b);
                    const L = uniqueFarey.length;
                    
                    let D = 0;
                    for (let j = 0; j < L; j++) {
                        D += Math.abs(uniqueFarey[j] - (j + 1) / L);
                    }
                    
                    results.push({ N, D, rhBound: Math.pow(N, 0.5 + 0.1) });
                }
            });
            
            // Plot
            const maxN = Math.max(...results.map(r => r.N));
            const maxY = Math.max(...results.map(r => r.D), ...results.map(r => r.rhBound));
            const xScale = (canvas.width - 60) / maxN;
            const yScale = (canvas.height - 60) / maxY;
            
            // Axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(40, 10);
            ctx.lineTo(40, canvas.height - 40);
            ctx.lineTo(canvas.width - 10, canvas.height - 40);
            ctx.stroke();
            
            // RH bound curve
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            results.forEach((r, i) => {
                const x = 40 + r.N * xScale;
                const y = canvas.height - 40 - r.rhBound * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Actual D(N) points
            ctx.fillStyle = '#4ECDC4';
            ctx.strokeStyle = '#4ECDC4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            results.forEach((r, i) => {
                const x = 40 + r.N * xScale;
                const y = canvas.height - 40 - r.D * yScale;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                
                ctx.fillRect(x - 2, y - 2, 4, 4);
            });
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#FFD700';
            ctx.font = '11px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('O(N^(1/2+Œµ)) bound', 50, 20);
            
            ctx.fillStyle = '#4ECDC4';
            ctx.fillText('Actual D(N)', 50, 35);
            
            // Title
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('Franel-Landau: D(N) vs RH Bound', canvas.width / 2, canvas.height - 10);
            
            // Check if all points satisfy RH
            const allSatisfy = results.every(r => r.D < r.rhBound);
            ctx.fillStyle = allSatisfy ? '#4ECDC4' : '#FF6B6B';
            ctx.font = '10px Segoe UI';
            ctx.fillText(allSatisfy ? '‚úì All points satisfy RH bound' : '‚ö† Some points exceed bound', canvas.width - 100, 20);
        }
        
        // Format label based on selected mode
        function formatLabel(r, modulus, ring) {
            const labelFormat = document.getElementById('labelFormat').value;
            const showGcdValue = document.getElementById('showGcdValue')?.checked;
            const showCoprimeIndicator = document.getElementById('showCoprimeIndicator')?.checked;
            const showTotientPosition = document.getElementById('showTotientPosition')?.checked;
            
            const gcdValue = gcd(r, Math.round(modulus));
            const isGcdOne = gcdValue === 1;
            
            let baseLabel = '';
            
            switch(labelFormat) {
                case 'number':
                    baseLabel = r.toString();
                    break;
                    
                case 'fraction':
                    baseLabel = `${r}/${Math.round(modulus)}`;
                    break;
                    
                case 'farey':
                    // Simplified fraction (Farey sequence)
                    const gcd_val = gcd(r, Math.round(modulus));
                    const num = r / gcd_val;
                    const den = Math.round(modulus) / gcd_val;
                    baseLabel = den === 1 ? num.toString() : `${num}/${den}`;
                    break;
                    
                case 'angle':
                    // Angle in degrees
                    const angleDeg = (360 * (modulus - r) / modulus).toFixed(1);
                    baseLabel = `${angleDeg}¬∞`;
                    break;
                    
                case 'gcd':
                    baseLabel = `gcd=${gcdValue}`;
                    break;
                    
                case 'coprime':
                    baseLabel = isGcdOne ? '‚úì' : '‚úó';
                    break;
                    
                case 'combined':
                    const angle = (360 * (modulus - r) / modulus).toFixed(0);
                    baseLabel = `${r}\ngcd=${gcdValue}\n${angle}¬∞`;
                    break;
                    
                default:
                    baseLabel = r.toString();
            }
            
            // Add optional GCD information only if not in combined or gcd modes
            let additionalInfo = [];
            
            if (showGcdValue && labelFormat !== 'gcd' && labelFormat !== 'combined') {
                additionalInfo.push(`gcd=${gcdValue}`);
            }
            
            if (showCoprimeIndicator && labelFormat !== 'coprime' && labelFormat !== 'combined') {
                additionalInfo.push(isGcdOne ? '‚úì' : '‚úó');
            }
            
            if (showTotientPosition && isGcdOne && labelFormat !== 'combined') {
                const coprimes = getCoprimes(Math.round(modulus));
                const position = coprimes.indexOf(r) + 1;
                if (position > 0) {
                    additionalInfo.push(`#${position}`);
                }
            }
            
            if (additionalInfo.length > 0) {
                baseLabel += '\n' + additionalInfo.join(' ');
            }
            
            return baseLabel;
        }
        
        function updateLabelFormat() {
            currentLabelFormat = document.getElementById('labelFormat').value;
            updateAnimationStatus(`Label format: ${currentLabelFormat}`);
            draw();
        }
        
        // GCD Analysis Functions
        function analyzeGcdPatterns() {
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) {
                alert('Please select rings to analyze GCD patterns');
                return;
            }
            
            let analysis = {
                rings: [],
                totalGcdOne: 0,
                totalResidues: 0,
                avgTotientDensity: 0,
                patterns: []
            };
            
            selectedRings.forEach(ringId => {
                const config = configs[ringId];
                if (!config) return;
                
                const modulus = Math.round(config.mod);
                const allResidues = getAllResidues(modulus);
                const coprimes = getCoprimes(modulus);
                const totientDensity = coprimes.length / allResidues.length;
                
                // Analyze GCD distribution
                const gcdDistribution = {};
                allResidues.forEach(r => {
                    const gcdVal = gcd(r, modulus);
                    gcdDistribution[gcdVal] = (gcdDistribution[gcdVal] || 0) + 1;
                });
                
                analysis.rings.push({
                    modulus: modulus,
                    label: config.label,
                    totalResidues: allResidues.length,
                    gcdOneCount: coprimes.length,
                    totientDensity: totientDensity,
                    gcdDistribution: gcdDistribution,
                    eulerPhi: coprimes.length
                });
                
                analysis.totalGcdOne += coprimes.length;
                analysis.totalResidues += allResidues.length;
            });
            
            analysis.avgTotientDensity = analysis.totalGcdOne / analysis.totalResidues;
            
            // Identify patterns
            analysis.patterns = identifyGcdPatterns(analysis.rings);
            
            displayGcdAnalysis(analysis);
            
            document.getElementById('gcdAnalysisResults').style.display = 'block';
            updateAnimationStatus('GCD pattern analysis complete');
        }
        
        function identifyGcdPatterns(rings) {
            const patterns = [];
            
            // Pattern 1: Prime moduli have œÜ(p) = p-1
            const primeRings = rings.filter(r => isPrime(r.modulus));
            if (primeRings.length > 0) {
                patterns.push({
                    name: 'Prime Moduli',
                    description: `${primeRings.length} prime moduli detected. Each has œÜ(p) = p-1, meaning almost all residues are coprime.`,
                    rings: primeRings.map(r => r.label)
                });
            }
            
            // Pattern 2: Powers of 2 have œÜ(2^k) = 2^(k-1)
            const powersOf2 = rings.filter(r => {
                const mod = r.modulus;
                return mod > 1 && (mod & (mod - 1)) === 0; // Check if power of 2
            });
            if (powersOf2.length > 0) {
                patterns.push({
                    name: 'Powers of 2',
                    description: `${powersOf2.length} rings are powers of 2. œÜ(2^k) = 2^(k-1), exactly half coprime.`,
                    rings: powersOf2.map(r => r.label)
                });
            }
            
            // Pattern 3: High totient density (> 0.4)
            const highDensity = rings.filter(r => r.totientDensity > 0.4);
            if (highDensity.length > 0) {
                patterns.push({
                    name: 'High Coprime Density',
                    description: `${highDensity.length} rings have >40% coprime residues (prime-like behavior).`,
                    rings: highDensity.map(r => `${r.label} (${(r.totientDensity * 100).toFixed(1)}%)`)
                });
            }
            
            // Pattern 4: Low totient density (< 0.2)
            const lowDensity = rings.filter(r => r.totientDensity < 0.2);
            if (lowDensity.length > 0) {
                patterns.push({
                    name: 'Low Coprime Density',
                    description: `${lowDensity.length} rings have <20% coprime residues (highly composite).`,
                    rings: lowDensity.map(r => `${r.label} (${(r.totientDensity * 100).toFixed(1)}%)`)
                });
            }
            
            return patterns;
        }
        
        function displayGcdAnalysis(analysis) {
            const resultsDiv = document.getElementById('gcdResultsContent');
            
            let html = `<strong>GCD Pattern Analysis</strong><br><br>`;
            
            html += `<strong>Overall Statistics:</strong><br>`;
            html += `‚Ä¢ Rings analyzed: ${analysis.rings.length}<br>`;
            html += `‚Ä¢ Total residues: ${analysis.totalResidues}<br>`;
            html += `‚Ä¢ Coprime residues (gcd=1): ${analysis.totalGcdOne}<br>`;
            html += `‚Ä¢ Average œÜ(M)/M density: ${(analysis.avgTotientDensity * 100).toFixed(2)}%<br><br>`;
            
            html += `<strong>Per-Ring Analysis:</strong><br>`;
            analysis.rings.slice(0, 10).forEach(ring => {
                html += `<div style="margin: 8px 0; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 5px;">`;
                html += `<strong>M = ${ring.modulus}:</strong><br>`;
                html += `‚Ä¢ œÜ(${ring.modulus}) = ${ring.eulerPhi} coprime residues<br>`;
                html += `‚Ä¢ Density: ${(ring.totientDensity * 100).toFixed(1)}%<br>`;
                
                // Show GCD distribution
                html += `‚Ä¢ GCD distribution: `;
                const gcdKeys = Object.keys(ring.gcdDistribution).sort((a, b) => parseInt(a) - parseInt(b));
                html += gcdKeys.map(k => `gcd=${k}:${ring.gcdDistribution[k]}`).join(', ');
                html += `</div>`;
            });
            
            if (analysis.rings.length > 10) {
                html += `<em>...and ${analysis.rings.length - 10} more rings</em><br><br>`;
            }
            
            if (analysis.patterns.length > 0) {
                html += `<br><strong>Identified Patterns:</strong><br>`;
                analysis.patterns.forEach((pattern, idx) => {
                    html += `<div style="margin: 8px 0; padding: 10px; background: rgba(72, 187, 120, 0.15); border-radius: 5px; border-left: 3px solid #48BB78;">`;
                    html += `<strong>${idx + 1}. ${pattern.name}:</strong><br>`;
                    html += `${pattern.description}<br>`;
                    html += `<em>Rings: ${pattern.rings.slice(0, 5).join(', ')}${pattern.rings.length > 5 ? '...' : ''}</em>`;
                    html += `</div>`;
                });
            }
            
            resultsDiv.innerHTML = html;
        }
        
        function exportGcdData() {
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) {
                alert('Please select rings to export GCD data');
                return;
            }
            
            let exportText = `GCD Analysis Export\n`;
            exportText += `Generated: ${new Date().toISOString()}\n`;
            exportText += `Riemann Hypothesis Explorer by Wessen Getachew\n\n`;
            exportText += `${'='.repeat(80)}\n\n`;
            
            selectedRings.forEach(ringId => {
                const config = configs[ringId];
                if (!config) return;
                
                const modulus = Math.round(config.mod);
                const allResidues = getAllResidues(modulus);
                const coprimes = getCoprimes(modulus);
                
                exportText += `Modulus M = ${modulus}\n`;
                exportText += `${'-'.repeat(40)}\n`;
                exportText += `œÜ(${modulus}) = ${coprimes.length}\n`;
                exportText += `Totient density: ${(coprimes.length / allResidues.length * 100).toFixed(2)}%\n\n`;
                
                exportText += `Complete Residue Analysis:\n`;
                allResidues.forEach(r => {
                    const gcdVal = gcd(r, modulus);
                    const isGcdOne = gcdVal === 1;
                    const angle = (360 * (modulus - r) / modulus).toFixed(2);
                    const fareyNum = r / gcdVal;
                    const fareyDen = modulus / gcdVal;
                    
                    exportText += `  r=${r.toString().padStart(4)}`;
                    exportText += `  gcd(${r},${modulus})=${gcdVal.toString().padStart(3)}`;
                    exportText += `  ${isGcdOne ? '‚úì COPRIME' : '‚úó not coprime'}`;
                    exportText += `  Œ∏=${angle.padStart(7)}¬∞`;
                    exportText += `  Farey: ${fareyNum}/${fareyDen}\n`;
                });
                
                exportText += `\nCoprime residues (gcd=1): [${coprimes.join(', ')}]\n`;
                exportText += `\n${'='.repeat(80)}\n\n`;
            });
            
            exportText += `Summary:\n`;
            exportText += `Total rings: ${selectedRings.length}\n`;
            exportText += `Total coprime residues: ${selectedRings.reduce((sum, id) => sum + (configs[id] ? getCoprimes(Math.round(configs[id].mod)).length : 0), 0)}\n`;
            
            const blob = new Blob([exportText], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `gcd_analysis_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.txt`;
            link.click();
            URL.revokeObjectURL(url);
            
            updateAnimationStatus('GCD data exported successfully');
        }
        
        function visualizeFareySequence() {
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) {
                alert('Please select rings to visualize Farey sequence');
                return;
            }
            
            // Set to Farey sequence labeling
            document.getElementById('labelFormat').value = 'farey';
            document.getElementById('showLabels').checked = true;
            document.getElementById('labelGcdOne').checked = true;
            document.getElementById('labelNonGcdOne').checked = true;
            
            updateLabelFormat();
            updateAnimationStatus('Farey sequence visualization activated');
        }
        
        function testCoprimalityTheorems() {
            const selectedRings = getSelectedRings();
            if (selectedRings.length < 2) {
                alert('Please select at least 2 rings to test coprimality theorems');
                return;
            }
            
            let results = [];
            
            // Theorem 1: gcd(a,mn) = 1 ‚ü∫ gcd(a,m) = 1 AND gcd(a,n) = 1
            results.push({
                theorem: "Product Rule",
                statement: "gcd(a,mn) = 1 ‚ü∫ gcd(a,m)=1 AND gcd(a,n)=1",
                tested: 0,
                verified: 0
            });
            
            // Theorem 2: œÜ(mn) = œÜ(m)œÜ(n) if gcd(m,n) = 1
            results.push({
                theorem: "Multiplicative Property",
                statement: "œÜ(mn) = œÜ(m)œÜ(n) when gcd(m,n) = 1",
                tested: 0,
                verified: 0
            });
            
            // Test theorems
            for (let i = 0; i < Math.min(selectedRings.length, 5); i++) {
                for (let j = i + 1; j < Math.min(selectedRings.length, 5); j++) {
                    const m = Math.round(configs[selectedRings[i]]?.mod || 1);
                    const n = Math.round(configs[selectedRings[j]]?.mod || 1);
                    
                    if (gcd(m, n) === 1) {
                        const phi_m = getCoprimes(m).length;
                        const phi_n = getCoprimes(n).length;
                        const phi_mn = getCoprimes(m * n).length;
                        
                        results[1].tested++;
                        if (phi_mn === phi_m * phi_n) {
                            results[1].verified++;
                        }
                    }
                }
            }
            
            const resultsDiv = document.getElementById('gcdResultsContent');
            document.getElementById('gcdAnalysisResults').style.display = 'block';
            
            let html = `<strong>Coprimality Theorem Testing</strong><br><br>`;
            
            results.forEach(result => {
                if (result.tested > 0) {
                    const percentage = (result.verified / result.tested * 100).toFixed(1);
                    html += `<div style="margin: 8px 0; padding: 10px; background: rgba(72, 187, 120, 0.15); border-radius: 5px;">`;
                    html += `<strong>${result.theorem}:</strong><br>`;
                    html += `<em>${result.statement}</em><br>`;
                    html += `Tested: ${result.tested} cases<br>`;
                    html += `Verified: ${result.verified} (${percentage}%)<br>`;
                    html += result.verified === result.tested ? '‚úì All cases verified!' : '‚ö† Some cases failed';
                    html += `</div>`;
                }
            });
            
            resultsDiv.innerHTML = html;
            updateAnimationStatus('Coprimality theorems tested');
        }
        
        // Enhanced functions
        function startAnimation() {
            document.getElementById('enableRotation').checked = true;
            toggleRotation();
            updateAnimationStatus('Animation started');
        }

        function stopAnimation() {
            document.getElementById('enableRotation').checked = false;
            if (!isInverting && !nestingAnimationActive) {
                animating = false;
            }
            updateAnimationStatus('Animation stopped');
        }

        // Theme toggle
        function toggleTheme() {
            currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.body.classList.toggle('light-mode');
            
            const icon = document.getElementById('themeIcon');
            
            if (currentTheme === 'light') {
                icon.textContent = '‚òÄÔ∏è';
            } else {
                icon.textContent = 'üåô';
            }
            
            draw();
            updateAnimationStatus(`Switched to ${currentTheme} mode`);
        }
        
        // Color palette application
        function applyPalette(paletteName) {
            currentPalette = paletteName;
            
            // Update active state
            document.querySelectorAll('.palette-option').forEach(opt => {
                opt.classList.remove('active');
            });
            document.querySelector(`.palette-option.${paletteName}`).classList.add('active');
            
            // Override the color mode to use the selected palette
            document.getElementById('residueColorMode').value = 'hue';
            updateColorMode();
            
            updateAnimationStatus(`Applied ${paletteName} palette`);
            draw();
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return;
            }
            
            switch(e.key.toLowerCase()) {
                case '?':
                    showKeyboardShortcuts = !showKeyboardShortcuts;
                    document.getElementById('keyboardShortcuts').classList.toggle('visible');
                    break;
                case 't':
                    toggleTheme();
                    break;
                case 'r':
                    document.getElementById('enableRotation').checked = !document.getElementById('enableRotation').checked;
                    toggleRotation();
                    break;
                case 'l':
                    document.getElementById('showLabels').checked = !document.getElementById('showLabels').checked;
                    draw();
                    break;
                case ' ':
                    e.preventDefault();
                    document.getElementById('enableRotation').checked = !document.getElementById('enableRotation').checked;
                    toggleRotation();
                    break;
                case 'arrowleft':
                    e.preventDefault();
                    const rotSlider = document.getElementById('rotationSlider');
                    rotSlider.value = Math.max(0, parseFloat(rotSlider.value) - 5);
                    updateRotation();
                    break;
                case 'arrowright':
                    e.preventDefault();
                    const rotSliderR = document.getElementById('rotationSlider');
                    rotSliderR.value = Math.min(360, parseFloat(rotSliderR.value) + 5);
                    updateRotation();
                    break;
                case 'arrowup':
                    e.preventDefault();
                    const zoomSlider = document.getElementById('zoomSlider');
                    zoomSlider.value = Math.min(10, parseFloat(zoomSlider.value) + 0.1);
                    updateZoom();
                    break;
                case 'arrowdown':
                    e.preventDefault();
                    const zoomSliderD = document.getElementById('zoomSlider');
                    zoomSliderD.value = Math.max(0.1, parseFloat(zoomSliderD.value) - 0.1);
                    updateZoom();
                    break;
                case 'escape':
                    resetView();
                    break;
                case 's':
                    takeScreenshot();
                    break;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                    const gapValue = parseInt(e.key) * 2;
                    toggleGapQuick(gapValue);
                    break;
            }
        });
        
        function toggleGapQuick(gap) {
            const gapControls = document.getElementById('gapControls');
            const gapCheckbox = Array.from(gapControls.querySelectorAll('input[type="checkbox"]'))
                .find(cb => parseInt(cb.value) === gap);
            
            if (gapCheckbox) {
                gapCheckbox.checked = !gapCheckbox.checked;
                updateAnimationStatus(`Gap ${gap} ${gapCheckbox.checked ? 'enabled' : 'disabled'}`);
                draw();
            }
        }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }

        function getCoprimes(modulus) {
            const residues = [];
            const m = Math.round(modulus);
            
            // Special case for mod 1: only residue is 0, and gcd(0,1) = 1
            if (m === 1) {
                return [0];
            }
            
            // For all other moduli, find residues coprime to m
            for (let r = 1; r < m; r++) {
                if (gcd(r, m) === 1) {
                    residues.push(r);
                }
            }
            return residues;
        }

        function getAllResidues(modulus) {
            const residues = [];
            const m = Math.round(modulus);
            
            // Special case for mod 1: only residue is 0
            if (m === 1) {
                return [0];
            }
            
            // For all other moduli, return all residues 0 to m-1
            for (let r = 0; r < m; r++) {
                residues.push(r);
            }
            return residues;
        }

        function getResidueColor(r, modulus, ringIndex, colorMode) {
            const customColor = document.getElementById('customResidueColor').value;
            const gcdBaseColor = document.getElementById('gcdBaseColor').value;
            const nonGcdColor = document.getElementById('nonGcdColor').value;
            
            // Special handling for unit circle
            if (modulus === 1) {
                return 'rgba(255, 215, 0, 0.9)'; // Golden color for unit circle
            }
            
            // Check if residue is coprime to modulus
            const isGcdOne = gcd(r, Math.round(modulus)) === 1;
            
            switch(colorMode) {
                case 'hue':
                    // Use the selected palette
                    const angle = r / modulus;
                    return colorPalettes[currentPalette](angle);
                case 'value':
                    return `hsl(${(r * 37) % 360}, 80%, 70%)`;
                case 'modulo':
                    return `hsl(${(ringIndex * 67) % 360}, 78%, 62%)`;
                case 'prime':
                    return isPrime(r) ? '#FF6B6B' : '#4ECDC4';
                case 'gcd_unified':
                    // All GCD=1 residues get same color
                    return isGcdOne ? gcdBaseColor : nonGcdColor;
                case 'gcd_per_mod':
                    // Each modulus gets its own hue for GCD=1 residues
                    if (isGcdOne) {
                        const modHue = (Math.round(modulus) * 67) % 360;
                        return `hsl(${modHue}, 85%, 70%)`;
                    } else {
                        return nonGcdColor;
                    }
                case 'gcd_per_residue':
                    // Each unique GCD=1 residue value gets its own color across all moduli
                    if (isGcdOne) {
                        const residueHue = (r * 43 + 123) % 360;
                        return `hsl(${residueHue}, 78%, 68%)`;
                    } else {
                        return nonGcdColor;
                    }
                case 'gcd_mathematical':
                    // Mathematical progression based on œÜ(n) and residue position
                    if (isGcdOne) {
                        const phi = getCoprimes(Math.round(modulus)).length;
                        const coprimesList = getCoprimes(Math.round(modulus));
                        const position = coprimesList.indexOf(r);
                        const mathHue = (position * 360 / phi + Math.round(modulus) * 7) % 360;
                        return `hsl(${mathHue}, 82%, 66%)`;
                    } else {
                        return nonGcdColor;
                    }
                case 'gcd_spectrum':
                    // Spectral distribution based on modulus size and residue density
                    if (isGcdOne) {
                        const phi = getCoprimes(Math.round(modulus)).length;
                        const density = phi / Math.round(modulus);
                        const spectralHue = (density * 240 + r * 15) % 360;
                        const saturation = 60 + density * 30;
                        return `hsl(${spectralHue}, ${saturation}%, 65%)`;
                    } else {
                        return nonGcdColor;
                    }
                case 'custom':
                    return customColor;
                default:
                    const defaultAngle = r / modulus;
                    return colorPalettes[currentPalette](defaultAngle);
            }
        }

        function getSelectedGaps() {
            const checked = document.querySelectorAll('#gapControls input:checked');
            return Array.from(checked).map(cb => parseInt(cb.value));
        }

        function getSelectedRings() {
            const checked = document.querySelectorAll('#ringControls input:checked');
            return Array.from(checked).map(cb => cb.value);
        }

        function updateExpBase() {
            const value = document.getElementById('expBase').value;
            document.getElementById('expBaseValue').textContent = value;
            exponentialBase = parseFloat(value);
            draw();
        }

        function updateRadiusScaling() {
            radiusScalingMode = document.getElementById('radiusScaling').value;
            const expGroup = document.getElementById('expBaseGroup');
            
            // Show exponential base control only for exponential mode
            expGroup.style.display = radiusScalingMode === 'exponential' ? 'block' : 'none';
            
            updateScalingDescription();
            updateAnimationStatus(`Radius scaling: ${radiusScalingMode}`);
            draw();
        }

        function updateScalingConst() {
            const value = document.getElementById('scalingConst').value;
            document.getElementById('scalingConstValue').textContent = value;
            scalingConstant = parseFloat(value);
            draw();
        }

        function updateScalingDescription() {
            const descriptions = {
                'uniform': 'Uniform spacing places rings at equal intervals regardless of modulus value. Best for visualizing all rings equally.',
                'linear': 'Linear scaling r(m) = c¬∑m places rings proportionally to modulus size. Larger moduli appear much farther out, emphasizing hierarchical structure.',
                'sqrt': 'Square-root scaling r(m) = c¬∑‚àöm compresses large moduli while spreading small ones. Balances visibility across different scales.',
                'log': 'Logarithmic scaling r(m) = c¬∑log(m+1) strongly compresses large moduli. Excellent for visualizing many rings of vastly different sizes.',
                'totient': 'Totient-based scaling r(m) = c¬∑œÜ(m) places rings by Euler totient function. Rings positioned by number of coprime residues‚Äîmathematically meaningful!',
                'density': 'Density scaling r(m) = c¬∑œÜ(m)/m uses totient density. Rings with higher proportions of coprime residues appear farther out‚Äîreveals number-theoretic properties.',
                'inverse': 'Inverse scaling r(m) = c/m places smaller moduli farther out and larger ones closer in. Reverses usual hierarchy‚Äîcreates unique perspectives.',
                'exponential': 'Exponential scaling r(m) = c¬∑a·µê grows rapidly. Large moduli spread far apart‚Äîbest for small sets of rings. Adjustable base a controls growth rate.'
            };
            
            document.getElementById('scalingDescription').textContent = descriptions[radiusScalingMode] || '';
        }

        function calculateRadius(modulus, index, totalRings) {
            const maxRadius = 280;
            const minRadius = 25;
            
            // Don't apply special case for unit circle during calculations
            // Let it be positioned based on index like all other rings
            
            const c = scalingConstant;
            
            switch(radiusScalingMode) {
                case 'uniform':
                    // Default uniform spacing - works for all rings including unit circle
                    return minRadius + (maxRadius - minRadius) * index / Math.max(1, totalRings - 1);
                
                case 'linear':
                    // r(m) = c¬∑m
                    const maxMod = Math.max(...getSelectedRings().map(id => configs[id]?.mod || 1));
                    const linearRadius = minRadius + (maxRadius - minRadius) * (c * modulus) / (c * maxMod);
                    return Math.min(maxRadius, linearRadius);
                
                case 'sqrt':
                    // r(m) = c¬∑‚àöm
                    const maxSqrt = Math.sqrt(Math.max(...getSelectedRings().map(id => configs[id]?.mod || 1)));
                    const sqrtRadius = minRadius + (maxRadius - minRadius) * (c * Math.sqrt(modulus)) / (c * maxSqrt);
                    return Math.min(maxRadius, sqrtRadius);
                
                case 'log':
                    // r(m) = c¬∑log(m+1)
                    const maxLog = Math.log(Math.max(...getSelectedRings().map(id => configs[id]?.mod || 1)) + 1);
                    const logRadius = minRadius + (maxRadius - minRadius) * (c * Math.log(modulus + 1)) / (c * maxLog);
                    return Math.min(maxRadius, logRadius);
                
                case 'totient': {
                    // r(m) = c¬∑œÜ(m)
                    const coprimes = getCoprimes(modulus);
                    const phi = coprimes.length;
                    const maxPhi = Math.max(...getSelectedRings().map(id => {
                        const cfg = configs[id];
                        return cfg ? getCoprimes(cfg.mod).length : 1;
                    }));
                    const totientRadius = minRadius + (maxRadius - minRadius) * (c * phi) / (c * maxPhi);
                    return Math.min(maxRadius, totientRadius);
                }
                
                case 'density': {
                    // r(m) = c¬∑œÜ(m)/m
                    const coprimes = getCoprimes(modulus);
                    const density = coprimes.length / modulus;
                    const maxDensity = Math.max(...getSelectedRings().map(id => {
                        const cfg = configs[id];
                        if (!cfg) return 0;
                        const cp = getCoprimes(cfg.mod);
                        return cp.length / cfg.mod;
                    }));
                    const densityRadius = minRadius + (maxRadius - minRadius) * (c * density) / (c * maxDensity);
                    return Math.min(maxRadius, densityRadius);
                }
                
                case 'inverse': {
                    // r(m) = c/m - but we need to normalize to fit in our range
                    const minMod = Math.min(...getSelectedRings().map(id => configs[id]?.mod || 1));
                    const maxInverse = c / minMod;
                    const inverse = c / modulus;
                    // Inverse: smaller values mean larger radius
                    const inverseRadius = minRadius + (maxRadius - minRadius) * (1 - inverse / maxInverse);
                    return Math.min(maxRadius, Math.max(minRadius, inverseRadius));
                }
                
                case 'exponential': {
                    // r(m) = c¬∑a^m
                    const a = exponentialBase;
                    const maxExp = Math.pow(a, Math.max(...getSelectedRings().map(id => configs[id]?.mod || 1)));
                    const exp = Math.pow(a, modulus);
                    const expRadius = minRadius + (maxRadius - minRadius) * (c * exp) / (c * maxExp);
                    return Math.min(maxRadius, expRadius);
                }
                
                default:
                    return minRadius + (maxRadius - minRadius) * index / Math.max(1, totalRings - 1);
            }
        }

        function resetRadiusScaling() {
            radiusScalingMode = 'uniform';
            scalingConstant = 1.0;
            exponentialBase = 1.15;
            
            document.getElementById('radiusScaling').value = 'uniform';
            document.getElementById('scalingConst').value = 1.0;
            document.getElementById('scalingConstValue').textContent = '1.0';
            document.getElementById('expBase').value = 1.15;
            document.getElementById('expBaseValue').textContent = '1.15';
            document.getElementById('expBaseGroup').style.display = 'none';
            
            updateScalingDescription();
            updateAnimationStatus('Radius scaling reset to uniform');
            draw();
        }

        function updateNestingInversion() {
            const value = document.getElementById('nestingInversion').value;
            document.getElementById('nestingInversionValue').textContent = parseFloat(value).toFixed(2);
            nestingInversionAmount = parseFloat(value);
            draw();
        }

        function updateNestingSpeed() {
            const value = document.getElementById('nestingSpeed').value;
            document.getElementById('nestingSpeedValue').textContent = value;
            nestingAnimationSpeed = parseFloat(value);
        }

        function startNestingAnimation() {
            const enabled = document.getElementById('enableNestingAnimation');
            enabled.checked = true;
            nestingAnimationActive = true;
            nestingAnimationProgress = 0;
            nestingAnimationDirection = 1;
            
            updateAnimationStatus('Nesting animation started');
            
            if (!animating && !isInverting) {
                animating = true;
                animate();
            }
        }

        function stopNestingAnimation() {
            nestingAnimationActive = false;
            document.getElementById('enableNestingAnimation').checked = false;
            updateAnimationStatus('Nesting animation stopped');
        }

        function resetNestingOrder() {
            nestingInversionAmount = 0;
            nestingAnimationProgress = 0;
            document.getElementById('nestingInversion').value = 0;
            document.getElementById('nestingInversionValue').textContent = '0.00';
            stopNestingAnimation();
            draw();
        }

        document.getElementById('enableNestingAnimation').addEventListener('change', function() {
            const controls = document.getElementById('nestingAnimationControls');
            controls.style.display = this.checked ? 'block' : 'none';
            
            if (this.checked) {
                startNestingAnimation();
            } else {
                stopNestingAnimation();
            }
        });

        function showRadiusComparison() {
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) {
                alert('Please select some rings first to compare scaling methods.');
                return;
            }
            
            let comparisonText = 'RING RADIUS SCALING COMPARISON\n';
            comparisonText += '=' .repeat(80) + '\n\n';
            comparisonText += `Selected Rings: ${selectedRings.length}\n`;
            comparisonText += `Scaling Constant c = ${scalingConstant}\n`;
            comparisonText += `Exponential Base a = ${exponentialBase}\n\n`;
            
            comparisonText += 'Modulus  | Uniform  | Linear   | Sqrt     | Log      | Totient  | Density  | Inverse  | Exponent\n';
            comparisonText += '-'.repeat(100) + '\n';
            
            const sortedRings = [...selectedRings].sort((a, b) => {
                if (a === 'unit') return -1;
                if (b === 'unit') return 1;
                return (configs[a]?.mod || 0) - (configs[b]?.mod || 0);
            });
            
            sortedRings.slice(0, 20).forEach((ringId, index) => {
                const config = configs[ringId];
                if (!config) return;
                
                const m = config.mod;
                const modLabel = ringId === 'unit' ? 'M=1 (Unit)' : `M=${Math.round(m)}`;
                
                // Calculate radius for each mode
                const modes = ['uniform', 'linear', 'sqrt', 'log', 'totient', 'density', 'inverse', 'exponential'];
                const radii = modes.map(mode => {
                    const oldMode = radiusScalingMode;
                    radiusScalingMode = mode;
                    const r = calculateRadius(m, index, selectedRings.length);
                    radiusScalingMode = oldMode;
                    return r.toFixed(2).padStart(8);
                });
                
                comparisonText += `${modLabel.padEnd(8)} | ${radii.join(' | ')}\n`;
            });
            
            if (sortedRings.length > 20) {
                comparisonText += `\n... and ${sortedRings.length - 20} more rings\n`;
            }
            
            comparisonText += '\n' + '='.repeat(80) + '\n';
            comparisonText += '\nMathematical Formulas:\n';
            comparisonText += '  Uniform:      Equal spacing independent of m\n';
            comparisonText += '  Linear:       r(m) = c¬∑m\n';
            comparisonText += '  Square-root:  r(m) = c¬∑‚àöm\n';
            comparisonText += '  Logarithmic:  r(m) = c¬∑log(m+1)\n';
            comparisonText += '  Totient:      r(m) = c¬∑œÜ(m)\n';
            comparisonText += '  Density:      r(m) = c¬∑œÜ(m)/m\n';
            comparisonText += '  Inverse:      r(m) = c/m\n';
            comparisonText += '  Exponential:  r(m) = c¬∑a·µê\n';
            
            // Create download
            const blob = new Blob([comparisonText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `radius_scaling_comparison_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.txt`;
            link.click();
            URL.revokeObjectURL(url);
            
            updateAnimationStatus('Radius scaling comparison exported');
        }

        // Enhanced control functions
        function clearAllGaps() {
            const gapControls = document.getElementById('gapControls');
            const checkboxes = gapControls.querySelectorAll('input[type="checkbox"]');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            updateAnimationStatus('All gaps cleared');
            draw();
        }

        function clearAllRings() {
            const ringControls = document.getElementById('ringControls');
            const checkboxes = ringControls.querySelectorAll('input[type="checkbox"]');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            updateAnimationStatus('All rings cleared');
            draw();
        }

        function resetToDefaults() {
            // First clear all rings
            clearAllRings();
            
            // Then check only the unit circle and M2-M60 defaults
            const ringControls = document.getElementById('ringControls');
            const checkboxes = ringControls.querySelectorAll('input[type="checkbox"]');
            
            checkboxes.forEach(checkbox => {
                const ringId = checkbox.value;
                if (ringId === 'unit' || ringId.startsWith('default_')) {
                    checkbox.checked = true;
                }
            });
            
            updateAnimationStatus('Reset to default rings: Unit Circle + M2-M60');
            draw();
        }

        function generateGaps() {
            const maxGap = parseInt(document.getElementById('maxGap').value);
            const gapControls = document.getElementById('gapControls');
            
            gapControls.innerHTML = '';
            
            for (let gap = 2; gap <= maxGap; gap += 2) {
                // Default: all gaps are unchecked
                addGapControl(gap, false);
            }
            
            updateAnimationStatus(`Generated even gaps 2 to ${maxGap} (all disabled by default)`);
            draw();
        }

        function addConsecutiveGaps() {
            const gapStart = parseInt(document.getElementById('gapStart').value);
            const gapEnd = parseInt(document.getElementById('gapEnd').value);
            
            if (gapStart >= gapEnd) {
                alert('Start gap must be less than end gap');
                return;
            }
            
            if (gapStart < 1) {
                alert('Gap start must be at least 1');
                return;
            }
            
            const gapControls = document.getElementById('gapControls');
            let addedCount = 0;
            
            for (let gap = gapStart; gap <= gapEnd; gap++) {
                // Check if gap already exists
                if (!document.querySelector(`#gapControls input[value="${gap}"]`)) {
                    addGapControl(gap, true); // Auto-check new gaps
                    addedCount++;
                }
            }
            
            updateAnimationStatus(`Added ${addedCount} consecutive gaps (${gapStart}-${gapEnd})`);
            draw();
        }

        function addGapControl(gap, checked = false) {
            const gapControls = document.getElementById('gapControls');
            
            const div = document.createElement('div');
            div.className = 'checkbox-item';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = gap;
            // Default: all gaps are unchecked
            checkbox.checked = checked;
            checkbox.addEventListener('change', draw);
            
            const label = document.createElement('span');
            let name = '';
            if (gap === 2) name = ' (Twin Primes)';
            else if (gap === 4) name = ' (Cousin Primes)';
            else if (gap === 6) name = ' (Sexy Primes)';
            label.textContent = `Gap ${gap}${name}`;
            
            div.appendChild(checkbox);
            div.appendChild(label);
            gapControls.appendChild(div);
        }

        function addConsecutiveMods() {
            const modStart = parseInt(document.getElementById('modStart').value);
            const modEnd = parseInt(document.getElementById('modEnd').value);
            
            if (modStart >= modEnd) {
                alert('Start modulus must be less than end modulus');
                return;
            }
            
            if (modStart < 1) {
                alert('Modulus start must be at least 1');
                return;
            }
            
            // Only warn for extremely large ranges
            if ((modEnd - modStart) > 1000) {
                if (!confirm(`This will add ${modEnd - modStart + 1} rings. This may impact performance. Continue?`)) {
                    return;
                }
            }
            
            let addedCount = 0;
            let skippedCount = 0;
            
            for (let mod = modStart; mod <= modEnd; mod++) {
                // Check if modulus already exists
                const existing = Object.values(configs).find(config => config.mod === mod);
                
                if (!existing) {
                    // Handle mod 1 as unit circle
                    if (mod === 1) {
                        // Unit circle already exists, just check it
                        const unitCheckbox = document.querySelector('#ringControls input[value="unit"]');
                        if (unitCheckbox) {
                            unitCheckbox.checked = true;
                            addedCount++;
                        }
                    } else {
                        const customId = `custom_${customRingCounter++}`;
                        configs[customId] = { 
                            mod: mod, 
                            label: mod.toString(),
                            description: `Custom modulus ${mod}`
                        };
                        
                        addRingControl(customId, `M${mod}`, true); // Auto-check new rings
                        addedCount++;
                    }
                } else {
                    // If ring exists, make sure it's checked
                    const ringControls = document.querySelectorAll('#ringControls input[type="checkbox"]');
                    ringControls.forEach(checkbox => {
                        const config = configs[checkbox.value];
                        if (config && config.mod === mod) {
                            checkbox.checked = true;
                        }
                    });
                    skippedCount++;
                }
            }
            
            updateAnimationStatus(`Added ${addedCount} rings (M${modStart}-M${modEnd}), ensured ${skippedCount} existing rings selected`);
            draw();
        }

        function addCustomRing() {
            const modValue = parseInt(document.getElementById('customMod').value);
            
            if (modValue < 1) {
                alert('Please enter a modulus of at least 1');
                return;
            }
            
            // Only warn for extremely large moduli that might impact performance
            if (modValue > 100000) {
                if (!confirm(`Modulus ${modValue} is very large and may impact performance. Continue?`)) {
                    return;
                }
            }
            
            const existing = Object.values(configs).find(config => config.mod === modValue);
            if (existing) {
                alert(`Modulus ${modValue} already exists in the ring system`);
                return;
            }
            
            const customId = `custom_${customRingCounter++}`;
            configs[customId] = { 
                mod: modValue, 
                label: modValue.toString(),
                description: `Custom modulus ${modValue}`
            };
            
            addRingControl(customId, `M${modValue}`, true);
            updateAnimationStatus(`Added single custom ring M${modValue}`);
            draw();
        }

        function addRingControl(ringId, displayText, checked = false) {
            const ringControls = document.getElementById('ringControls');
            
            const div = document.createElement('div');
            div.className = 'checkbox-item';
            div.id = `ring_${ringId}`;
            
            // Special styling for unit circle
            if (ringId === 'unit') {
                div.classList.add('unit-circle-highlight');
            }
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = ringId;
            checkbox.checked = checked;
            checkbox.addEventListener('change', draw);
            
            const label = document.createElement('span');
            label.textContent = displayText;
            
            if (ringId.startsWith('custom_')) {
                const removeBtn = document.createElement('button');
                removeBtn.textContent = '√ó';
                removeBtn.style.marginLeft = '10px';
                removeBtn.style.padding = '4px 8px';
                removeBtn.style.fontSize = '12px';
                removeBtn.style.background = '#e74c3c';
                removeBtn.style.minWidth = '24px';
                removeBtn.onclick = () => removeCustomRing(ringId);
                div.appendChild(checkbox);
                div.appendChild(label);
                div.appendChild(removeBtn);
            } else {
                div.appendChild(checkbox);
                div.appendChild(label);
            }
            
            ringControls.appendChild(div);
        }

        function removeCustomRing(ringId) {
            delete configs[ringId];
            const element = document.getElementById(`ring_${ringId}`);
            if (element) {
                element.remove();
            }
            updateAnimationStatus('Removed custom ring');
            draw();
        }

        function updateAnimationStatus(message) {
            const status = document.getElementById('animationStatus');
            status.textContent = message;
            setTimeout(() => {
                if (isInverting) {
                    status.textContent = 'Inversion Active';
                } else if (animating) {
                    status.textContent = 'Animating';
                } else {
                    status.textContent = 'Ready';
                }
            }, 2000);
        }

        function updateAnimDuration() {
            const value = document.getElementById('animDuration').value;
            document.getElementById('animDurationValue').textContent = value;
        }

        function updateAnimFps() {
            const value = document.getElementById('animFps').value;
            document.getElementById('animFpsValue').textContent = value;
        }

        function updateZoom() {
            const value = document.getElementById('zoomSlider').value;
            currentZoom = parseFloat(value);
            document.getElementById('zoomValue').textContent = value;
            draw();
        }

        function resetView() {
            panX = 0;
            panY = 0;
            currentZoom = 1;
            document.getElementById('zoomSlider').value = 1;
            document.getElementById('zoomValue').textContent = '1.0';
            updateAnimationStatus('View reset to center');
            draw();
        }

        function updateRotation() {
            const value = document.getElementById('rotationSlider').value;
            document.getElementById('rotationValue').textContent = value + '¬∞';
            draw();
        }

        function updateThickness() {
            const value = document.getElementById('lineThickness').value;
            document.getElementById('thicknessValue').textContent = value;
            draw();
        }

        function updateGapThickness() {
            const value = document.getElementById('gapLineThickness').value;
            document.getElementById('gapThicknessValue').textContent = value;
            draw();
        }
        
        function updateRingThickness() {
            const value = document.getElementById('ringThickness').value;
            document.getElementById('ringThicknessValue').textContent = value;
            draw();
        }
        
        function updateUnitThickness() {
            const value = document.getElementById('unitThickness').value;
            document.getElementById('unitThicknessValue').textContent = value;
            draw();
        }
        
        function updatePointSize() {
            const value = document.getElementById('pointSize').value;
            document.getElementById('pointSizeValue').textContent = value;
            draw();
        }
        
        function updatePointBorder() {
            const value = document.getElementById('pointBorder').value;
            document.getElementById('pointBorderValue').textContent = value;
            draw();
        }

        function updateLabelSize() {
            const value = document.getElementById('labelSize').value;
            document.getElementById('labelSizeValue').textContent = value;
            draw();
        }

        function updateLabelOpacity() {
            const value = document.getElementById('labelOpacity').value;
            document.getElementById('labelOpacityValue').textContent = value;
            draw();
        }

        function updateInversionIntensity() {
            const value = document.getElementById('inversionIntensity').value;
            document.getElementById('inversionIntensityValue').textContent = value;
            inversionIntensity = parseFloat(value);
            draw();
        }

        function updateSpecificLabels() {
            const input = document.getElementById('labelSpecificMods').value;
            specificLabelMods.clear();
            
            if (input.trim()) {
                const mods = input.split(',').map(s => s.trim()).filter(s => s);
                mods.forEach(mod => {
                    const num = parseInt(mod);
                    if (!isNaN(num) && num > 0) {
                        specificLabelMods.add(num);
                    }
                });
            }
            
            updateAnimationStatus(`Specific labeling applied to moduli: [${Array.from(specificLabelMods).join(', ')}]`);
            draw();
        }
        
        function updateLabelRange() {
            const modStart = parseInt(document.getElementById('labelModStart').value);
            const modEnd = parseInt(document.getElementById('labelModEnd').value);
            
            if (modStart >= modEnd) {
                alert('Start modulus must be less than end modulus');
                return;
            }
            
            specificLabelMods.clear();
            for (let m = modStart; m <= modEnd; m++) {
                specificLabelMods.add(m);
            }
            
            updateAnimationStatus(`Label range applied: M${modStart} to M${modEnd}`);
            draw();
        }

        // High-quality animation recording system
        function startRecording() {
            if (isRecording) {
                stopRecording();
                return;
            }
            
            const format = document.querySelector('input[name="animationFormat"]:checked').value;
            const duration = parseInt(document.getElementById('animDuration').value);
            const fps = parseInt(document.getElementById('animFps').value);
            const resolution = document.getElementById('animResolution').value;
            
            // Get recording dimensions
            let recordWidth, recordHeight;
            switch(resolution) {
                case '1080p':
                    recordWidth = 1920;
                    recordHeight = 1080;
                    break;
                case '1440p':
                    recordWidth = 2560;
                    recordHeight = 1440;
                    break;
                case '4k':
                    recordWidth = 3840;
                    recordHeight = 2160;
                    break;
                case 'custom':
                    recordWidth = parseInt(document.getElementById('customWidth').value);
                    recordHeight = parseInt(document.getElementById('customHeight').value);
                    break;
                default:
                    recordWidth = 3840;
                    recordHeight = 2160;
            }
            
            // Create high-resolution recording canvas
            recordingCanvas = document.createElement('canvas');
            recordingCanvas.width = recordWidth;
            recordingCanvas.height = recordHeight;
            
            updateAnimationStatus(`Starting ${format.toUpperCase()} recording: ${recordWidth}√ó${recordHeight} @ ${fps}fps for ${duration}s...`);
            
            if (format === 'gif') {
                startGifRecording(duration, fps, recordWidth, recordHeight);
            } else {
                startVideoRecording(format, duration, fps, recordWidth, recordHeight);
            }
        }

        function startVideoRecording(format, duration, fps, width, height) {
            try {
                // Get canvas stream with specified frame rate
                recordingStream = recordingCanvas.captureStream(fps);
                
                // Configure MediaRecorder based on format
                let mimeType;
                let options = {
                    videoBitsPerSecond: 8000000 // 8 Mbps for high quality
                };
                
                if (format === 'webm') {
                    if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                        mimeType = 'video/webm;codecs=vp9';
                        options.videoBitsPerSecond = 12000000; // Higher bitrate for VP9
                    } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                        mimeType = 'video/webm;codecs=vp8';
                    } else {
                        mimeType = 'video/webm';
                    }
                } else {
                    // MP4 fallback
                    if (MediaRecorder.isTypeSupported('video/mp4;codecs=h264')) {
                        mimeType = 'video/mp4;codecs=h264';
                    } else if (MediaRecorder.isTypeSupported('video/mp4')) {
                        mimeType = 'video/mp4';
                    } else {
                        // Fallback to WebM if MP4 not supported
                        mimeType = 'video/webm';
                    }
                }
                
                mediaRecorder = new MediaRecorder(recordingStream, {
                    mimeType: mimeType,
                    ...options
                });
                
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: mimeType });
                    downloadRecording(blob, format);
                    cleanupRecording();
                };
                
                // Start recording
                isRecording = true;
                frameCount = 0;
                recordingStartTime = Date.now();
                
                // Enable animation if not already running
                if (!animating) {
                    document.getElementById('enableRotation').checked = true;
                    toggleRotation();
                }
                
                mediaRecorder.start(100); // Collect data every 100ms
                
                // Update button
                const recordBtn = document.getElementById('recordButton');
                recordBtn.textContent = '‚èπÔ∏è Stop Recording';
                recordBtn.style.background = 'linear-gradient(45deg, #e74c3c, #c0392b)';
                
                // Schedule automatic stop
                setTimeout(() => {
                    if (isRecording) {
                        stopRecording();
                    }
                }, duration * 1000);
                
                // Start the recording animation loop
                recordFrame(fps);
                
            } catch (error) {
                alert('Error starting video recording: ' + error.message);
                cleanupRecording();
            }
        }

        function startGifRecording(duration, fps, width, height) {
            // For GIF, we'll collect frames and use a simple encoder
            updateAnimationStatus(`Preparing GIF recording: ${width}√ó${height} @ ${fps}fps for ${duration}s...`);
            
            const frames = [];
            const totalFrames = duration * fps;
            let currentFrame = 0;
            
            isRecording = true;
            frameCount = 0;
            recordingStartTime = Date.now();
            
            // Enable animation if not already running
            if (!animating) {
                document.getElementById('enableRotation').checked = true;
                toggleRotation();
            }
            
            // Update button
            const recordBtn = document.getElementById('recordButton');
            recordBtn.textContent = '‚èπÔ∏è Stop Recording';
            recordBtn.style.background = 'linear-gradient(45deg, #e74c3c, #c0392b)';
            
            function captureGifFrame() {
                if (!isRecording || currentFrame >= totalFrames) {
                    // Encoding complete
                    createGifFromFrames(frames, fps, width, height);
                    return;
                }
                
                // Render current frame to recording canvas
                renderFrameToCanvas(recordingCanvas);
                
                // Capture frame data
                const imageData = recordingCanvas.getContext('2d').getImageData(0, 0, width, height);
                frames.push({
                    data: imageData.data,
                    width: width,
                    height: height
                });
                
                currentFrame++;
                frameCount++;
                
                // Update progress
                const progress = (currentFrame / totalFrames * 100).toFixed(1);
                updateAnimationStatus(`Capturing GIF frames: ${progress}% (${currentFrame}/${totalFrames})`);
                
                // Schedule next frame
                setTimeout(captureGifFrame, 1000 / fps);
            }
            
            captureGifFrame();
        }

        function recordFrame(fps) {
            if (!isRecording) return;
            
            // Render current animation state to recording canvas
            renderFrameToCanvas(recordingCanvas);
            frameCount++;
            
            // Update status
            const elapsed = (Date.now() - recordingStartTime) / 1000;
            const duration = parseInt(document.getElementById('animDuration').value);
            const progress = (elapsed / duration * 100).toFixed(1);
            updateAnimationStatus(`Recording: ${progress}% (${frameCount} frames, ${elapsed.toFixed(1)}s)`);
            
            // Schedule next frame
            if (isRecording) {
                setTimeout(() => recordFrame(fps), 1000 / fps);
            }
        }

        function renderFrameToCanvas(targetCanvas) {
            const targetCtx = targetCanvas.getContext('2d');
            const scaleX = targetCanvas.width / canvas.width;
            const scaleY = targetCanvas.height / canvas.height;
            
            // Clear the recording canvas
            targetCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
            
            // Scale and draw the main canvas
            targetCtx.save();
            targetCtx.scale(scaleX, scaleY);
            targetCtx.drawImage(canvas, 0, 0);
            targetCtx.restore();
            
            // Add title and legend if enabled (scaled appropriately)
            const includeTitle = document.getElementById('includeTitle').checked;
            const includeLegend = document.getElementById('includeLegend').checked;
            
            if (includeTitle) {
                const selectedRings = getSelectedRings();
                const selectedGaps = getSelectedGaps();
                const { title, subtitle } = generateConfigurationDescription(selectedRings, selectedGaps);
                
                targetCtx.fillStyle = '#2c3e50';
                targetCtx.font = `bold ${24 * scaleX}px Segoe UI`;
                targetCtx.textAlign = 'center';
                targetCtx.fillText(title, targetCanvas.width / 2, 30 * scaleY);
                
                targetCtx.fillStyle = '#34495e';
                targetCtx.font = `${14 * scaleX}px Segoe UI`;
                targetCtx.fillText(subtitle.substring(0, 120) + (subtitle.length > 120 ? '...' : ''), 
                    targetCanvas.width / 2, 55 * scaleY);
            }
        }

        function createGifFromFrames(frames, fps, width, height) {
            updateAnimationStatus('Encoding GIF... This may take a moment.');
            
            // Simple GIF encoding (this is a basic implementation)
            // For production, you'd want to use a more sophisticated GIF encoder
            
            // Create a simple animated data structure
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // For now, we'll create a WebM and suggest the user convert it
            // A full GIF encoder would be quite complex to implement here
            alert('GIF encoding requires additional libraries. The recording has been saved as WebM format instead. You can convert it to GIF using online tools or software like FFmpeg.');
            
            // Convert to WebM instead
            startVideoRecording('webm', parseInt(document.getElementById('animDuration').value), fps, width, height);
        }

        function stopRecording() {
            if (!isRecording) return;
            
            isRecording = false;
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            // Reset button
            const recordBtn = document.getElementById('recordButton');
            recordBtn.textContent = 'üé¨ Record Animation';
            recordBtn.style.background = 'linear-gradient(45deg, #FF6B6B, #4ECDC4)';
            
            updateAnimationStatus('Recording stopped, processing...');
        }

        function downloadRecording(blob, format) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            
            const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,'-');
            const selectedRings = getSelectedRings();
            const selectedGaps = getSelectedGaps();
            
            const ringText = selectedRings.length > 0 ? `_${selectedRings.length}rings` : '';
            const gapText = selectedGaps.length > 0 ? `_${selectedGaps.length}gaps` : '';
            const resolution = document.getElementById('animResolution').value;
            const duration = document.getElementById('animDuration').value;
            const fps = document.getElementById('animFps').value;
            
            link.href = url;
            link.download = `modular_rings_animation${ringText}${gapText}_${resolution}_${duration}s_${fps}fps_${timestamp}.${format}`;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
            
            const fileSize = (blob.size / (1024 * 1024)).toFixed(2);
            updateAnimationStatus(`${format.toUpperCase()} animation saved! (${fileSize} MB)`);
        }

        function cleanupRecording() {
            isRecording = false;
            frameCount = 0;
            recordedChunks = [];
            
            if (recordingStream) {
                recordingStream.getTracks().forEach(track => track.stop());
                recordingStream = null;
            }
            
            if (recordingCanvas) {
                recordingCanvas = null;
            }
            
            mediaRecorder = null;
        }

        function resetView() {
            panX = 0;
            panY = 0;
            currentZoom = 1;
            document.getElementById('zoomSlider').value = 1;
            document.getElementById('zoomValue').textContent = '1.0';
            updateAnimationStatus('View reset to center');
            draw();
        }

        function generateConfigurationDescription(selectedRings, selectedGaps) {
            const ringCount = selectedRings.length;
            const gapCount = selectedGaps.length;
            const hasUnitCircle = selectedRings.includes('unit');
            
            let title = 'Interactive Modular Lifting Rings';
            let subtitle = '';
            
            // Generate detailed arrangement description
            if (ringCount === 0) {
                subtitle = 'No rings selected';
            } else {
                // Count different types of rings
                const defaultRings = selectedRings.filter(r => r.startsWith('default_')).length;
                const customRings = selectedRings.filter(r => r.startsWith('custom_')).length;
                const seriesRings = selectedRings.filter(r => !r.startsWith('default_') && !r.startsWith('custom_') && r !== 'unit').length;
                const sieveRings = selectedRings.filter(r => r.startsWith('sieve_')).length;
                
                let ringDescription = '';
                if (hasUnitCircle) {
                    ringDescription = 'Unit Circle';
                    if (ringCount > 1) {
                        ringDescription += ' + ';
                        
                        const otherParts = [];
                        if (defaultRings > 0) otherParts.push(`M1-M${defaultRings + 1}`);
                        if (seriesRings > 0) otherParts.push(`${seriesRings} Series Rings`);
                        if (customRings > 0) otherParts.push(`${customRings} Custom`);
                        if (sieveRings > 0) otherParts.push(`${sieveRings} Sieve`);
                        
                        ringDescription += otherParts.join(' + ');
                    }
                } else {
                    const parts = [];
                    if (defaultRings > 0) parts.push(`M1-M${defaultRings + 1}`);
                    if (seriesRings > 0) parts.push(`${seriesRings} Series`);
                    if (customRings > 0) parts.push(`${customRings} Custom`);
                    if (sieveRings > 0) parts.push(`${sieveRings} Sieve`);
                    
                    ringDescription = parts.join(' + ') || `${ringCount} Rings`;
                }
                
                subtitle = ringDescription;
                
                // Add gap analysis info
                if (gapCount > 0) {
                    if (gapCount === 1) {
                        const gap = selectedGaps[0];
                        let gapName = '';
                        if (gap === 2) gapName = ' (Twin Primes)';
                        else if (gap === 4) gapName = ' (Cousin Primes)';
                        else if (gap === 6) gapName = ' (Sexy Primes)';
                        subtitle += ` ‚Ä¢ Gap ${gap}${gapName}`;
                    } else {
                        const minGap = Math.min(...selectedGaps);
                        const maxGap = Math.max(...selectedGaps);
                        if (selectedGaps.length <= 3) {
                            subtitle += ` ‚Ä¢ Gaps [${selectedGaps.join(', ')}]`;
                        } else {
                            subtitle += ` ‚Ä¢ ${gapCount} Gaps (${minGap}-${maxGap})`;
                        }
                    }
                }
                
                // Add prime sieve info
                if (primeData.isActive) {
                    subtitle += ` ‚Ä¢ Prime Sieve (mod ${primeData.modulus}, ${primeData.totalPrimes} primes)`;
                }
                
                // Add configuration details
                const colorMode = document.getElementById('residueColorMode').value;
                const showLifts = document.getElementById('showDirectLifts').checked;
                const showModular = document.getElementById('showModularLifts').checked;
                const gcdFilter = document.getElementById('showGcdOne').checked;
                
                let configDetails = [];
                if (colorMode !== 'hue') {
                    const modeNames = {
                        'value': 'Value Coloring',
                        'modulo': 'Ring Coloring',
                        'prime': 'Prime Analysis',
                        'gcd_unified': 'GCD Unified',
                        'gcd_per_mod': 'GCD per Ring',
                        'gcd_per_residue': 'GCD per Residue',
                        'custom': 'Custom Color'
                    };
                    configDetails.push(modeNames[colorMode] || colorMode);
                }
                
                if (showLifts) configDetails.push('Direct Lifts');
                if (showModular) configDetails.push('Modular Lifts');
                if (!gcdFilter) configDetails.push('All Residues');
                
                if (configDetails.length > 0) {
                    subtitle += ` ‚Ä¢ ${configDetails.join(' + ')}`;
                }
            }
            
            return { title, subtitle };
        }

        // Enhanced screenshot function with title, subtitle, legend, and watermark
        function captureImage() {
            try {
                const selectedRings = getSelectedRings();
                const selectedGaps = getSelectedGaps();
                const includeTitle = document.getElementById('includeTitle')?.checked ?? true;
                const includeLegend = document.getElementById('includeLegend')?.checked ?? true;
                const backgroundChoice = document.querySelector('input[name="screenshotBg"]:checked')?.value || 'black';
                const resolutionChoice = document.querySelector('input[name="screenshotResolution"]:checked')?.value || 'standard';
                
                // Determine canvas dimensions
                let baseWidth, baseHeight, scaleFactor;
                if (resolutionChoice === '4k') {
                    baseWidth = 3200;
                    baseHeight = 2400;
                    scaleFactor = baseWidth / canvas.width;
                } else {
                    baseWidth = canvas.width * 1.2;
                    baseHeight = canvas.height * 1.2;
                    scaleFactor = 1.2;
                }
                
                // Calculate layout dimensions - LARGER LEGEND for comprehensive details
                const titleHeight = includeTitle ? 120 * scaleFactor : 0;
                const legendWidth = includeLegend ? 650 * scaleFactor : 0; // INCREASED from 400
                const padding = 30 * scaleFactor;
                const contentPadding = 20 * scaleFactor;
                
                // Create screenshot canvas - height matches main content, no extra space
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = baseWidth + legendWidth + (includeLegend ? padding * 3 : contentPadding * 2);
                tempCanvas.height = baseHeight + titleHeight + contentPadding * 2;
                
                // Set background
                tempCtx.fillStyle = backgroundChoice === 'white' ? '#ffffff' : '#000000';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                
                const textColor = backgroundChoice === 'white' ? '#2c3e50' : '#ffffff';
                const accentColor = backgroundChoice === 'white' ? '#e67e22' : '#f39c12';
                const subtleColor = backgroundChoice === 'white' ? '#7f8c8d' : '#bdc3c7';
                
                // Draw title and subtitle
                if (includeTitle) {
                    const { title, subtitle } = generateConfigurationDescription(selectedRings, selectedGaps);
                    
                    tempCtx.fillStyle = accentColor;
                    tempCtx.font = `bold ${28 * scaleFactor}px Segoe UI`;
                    tempCtx.textAlign = 'center';
                    const titleCenterX = contentPadding + baseWidth / 2;
                    tempCtx.fillText(title, titleCenterX, 40 * scaleFactor);
                    
                    tempCtx.fillStyle = textColor;
                    tempCtx.font = `${16 * scaleFactor}px Segoe UI`;
                    
                    const maxSubtitleWidth = baseWidth - contentPadding * 2;
                    const words = subtitle.split(' ');
                    let line = '';
                    let y = 70 * scaleFactor;
                    const lineHeight = 22 * scaleFactor;
                    
                    for (let i = 0; i < words.length; i++) {
                        const testLine = line + words[i] + ' ';
                        const metrics = tempCtx.measureText(testLine);
                        
                        if (metrics.width > maxSubtitleWidth && line !== '') {
                            tempCtx.fillText(line.trim(), titleCenterX, y);
                            line = words[i] + ' ';
                            y += lineHeight;
                        } else {
                            line = testLine;
                        }
                    }
                    tempCtx.fillText(line.trim(), titleCenterX, y);
                }
                
                // Draw main canvas
                const mainCanvasX = contentPadding;
                const mainCanvasY = titleHeight + contentPadding;
                
                tempCtx.save();
                tempCtx.translate(mainCanvasX, mainCanvasY);
                tempCtx.scale(scaleFactor, scaleFactor);
                tempCtx.drawImage(canvas, 0, 0);
                tempCtx.restore();
                
                // Draw COMPREHENSIVE LEGEND - compact, no wasted space
                if (includeLegend) {
                    const legendX = baseWidth + contentPadding + padding;
                    const legendY = titleHeight + contentPadding;
                    const legendContentWidth = legendWidth - padding * 2;
                    const legendContentHeight = baseHeight; // Match main canvas height
                    
                    tempCtx.fillStyle = backgroundChoice === 'white' ? 'rgba(248, 249, 250, 0.95)' : 'rgba(20, 20, 20, 0.95)';
                    tempCtx.fillRect(legendX, legendY, legendContentWidth, legendContentHeight);
                    tempCtx.strokeStyle = backgroundChoice === 'white' ? 'rgba(0, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.2)';
                    tempCtx.lineWidth = 2 * scaleFactor;
                    tempCtx.strokeRect(legendX, legendY, legendContentWidth, legendContentHeight);
                    
                    // SECTION 1: HEADER
                    tempCtx.fillStyle = accentColor;
                    tempCtx.font = `bold ${18 * scaleFactor}px Segoe UI`;
                    tempCtx.textAlign = 'left';
                    let currentY = legendY + 30 * scaleFactor;
                    tempCtx.fillText('Configuration Details', legendX + 15 * scaleFactor, currentY);
                    
                    currentY += 35 * scaleFactor;
                    
                    const fontSize = 11 * scaleFactor;
                    const lineHeight = 15 * scaleFactor;
                    const sectionGap = 20 * scaleFactor;
                    const leftMargin = legendX + 15 * scaleFactor;
                    
                    // Active Parameters Header
                    tempCtx.fillStyle = accentColor;
                    tempCtx.font = `bold ${12 * scaleFactor}px Segoe UI`;
                    tempCtx.fillText('Active Parameters:', leftMargin, currentY);
                    currentY += lineHeight * 1.3;
                    
                    tempCtx.fillStyle = textColor;
                    tempCtx.font = `${fontSize}px Segoe UI`;
                    
                    // Count ring types
                    const ringCounts = {
                        unit: selectedRings.filter(r => r === 'unit').length,
                        defaults: selectedRings.filter(r => r.startsWith('default_')).length,
                        custom: selectedRings.filter(r => r.startsWith('custom_')).length,
                        series: selectedRings.filter(r => !r.startsWith('default_') && !r.startsWith('custom_') && r !== 'unit').length
                    };
                    
                    tempCtx.fillText(`Total Rings Selected: ${selectedRings.length}`, leftMargin, currentY);
                    currentY += lineHeight;
                    
                    if (ringCounts.unit > 0) {
                        tempCtx.fillText(`‚Ä¢ Unit Circle (M=1): ${ringCounts.unit}`, leftMargin, currentY);
                        currentY += lineHeight;
                    }
                    if (ringCounts.defaults > 0) {
                        const minMod = Math.min(...selectedRings.filter(r => r.startsWith('default_')).map(r => configs[r].mod));
                        const maxMod = Math.max(...selectedRings.filter(r => r.startsWith('default_')).map(r => configs[r].mod));
                        tempCtx.fillText(`‚Ä¢ Default Range: M${minMod}-M${maxMod} (${ringCounts.defaults} rings)`, leftMargin, currentY);
                        currentY += lineHeight;
                    }
                    if (ringCounts.series > 0) {
                        tempCtx.fillText(`‚Ä¢ Series Rings: ${ringCounts.series}`, leftMargin, currentY);
                        currentY += lineHeight;
                    }
                    if (ringCounts.custom > 0) {
                        tempCtx.fillText(`‚Ä¢ Custom Moduli: ${ringCounts.custom}`, leftMargin, currentY);
                        currentY += lineHeight;
                    }
                    
                    // Total Euler totient
                    const totalEuler = selectedRings.reduce((sum, id) => sum + (configs[id] ? getCoprimes(configs[id].mod).length : 0), 0);
                    tempCtx.fillStyle = accentColor;
                    tempCtx.fillText(`Œ£œÜ(M) = ${totalEuler} total character support`, leftMargin, currentY);
                    currentY += sectionGap;
                    
                    // SECTION 3: COLOR SCHEME DETAILS
                    tempCtx.fillStyle = accentColor;
                    tempCtx.font = `bold ${13 * scaleFactor}px Segoe UI`;
                    tempCtx.fillText('‚ïê‚ïê‚ïê COLOR SCHEME ‚ïê‚ïê‚ïê', leftMargin, currentY);
                    currentY += lineHeight * 1.5;
                    
                    const colorMode = document.getElementById('residueColorMode').value;
                    const colorModeNames = {
                        'hue': 'Rainbow (Angular Œ∏=2œÄr/M)',
                        'value': 'By Residue Value',
                        'modulo': 'By Ring/Modulus',
                        'prime': 'Prime vs Composite',
                        'gcd_unified': 'GCD=1 Unified Color',
                        'gcd_per_mod': 'GCD=1 Per Modulus',
                        'gcd_per_residue': 'GCD=1 Per Residue',
                        'gcd_mathematical': 'GCD=1 Mathematical',
                        'gcd_spectrum': 'GCD=1 Spectral',
                        'custom': 'Custom Single Color'
                    };
                    
                    tempCtx.fillStyle = textColor;
                    tempCtx.font = `${fontSize}px Segoe UI`;
                    tempCtx.fillText(`Mode: ${colorModeNames[colorMode]}`, leftMargin, currentY);
                    currentY += lineHeight;
                    
                    // Show actual colors being used
                    if (colorMode.startsWith('gcd_') || colorMode === 'custom') {
                        const gcdColor = document.getElementById('gcdBaseColor')?.value || document.getElementById('customResidueColor')?.value || '#FF6B6B';
                        const nonGcdColor = document.getElementById('nonGcdColor')?.value || '#666666';
                        
                        // Draw color swatches
                        tempCtx.fillStyle = gcdColor;
                        tempCtx.fillRect(leftMargin, currentY - 8 * scaleFactor, 12 * scaleFactor, 12 * scaleFactor);
                        tempCtx.fillStyle = textColor;
                        tempCtx.fillText(`GCD=1: ${gcdColor}`, leftMargin + 16 * scaleFactor, currentY);
                        currentY += lineHeight;
                        
                        tempCtx.fillStyle = nonGcdColor;
                        tempCtx.fillRect(leftMargin, currentY - 8 * scaleFactor, 12 * scaleFactor, 12 * scaleFactor);
                        tempCtx.fillStyle = textColor;
                        tempCtx.fillText(`GCD‚â†1: ${nonGcdColor}`, leftMargin + 16 * scaleFactor, currentY);
                        currentY += lineHeight;
                    }
                    
                    const liftLineColor = document.getElementById('liftLineColor').value;
                    const modularLiftColor = document.getElementById('modularLiftColor').value;
                    
                    tempCtx.fillStyle = liftLineColor;
                    tempCtx.fillRect(leftMargin, currentY - 8 * scaleFactor, 12 * scaleFactor, 12 * scaleFactor);
                    tempCtx.fillStyle = textColor;
                    tempCtx.fillText(`Direct Lifts: ${liftLineColor}`, leftMargin + 16 * scaleFactor, currentY);
                    currentY += lineHeight;
                    
                    tempCtx.fillStyle = modularLiftColor;
                    tempCtx.fillRect(leftMargin, currentY - 8 * scaleFactor, 12 * scaleFactor, 12 * scaleFactor);
                    tempCtx.fillStyle = textColor;
                    tempCtx.fillText(`Modular Lifts: ${modularLiftColor}`, leftMargin + 16 * scaleFactor, currentY);
                    currentY += sectionGap;
                    
                    // SECTION 4: GAP ANALYSIS
                    if (selectedGaps.length > 0) {
                        tempCtx.fillStyle = accentColor;
                        tempCtx.font = `bold ${13 * scaleFactor}px Segoe UI`;
                        tempCtx.fillText('‚ïê‚ïê‚ïê GAP ANALYSIS ‚ïê‚ïê‚ïê', leftMargin, currentY);
                        currentY += lineHeight * 1.5;
                        
                        tempCtx.fillStyle = textColor;
                        tempCtx.font = `${fontSize}px Segoe UI`;
                        tempCtx.fillText(`Active Gaps: [${selectedGaps.join(', ')}]`, leftMargin, currentY);
                        currentY += lineHeight;
                        
                        selectedGaps.forEach(gap => {
                            let gapName = '';
                            if (gap === 2) gapName = ' (Twin Primes)';
                            else if (gap === 4) gapName = ' (Cousin Primes)';
                            else if (gap === 6) gapName = ' (Sexy Primes)';
                            tempCtx.fillText(`  Gap ${gap}${gapName}`, leftMargin, currentY);
                            currentY += lineHeight;
                        });
                        currentY += sectionGap - lineHeight;
                    }
                    
                    // SECTION 5: PRIME SIEVE (if active) - COMPREHENSIVE DETAILS
                    if (primeData.isActive) {
                        tempCtx.fillStyle = accentColor;
                        tempCtx.font = `bold ${13 * scaleFactor}px Segoe UI`;
                        tempCtx.fillText('‚ïê‚ïê‚ïê PRIME SIEVE DETAILS ‚ïê‚ïê‚ïê', leftMargin, currentY);
                        currentY += lineHeight * 1.5;
                        
                        tempCtx.fillStyle = textColor;
                        tempCtx.font = `${fontSize}px Segoe UI`;
                        
                        // Basic sieve parameters
                        tempCtx.fillText(`Modulus: ${primeData.modulus}`, leftMargin, currentY);
                        currentY += lineHeight;
                        tempCtx.fillText(`Search Limit: ${primeData.limit.toLocaleString()}`, leftMargin, currentY);
                        currentY += lineHeight;
                        tempCtx.fillText(`Total Primes Found: ${primeData.totalPrimes.toLocaleString()}`, leftMargin, currentY);
                        currentY += lineHeight;
                        
                        const eulerPhi = getCoprimes(primeData.modulus).length;
                        tempCtx.fillText(`œÜ(${primeData.modulus}) = ${eulerPhi} residue classes`, leftMargin, currentY);
                        currentY += lineHeight;
                        
                        const avgPerClass = (primeData.totalPrimes / eulerPhi).toFixed(2);
                        tempCtx.fillText(`Avg primes per class: ${avgPerClass}`, leftMargin, currentY);
                        currentY += lineHeight;
                        
                        const primeDensity = (primeData.totalPrimes / primeData.limit * 100).toFixed(3);
                        tempCtx.fillText(`Prime density: ${primeDensity}%`, leftMargin, currentY);
                        currentY += lineHeight;
                        
                        // Uniformity analysis
                        const uniformity = calculateEquidistributionScore();
                        tempCtx.fillStyle = uniformity.uniformityScore > 0.85 ? '#4ECDC4' : '#FFA500';
                        tempCtx.fillText(`Uniformity: ${(uniformity.uniformityScore * 100).toFixed(1)}%`, leftMargin, currentY);
                        currentY += lineHeight;
                        
                        tempCtx.fillStyle = textColor;
                        tempCtx.fillText(`Chi-squared: œá¬≤ = ${uniformity.chiSquared.toFixed(2)}`, leftMargin, currentY);
                        currentY += lineHeight;
                        tempCtx.fillText(`GRH Support: ${uniformity.grhSupport}`, leftMargin, currentY);
                        currentY += lineHeight;
                        
                        // Top 3 residue classes by prime count
                        const sortedResidues = Object.entries(primeData.residueDistribution)
                            .sort((a, b) => b[1].count - a[1].count)
                            .slice(0, 3);
                        
                        tempCtx.fillStyle = accentColor;
                        tempCtx.font = `${fontSize}px Segoe UI`;
                        tempCtx.fillText(`Top residue classes:`, leftMargin, currentY);
                        currentY += lineHeight;
                        
                        tempCtx.fillStyle = textColor;
                        sortedResidues.forEach(([residue, data], idx) => {
                            tempCtx.fillText(`  ${idx+1}. r‚â°${residue}: ${data.count} (${data.percentage}%)`, leftMargin, currentY);
                            currentY += lineHeight;
                        });
                        
                        currentY += sectionGap - lineHeight;
                    }
                    
                    // SECTION 6: VISUAL PARAMETERS
                    tempCtx.fillStyle = accentColor;
                    tempCtx.font = `bold ${13 * scaleFactor}px Segoe UI`;
                    tempCtx.fillText('‚ïê‚ïê‚ïê VISUAL PARAMETERS ‚ïê‚ïê‚ïê', leftMargin, currentY);
                    currentY += lineHeight * 1.5;
                    
                    tempCtx.fillStyle = textColor;
                    tempCtx.font = `${fontSize}px Segoe UI`;
                    
                    // Thickness parameters
                    const lineThickness = parseFloat(document.getElementById('lineThickness').value);
                    const gapThickness = parseFloat(document.getElementById('gapLineThickness').value);
                    const ringThickness = parseFloat(document.getElementById('ringThickness').value);
                    const pointSize = parseFloat(document.getElementById('pointSize').value);
                    
                    tempCtx.fillText(`Lift Lines: ${(lineThickness * 100).toFixed(0)}%`, leftMargin, currentY);
                    currentY += lineHeight;
                    tempCtx.fillText(`Gap Lines: ${(gapThickness * 100).toFixed(0)}%`, leftMargin, currentY);
                    currentY += lineHeight;
                    tempCtx.fillText(`Ring Circles: ${(ringThickness * 100).toFixed(0)}%`, leftMargin, currentY);
                    currentY += lineHeight;
                    tempCtx.fillText(`Point Size: ${(pointSize * 100).toFixed(0)}%`, leftMargin, currentY);
                    currentY += lineHeight;
                    
                    // Zoom and rotation
                    const zoom = parseFloat(document.getElementById('zoomSlider').value);
                    const rotation = parseFloat(document.getElementById('rotationSlider').value);
                    tempCtx.fillText(`Zoom: ${zoom.toFixed(2)}x`, leftMargin, currentY);
                    currentY += lineHeight;
                    tempCtx.fillText(`Rotation: ${rotation.toFixed(0)}¬∞`, leftMargin, currentY);
                    currentY += sectionGap;
                    
                    // SECTION 7: RADIUS SCALING
                    tempCtx.fillStyle = accentColor;
                    tempCtx.font = `bold ${13 * scaleFactor}px Segoe UI`;
                    tempCtx.fillText('‚ïê‚ïê‚ïê RADIUS SCALING ‚ïê‚ïê‚ïê', leftMargin, currentY);
                    currentY += lineHeight * 1.5;
                    
                    tempCtx.fillStyle = textColor;
                    tempCtx.font = `${fontSize}px Segoe UI`;
                    
                    const scalingModes = {
                        'uniform': 'Uniform (equal spacing)',
                        'linear': 'Linear: r(m) = c¬∑m',
                        'sqrt': 'Square-root: r(m) = c¬∑‚àöm',
                        'log': 'Logarithmic: r(m) = c¬∑log(m)',
                        'totient': 'Totient: r(m) = c¬∑œÜ(m)',
                        'density': 'Density: r(m) = c¬∑œÜ(m)/m',
                        'inverse': 'Inverse: r(m) = c/m',
                        'exponential': 'Exponential: r(m) = c¬∑a·µê'
                    };
                    
                    tempCtx.fillText(`Mode: ${scalingModes[radiusScalingMode]}`, leftMargin, currentY);
                    currentY += lineHeight;
                    
                    if (radiusScalingMode !== 'uniform') {
                        tempCtx.fillText(`Constant c = ${scalingConstant.toFixed(2)}`, leftMargin, currentY);
                        currentY += lineHeight;
                        
                        if (radiusScalingMode === 'exponential') {
                            tempCtx.fillText(`Base a = ${exponentialBase.toFixed(2)}`, leftMargin, currentY);
                            currentY += lineHeight;
                        }
                    }
                    currentY += sectionGap;
                    
                    // SECTION 8: LIFT CONFIGURATION
                    tempCtx.fillStyle = accentColor;
                    tempCtx.font = `bold ${13 * scaleFactor}px Segoe UI`;
                    tempCtx.fillText('‚ïê‚ïê‚ïê LIFT CONFIGURATION ‚ïê‚ïê‚ïê', leftMargin, currentY);
                    currentY += lineHeight * 1.5;
                    
                    tempCtx.fillStyle = textColor;
                    tempCtx.font = `${fontSize}px Segoe UI`;
                    
                    const showDirect = document.getElementById('showDirectLifts').checked;
                    const showModular = document.getElementById('showModularLifts').checked;
                    const showSkipDirect = document.getElementById('showSkipDirectLifts').checked;
                    const showSkipModular = document.getElementById('showSkipModularLifts').checked;
                    
                    tempCtx.fillText(`Direct Lifts (r‚Üír): ${showDirect ? 'ON' : 'OFF'}`, leftMargin, currentY);
                    currentY += lineHeight;
                    tempCtx.fillText(`Modular Lifts (r‚Üír+M√ó2‚Åø): ${showModular ? 'ON' : 'OFF'}`, leftMargin, currentY);
                    currentY += lineHeight;
                    tempCtx.fillText(`Skip Direct: ${showSkipDirect ? 'ON' : 'OFF'}`, leftMargin, currentY);
                    currentY += lineHeight;
                    tempCtx.fillText(`Skip Modular: ${showSkipModular ? 'ON' : 'OFF'}`, leftMargin, currentY);
                    currentY += sectionGap;
                    
                    // SECTION 9: MATHEMATICAL FORMULAS
                    tempCtx.fillStyle = accentColor;
                    tempCtx.font = `bold ${13 * scaleFactor}px Segoe UI`;
                    tempCtx.fillText('‚ïê‚ïê‚ïê KEY FORMULAS ‚ïê‚ïê‚ïê', leftMargin, currentY);
                    currentY += lineHeight * 1.5;
                    
                    tempCtx.fillStyle = subtleColor;
                    tempCtx.font = `italic ${10 * scaleFactor}px Times New Roman`;
                    
                    tempCtx.fillText('œÜ(n) = n‚àè(1 - 1/p) [Euler totient]', leftMargin, currentY);
                    currentY += lineHeight;
                    tempCtx.fillText('Œ∏ = 2œÄ(M-r)/M [residue angle]', leftMargin, currentY);
                    currentY += lineHeight;
                    tempCtx.fillText('gcd(r,M)=1 ‚ü∫ œá(r)‚â†0 [character]', leftMargin, currentY);
                    currentY += lineHeight;
                    tempCtx.fillText('L(s,œá) = Œ£œá(n)/nÀ¢ [L-function]', leftMargin, currentY);
                    currentY += lineHeight;
                    
                    if (primeData.isActive) {
                        tempCtx.fillText(`œÄ(x) ~ x/ln(x) [prime counting]`, leftMargin, currentY);
                        currentY += lineHeight;
                    }
                }
                
                // ALWAYS add watermark (bottom right)
                tempCtx.fillStyle = backgroundChoice === 'white' ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.15)';
                tempCtx.font = `${10 * scaleFactor}px Segoe UI`;
                tempCtx.textAlign = 'right';
                const watermarkX = tempCanvas.width - 15 * scaleFactor;
                const watermarkY = tempCanvas.height - 10 * scaleFactor;
                tempCtx.fillText('Riemann Hypothesis Explorer | Built by Wessen Getachew', watermarkX, watermarkY);
                
                // Convert to JPEG and download
                const dataURL = tempCanvas.toDataURL('image/jpeg', 0.95);
                
                const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,'-');
                const ringText = selectedRings.length > 0 ? `_${selectedRings.length}rings` : '';
                const gapText = selectedGaps.length > 0 ? `_${selectedGaps.length}gaps` : '';
                const resText = resolutionChoice === '4k' ? '_4K' : '';
                const filename = `modular_rings${ringText}${gapText}${resText}_${timestamp}.jpg`;
                
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = filename;
                link.click();
                
                const statusMsg = resolutionChoice === '4k' 
                    ? '4K screenshot saved with watermark! üì∏' 
                    : 'Screenshot saved with watermark! üì∏';
                updateAnimationStatus(statusMsg);
            } catch (error) {
                alert('Error capturing image: ' + error.message);
                console.error('Capture error:', error);
                updateAnimationStatus('Screenshot failed');
            }
        }
        
        function generateConfigurationDescription(selectedRings, selectedGaps) {
            const ringCount = selectedRings.length;
            const gapCount = selectedGaps.length;
            const hasUnitCircle = selectedRings.includes('unit');
            
            let title = 'Interactive Modular Lifting Rings';
            let subtitle = '';
            
            if (ringCount === 0) {
                subtitle = 'No rings selected';
            } else {
                const defaultRings = selectedRings.filter(r => r.startsWith('default_')).length;
                const customRings = selectedRings.filter(r => r.startsWith('custom_')).length;
                const seriesRings = selectedRings.filter(r => !r.startsWith('default_') && !r.startsWith('custom_') && r !== 'unit').length;
                
                let ringDescription = '';
                if (hasUnitCircle) {
                    ringDescription = 'Unit Circle';
                    if (ringCount > 1) {
                        ringDescription += ' + ';
                        const otherParts = [];
                        if (defaultRings > 0) otherParts.push(`M1-M${defaultRings + 1}`);
                        if (seriesRings > 0) otherParts.push(`${seriesRings} Series`);
                        if (customRings > 0) otherParts.push(`${customRings} Custom`);
                        ringDescription += otherParts.join(' + ');
                    }
                } else {
                    const parts = [];
                    if (defaultRings > 0) parts.push(`M1-M${defaultRings + 1}`);
                    if (seriesRings > 0) parts.push(`${seriesRings} Series`);
                    if (customRings > 0) parts.push(`${customRings} Custom`);
                    ringDescription = parts.join(' + ') || `${ringCount} Rings`;
                }
                
                subtitle = ringDescription;
                
                if (gapCount > 0) {
                    if (gapCount === 1) {
                        const gap = selectedGaps[0];
                        let gapName = '';
                        if (gap === 2) gapName = ' (Twin)';
                        else if (gap === 4) gapName = ' (Cousin)';
                        else if (gap === 6) gapName = ' (Sexy)';
                        subtitle += ` ‚Ä¢ Gap ${gap}${gapName}`;
                    } else {
                        subtitle += ` ‚Ä¢ ${gapCount} Gaps`;
                    }
                }
                
                if (primeData.isActive) {
                    subtitle += ` ‚Ä¢ Sieve (mod ${primeData.modulus})`;
                }
            }
            
            return { title, subtitle };
        }
        
        // Invert ring order (like nesting animation but instant)
        let ringOrderInverted = false;
        
        function invertCanvas() {
            ringOrderInverted = !ringOrderInverted;
            
            if (ringOrderInverted) {
                // Set nesting inversion to 1.0 (fully inverted)
                nestingInversionAmount = 1.0;
                document.getElementById('nestingInversion').value = 1.0;
                document.getElementById('nestingInversionValue').textContent = '1.00';
                updateAnimationStatus('ALL rings inverted (M30 inner, M1 outer - complete reversal)');
            } else {
                // Reset to normal order
                nestingInversionAmount = 0.0;
                document.getElementById('nestingInversion').value = 0.0;
                document.getElementById('nestingInversionValue').textContent = '0.00';
                updateAnimationStatus('Ring order restored to normal (M1 inner, M30 outer)');
            }
            
            draw();
        }
        function takeScreenshot_OLD_DISABLED() {
            const selectedRings = getSelectedRings();
            const selectedGaps = getSelectedGaps();
            const includeTitle = document.getElementById('includeTitle').checked;
            const includeLegend = document.getElementById('includeLegend').checked;
            const backgroundChoice = document.querySelector('input[name="screenshotBg"]:checked').value;
            const resolutionChoice = document.querySelector('input[name="screenshotResolution"]:checked').value;
            const colorMode = document.getElementById('residueColorMode').value;
            
            // Determine canvas dimensions with proper spacing
            let baseWidth, baseHeight, scaleFactor;
            if (resolutionChoice === '4k') {
                baseWidth = 3200;  // Main content area
                baseHeight = 2400; // Main content area
                scaleFactor = baseWidth / canvas.width;
                updateAnimationStatus('Generating 4K screenshot...');
            } else {
                baseWidth = canvas.width * 1.2;  // 20% larger main area
                baseHeight = canvas.height * 1.2; // 20% larger main area
                scaleFactor = 1.2;
            }
            
            // Calculate layout dimensions with proper spacing
            const titleHeight = includeTitle ? 100 * scaleFactor : 0;
            const legendWidth = includeLegend ? 500 * scaleFactor : 0; // Wider legend
            const padding = 30 * scaleFactor;
            const contentPadding = 20 * scaleFactor; // Padding around main content
            
            // Create enhanced screenshot canvas with proper layout
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = baseWidth + legendWidth + (includeLegend ? padding * 3 : contentPadding * 2);
            tempCanvas.height = Math.max(baseHeight + titleHeight + contentPadding * 2, includeLegend ? 1200 * scaleFactor : baseHeight + titleHeight + contentPadding * 2);
            
            // Set background
            tempCtx.fillStyle = backgroundChoice === 'white' ? '#ffffff' : '#000000';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            const textColor = backgroundChoice === 'white' ? '#2c3e50' : '#ffffff';
            const accentColor = backgroundChoice === 'white' ? '#e67e22' : '#f39c12';
            const subtleColor = backgroundChoice === 'white' ? '#7f8c8d' : '#bdc3c7';
            
            // Draw title and subtitle with proper positioning
            if (includeTitle) {
                const { title, subtitle } = generateConfigurationDescription(selectedRings, selectedGaps);
                
                // Main title - centered over main content area only
                tempCtx.fillStyle = accentColor;
                tempCtx.font = `bold ${28 * scaleFactor}px Segoe UI`;
                tempCtx.textAlign = 'center';
                const titleCenterX = contentPadding + baseWidth / 2;
                tempCtx.fillText(title, titleCenterX, 40 * scaleFactor);
                
                // Subtitle with better formatting - also centered over main content
                tempCtx.fillStyle = textColor;
                tempCtx.font = `${16 * scaleFactor}px Segoe UI`;
                
                // Word wrap for subtitles within main content area
                const maxSubtitleWidth = baseWidth - contentPadding * 2;
                const words = subtitle.split(' ');
                let line = '';
                let y = 70 * scaleFactor;
                const lineHeight = 22 * scaleFactor;
                
                for (let i = 0; i < words.length; i++) {
                    const testLine = line + words[i] + ' ';
                    const metrics = tempCtx.measureText(testLine);
                    const testWidth = metrics.width;
                    
                    if (testWidth > maxSubtitleWidth && line !== '') {
                        tempCtx.fillText(line.trim(), titleCenterX, y);
                        line = words[i] + ' ';
                        y += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                tempCtx.fillText(line.trim(), titleCenterX, y);
            }
            
            // Draw main canvas content positioned properly
            const mainCanvasX = contentPadding;
            const mainCanvasY = titleHeight + contentPadding;
            
            // Scale and draw the main canvas within its designated area
            tempCtx.save();
            tempCtx.translate(mainCanvasX, mainCanvasY);
            tempCtx.scale(scaleFactor, scaleFactor);
            tempCtx.drawImage(canvas, 0, 0);
            tempCtx.restore();
            
            // Draw comprehensive legend on the right side with proper spacing
            if (includeLegend) {
                const legendX = baseWidth + contentPadding + padding;
                const legendY = titleHeight + contentPadding;
                const legendContentWidth = legendWidth - padding * 2;
                const legendContentHeight = tempCanvas.height - titleHeight - contentPadding * 2;
                
                // Legend background with proper boundaries
                tempCtx.fillStyle = backgroundChoice === 'white' ? 'rgba(248, 249, 250, 0.95)' : 'rgba(20, 20, 20, 0.95)';
                tempCtx.fillRect(legendX, legendY, legendContentWidth, legendContentHeight);
                tempCtx.strokeStyle = backgroundChoice === 'white' ? 'rgba(0, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.2)';
                tempCtx.lineWidth = 2 * scaleFactor;
                tempCtx.strokeRect(legendX, legendY, legendContentWidth, legendContentHeight);
                
                // Legend title
                tempCtx.fillStyle = accentColor;
                tempCtx.font = `bold ${18 * scaleFactor}px Segoe UI`;
                tempCtx.textAlign = 'left';
                let currentY = legendY + 30 * scaleFactor;
                tempCtx.fillText('Configuration & Legend', legendX + 15 * scaleFactor, currentY);
                
                currentY += 15 * scaleFactor;
                
                // ===== DETAILED PARAMETER SECTION =====
                tempCtx.fillStyle = backgroundChoice === 'white' ? 'rgba(52, 73, 94, 0.95)' : 'rgba(255, 255, 255, 0.95)';
                tempCtx.font = `bold ${14 * scaleFactor}px Segoe UI`;
                currentY += 20 * scaleFactor;
                tempCtx.fillText('Active Parameters:', legendX + 15 * scaleFactor, currentY);
                
                tempCtx.font = `${11 * scaleFactor}px Segoe UI`;
                currentY += 18 * scaleFactor;
                
                // Count active rings by category
                const ringCounts = {
                    unit: selectedRings.filter(r => r === 'unit').length,
                    defaults: selectedRings.filter(r => r.startsWith('default_')).length,
                    custom: selectedRings.filter(r => r.startsWith('custom_')).length,
                    sieve: selectedRings.filter(r => r.startsWith('sieve_')).length,
                    series: selectedRings.filter(r => !r.startsWith('default_') && !r.startsWith('custom_') && !r.startsWith('sieve_') && r !== 'unit').length
                };
                
                // Ring system details
                tempCtx.fillText(`‚îú‚îÄ Total Rings: ${selectedRings.length}`, legendX + 20 * scaleFactor, currentY);
                currentY += 15 * scaleFactor;
                
                if (ringCounts.unit > 0) {
                    tempCtx.fillText(`‚îÇ  ‚îú‚îÄ Unit Circle: ${ringCounts.unit}`, legendX + 20 * scaleFactor, currentY);
                    currentY += 14 * scaleFactor;
                }
                if (ringCounts.defaults > 0) {
                    const minDefault = Math.min(...selectedRings.filter(r => r.startsWith('default_')).map(r => configs[r].mod));
                    const maxDefault = Math.max(...selectedRings.filter(r => r.startsWith('default_')).map(r => configs[r].mod));
                    tempCtx.fillText(`‚îÇ  ‚îú‚îÄ Default: ${ringCounts.defaults} (M${minDefault}-M${maxDefault})`, legendX + 20 * scaleFactor, currentY);
                    currentY += 14 * scaleFactor;
                }
                if (ringCounts.series > 0) {
                    tempCtx.fillText(`‚îÇ  ‚îú‚îÄ Series: ${ringCounts.series}`, legendX + 20 * scaleFactor, currentY);
                    currentY += 14 * scaleFactor;
                }
                if (ringCounts.custom > 0) {
                    tempCtx.fillText(`‚îÇ  ‚îú‚îÄ Custom: ${ringCounts.custom}`, legendX + 20 * scaleFactor, currentY);
                    currentY += 14 * scaleFactor;
                }
                if (ringCounts.sieve > 0) {
                    tempCtx.fillText(`‚îÇ  ‚îî‚îÄ Sieve: ${ringCounts.sieve}`, legendX + 20 * scaleFactor, currentY);
                    currentY += 14 * scaleFactor;
                }
                
                // Calculate total Euler totient sum
                const totalEulerSum = selectedRings.reduce((sum, ringId) => {
                    const config = configs[ringId];
                    if (config) {
                        return sum + getCoprimes(config.mod).length;
                    }
                    return sum;
                }, 0);
                
                tempCtx.fillText(`‚îú‚îÄ Total Character Support: Œ£œÜ(M·µ¢) = ${totalEulerSum}`, legendX + 20 * scaleFactor, currentY);
                currentY += 18 * scaleFactor;
                
                // Gap analysis details
                if (selectedGaps.length > 0) {
                    tempCtx.fillText(`‚îú‚îÄ Gap Analysis: ${selectedGaps.length} active`, legendX + 20 * scaleFactor, currentY);
                    currentY += 15 * scaleFactor;
                    
                    selectedGaps.slice(0, 3).forEach((gap, idx) => {
                        let gapName = '';
                        if (gap === 2) gapName = ' (Twin)';
                        else if (gap === 4) gapName = ' (Cousin)';
                        else if (gap === 6) gapName = ' (Sexy)';
                        const prefix = idx === selectedGaps.length - 1 || idx === 2 ? '‚îÇ  ‚îî‚îÄ' : '‚îÇ  ‚îú‚îÄ';
                        tempCtx.fillText(`${prefix} Gap ${gap}${gapName}`, legendX + 20 * scaleFactor, currentY);
                        currentY += 14 * scaleFactor;
                    });
                    
                    if (selectedGaps.length > 3) {
                        tempCtx.fillText(`‚îÇ     ... and ${selectedGaps.length - 3} more`, legendX + 20 * scaleFactor, currentY);
                        currentY += 14 * scaleFactor;
                    }
                } else {
                    tempCtx.fillText(`‚îú‚îÄ Gap Analysis:         function handleResidueClick(screenX, screenY) {
            // Re-use hover detection logic
            checkResidueHover(screenX, screenY);
            
            // Future: Add click-specific behavior like isolating a ring or showing detailed analysis
            updateAnimationStatus('Click features coming in next phase!');
        }
        
        function handleDistanceMeasurementClick(screenX, screenY) {
            if (!distanceMeasurementActive) return;
            
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) return;
            
            const centerX = canvas.width / 2 + panX;
            const centerY = canvas.height / 2 + panY;
            const rotation = parseFloat(document.getElementById('rotationSlider').value);
            const enableRotation = document.getElementById('enableRotation').checked;
            
            const dx = (screenX - centerX) / currentZoom;
            const dy = (screenY - centerY) / currentZoom;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            const ringConfigs = selectedRings.map(function(ringId, originalIndex) {
                return {
                    ringId: ringId,
                    originalIndex: originalIndex,
                    modulus: configs[ringId] ? configs[ringId].mod : 1
                };
            });
            
            ringConfigs.sort(function(a, b) {
                if (a.ringId === 'unit') return -1;
                if (b.ringId === 'unit') return 1;
                return a.modulus - b.modulus;
            });
            
            const sortedRings = ringConfigs.map(function(config, sortedIndex) {
                const normalPos = sortedIndex;
                const invertedPos = ringConfigs.length - 1 - sortedIndex;
                const finalPos = normalPos * (1 - nestingInversionAmount) + invertedPos * nestingInversionAmount;
                config.finalIndex = finalPos;
                return config;
            });
            
            sortedRings.sort(function(a, b) {
                return a.finalIndex - b.finalIndex;
            });
            
            let foundResidue = null;
            let minDistance = Infinity;
            
            sortedRings.forEach(function(config, visualIndex) {
                const modulus = config.modulus;
                const radius = calculateRadius(modulus, visualIndex, sortedRings.length);
                
                if (Math.abs(dist - radius) < 20) {
                    const coprimes = getCoprimes(modulus);
                    const allResidues = getAllResidues(modulus);
                    
                    let ringRotation = 0;
                    if (enableRotation) {
                        ringRotation = animationFrame * ringRotationSpeeds[config.ringId] * Math.PI / 180;
                    }
                    
                    allResidues.forEach(function(r) {
                        let baseAngle;
                        if (config.ringId === 'unit') {
                            baseAngle = 0;
                        } else {
                            baseAngle = 2 * Math.PI * (modulus - r) / modulus;
                        }
                        
                        const angle = baseAngle + ringRotation;
                        const rx = radius * Math.cos(angle);
                        const ry = radius * Math.sin(angle);
                        
                        const rdist = Math.sqrt((dx - rx) * (dx - rx) + (dy - ry) * (dy - ry));
                        
                        if (rdist < 15 && rdist < minDistance) {
                            minDistance = rdist;
                            foundResidue = {
                                residue: r,
                                modulus: modulus,
                                radius: radius,
                                angle: angle,
                                ringId: config.ringId,
                                isGcdOne: gcd(r, Math.round(modulus)) === 1
                            };
                        }
                    });
                }
            });
            
            if (foundResidue) {
                if (!selectedPoint1) {
                    selectedPoint1 = foundResidue;
                    updateDistanceDisplay('Point 1 selected', foundResidue);
                    updateAnimationStatus('Point 1: r=' + foundResidue.residue + ' on M=' + Math.round(foundResidue.modulus));
                    draw();
                } else if (!selectedPoint2) {
                    selectedPoint2 = foundResidue;
                    
                    const distResult = calculateEuclideanDistance(selectedPoint1, selectedPoint2);
                    displayDistanceResults(distResult);
                    updateAnimationStatus('Distance: ' + distResult.euclidean.toFixed(6) + ' units');
                    draw();
                }
            }
        }
        
        function updateDistanceDisplay(status, point) {
            const display = document.getElementById('distanceDisplay');
            
            if (!point) {
                display.innerHTML = '<strong>' + status + '</strong>';
                return;
            }
            
            const gcdVal = gcd(point.residue, Math.round(point.modulus));
            const supportText = point.isGcdOne ? '<span style="color: #4ECDC4;">‚úì Character Support (œá‚â†0)</span>' : '<span style="color: #666;">œá=0</span>';
            
            display.innerHTML = '<strong>' + status + '</strong><br>' +
                'Ring: M = ' + Math.round(point.modulus) + '<br>' +
                'Residue: r = ' + point.residue + '<br>' +
                'GCD(r,M) = ' + gcdVal + '<br>' +
                supportText;
        }
        
        function displayDistanceResults(dist) {
            const display = document.getElementById('distanceDisplay');
            
            const diff = Math.abs(dist.euclidean - dist.lawOfCosines).toExponential(3);
            
            display.innerHTML = '<strong>Distance Measurement Complete!</strong><br><br>' +
                '<strong>Point 1:</strong> r=' + selectedPoint1.residue + ', M=' + Math.round(selectedPoint1.modulus) + '<br>' +
                '<strong>Point 2:</strong> r=' + selectedPoint2.residue + ', M=' + Math.round(selectedPoint2.modulus) + '<br><br>' +
                '<strong style="color: #FFD700;">Euclidean Distance:</strong><br>' +
                'd = ' + dist.euclidean.toFixed(6) + ' units<br><br>' +
                '<strong>Verification (Law of Cosines):</strong><br>' +
                'd = ' + dist.lawOfCosines.toFixed(6) + ' units<br><br>' +
                '<em style="font-size: 11px;">Difference: ' + diff + '</em><br>' +
                '<em style="font-size: 11px;">(Should be near machine precision)</em>';
        }
        
        function drawSelectedPoints() {
            if (!distanceMeasurementActive) return;
            
            ctx.save();
            
            if (selectedPoint1) {
                const x1 = selectedPoint1.radius * Math.cos(selectedPoint1.angle);
                const y1 = selectedPoint1.radius * Math.sin(selectedPoint1.angle);
                
                ctx.beginPath();
                ctx.arc(x1, y1, 12, 0, 2 * Math.PI);
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(x1, y1, 8, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.fill();
            }
            
            if (selectedPoint2) {
                const x2 = selectedPoint2.radius * Math.cos(selectedPoint2.angle);
                const y2 = selectedPoint2.radius * Math.sin(selectedPoint2.angle);
                
                ctx.beginPath();
                ctx.arc(x2, y2, 12, 0, 2 * Math.PI);
                ctx.strokeStyle = '#4ECDC4';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(x2, y2, 8, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(78, 205, 196, 0.3)';
                ctx.fill();
                
                if (selectedPoint1) {
                    const x1 = selectedPoint1.radius * Math.cos(selectedPoint1.angle);
                    const y1 = selectedPoint1.radius * Math.sin(selectedPoint1.angle);
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            ctx.restore();
        }`, legendX + 20 * scaleFactor, currentY);
                    currentY += 15 * scaleFactor;
                }
                
                // Lift configurations
                const liftTypes = [];
                if (document.getElementById('showDirectLifts').checked) liftTypes.push('Direct');
                if (document.getElementById('showModularLifts').checked) liftTypes.push('Modular');
                if (document.getElementById('showSkipDirectLifts').checked) liftTypes.push('Skip-Direct');
                if (document.getElementById('showSkipModularLifts').checked) liftTypes.push('Skip-Modular');
                
                tempCtx.fillText(`‚îú‚îÄ Lift Homomorphisms: ${liftTypes.length > 0 ? liftTypes.join(', ') : 'None'}`, legendX + 20 * scaleFactor, currentY);
                currentY += 18 * scaleFactor;
                
                // Visual settings
                const colorModeNames = {
                    'hue': 'Rainbow (Angular)',
                    'value': 'By Value',
                    'modulo': 'By Ring',
                    'prime': 'Prime Analysis',
                    'gcd_unified': 'GCD Unified',
                    'gcd_per_mod': 'GCD per Ring',
                    'gcd_per_residue': 'GCD per Residue',
                    'gcd_mathematical': 'GCD Mathematical',
                    'gcd_spectrum': 'GCD Spectrum',
                    'custom': 'Custom Color'
                };
                
                tempCtx.fillText(`‚îú‚îÄ Color Mode: ${colorModeNames[colorMode] || colorMode}`, legendX + 20 * scaleFactor, currentY);
                currentY += 15 * scaleFactor;
                
                // Radius scaling
                const scalingModes = {
                    'uniform': 'Uniform',
                    'linear': 'Linear r=c¬∑m',
                    'sqrt': 'Square-root r=c¬∑‚àöm',
                    'log': 'Logarithmic r=c¬∑log(m)',
                    'totient': 'Totient r=c¬∑œÜ(m)',
                    'density': 'Density r=c¬∑œÜ(m)/m',
                    'inverse': 'Inverse r=c/m',
                    'exponential': 'Exponential r=c¬∑a·µê'
                };
                
                tempCtx.fillText(`‚îú‚îÄ Radius Scaling: ${scalingModes[radiusScalingMode] || radiusScalingMode}`, legendX + 20 * scaleFactor, currentY);
                currentY += 15 * scaleFactor;
                
                if (radiusScalingMode !== 'uniform') {
                    tempCtx.fillText(`‚îÇ  ‚îî‚îÄ Constant c = ${scalingConstant.toFixed(2)}`, legendX + 20 * scaleFactor, currentY);
                    currentY += 14 * scaleFactor;
                }
                
                // Prime sieve details
                if (primeData.isActive) {
                    tempCtx.fillText(`‚îú‚îÄ Prime Sieve: ACTIVE`, legendX + 20 * scaleFactor, currentY);
                    currentY += 15 * scaleFactor;
                    tempCtx.fillText(`‚îÇ  ‚îú‚îÄ Modulus: ${primeData.modulus}`, legendX + 20 * scaleFactor, currentY);
                    currentY += 14 * scaleFactor;
                    tempCtx.fillText(`‚îÇ  ‚îú‚îÄ Limit: ${primeData.limit.toLocaleString()}`, legendX + 20 * scaleFactor, currentY);
                    currentY += 14 * scaleFactor;
                    tempCtx.fillText(`‚îÇ  ‚îú‚îÄ Primes Found: ${primeData.totalPrimes.toLocaleString()}`, legendX + 20 * scaleFactor, currentY);
                    currentY += 14 * scaleFactor;
                    
                    const eulerPhi = getCoprimes(primeData.modulus).length;
                    const avgPerClass = (primeData.totalPrimes / eulerPhi).toFixed(1);
                    tempCtx.fillText(`‚îÇ  ‚îî‚îÄ Avg per class: ${avgPerClass}`, legendX + 20 * scaleFactor, currentY);
                    currentY += 14 * scaleFactor;
                    
                    // Uniformity analysis
                    if (primeData.totalPrimes > 100) {
                        const uniformity = calculateEquidistributionScore();
                        tempCtx.fillText(`‚îÇ     ‚îú‚îÄ Uniformity: ${(uniformity.uniformityScore * 100).toFixed(1)}%`, legendX + 20 * scaleFactor, currentY);
                        currentY += 14 * scaleFactor;
                        tempCtx.fillText(`‚îÇ     ‚îî‚îÄ GRH Support: ${uniformity.grhSupport}`, legendX + 20 * scaleFactor, currentY);
                        currentY += 14 * scaleFactor;
                    }
                } else {
                    tempCtx.fillText(`‚îú‚îÄ Prime Sieve: Inactive`, legendX + 20 * scaleFactor, currentY);
                    currentY += 15 * scaleFactor;
                }
                
                // Animation state
                const animationState = [];
                if (document.getElementById('enableRotation').checked) {
                    animationState.push(`Rotation (${document.getElementById('globalSpeed').value}x)`);
                }
                if (isInverting) {
                    animationState.push('Inversion');
                }
                if (nestingAnimationActive) {
                    animationState.push('Nesting');
                }
                
                tempCtx.fillText(`‚îú‚îÄ Animation: ${animationState.length > 0 ? animationState.join(', ') : 'Static'}`, legendX + 20 * scaleFactor, currentY);
                currentY += 15 * scaleFactor;
                
                // Display settings
                const displaySettings = [];
                if (document.getElementById('showLabels').checked) displaySettings.push('Labels');
                if (document.getElementById('showGcdOne').checked) displaySettings.push('œá‚â†0');
                if (document.getElementById('showNonGcdOne').checked) displaySettings.push('œá=0');
                if (document.getElementById('showUnitCircle').checked) displaySettings.push('Unit Circle');
                
                tempCtx.fillText(`‚îî‚îÄ Display: ${displaySettings.join(', ')}`, legendX + 20 * scaleFactor, currentY);
                currentY += 25 * scaleFactor;
                
                // ===== VISUAL LEGEND ITEMS =====
                tempCtx.fillStyle = accentColor;
                tempCtx.font = `bold ${14 * scaleFactor}px Segoe UI`;
                tempCtx.fillText('Visual Elements:', legendX + 15 * scaleFactor, currentY);
                
                currentY += 20 * scaleFactor;
                
                // Comprehensive legend items with enhanced details
                const legendItems = [
                    { 
                        color: '#FFD700', 
                        text: 'Unit Circle (M=1)', 
                        description: 'Mathematical foundation where gcd(0,1)=1. Contains single residue 0. Critical for understanding modular arithmetic structure and ring homomorphisms.'
                    },
                    { 
                        color: '#FF6B6B', 
                        text: 'Euler Totient Residues', 
                        description: `œÜ(M) coprime residues where gcd(r,M)=1. These form character support for Dirichlet L-functions. Essential for RH analysis.`
                    },
                    { 
                        color: '#4ECDC4', 
                        text: 'Prime Gap Patterns', 
                        description: 'Connections between primes separated by specific gaps: Twin primes (gap 2), cousin primes (gap 4), sexy primes (gap 6). Tests Hardy-Littlewood conjectures.'
                    }
                ];
                
                // Add active mathematical features to legend with detailed explanations
                if (document.getElementById('showDirectLifts').checked) {
                    legendItems.push({ 
                        color: document.getElementById('liftLineColor').value, 
                        text: 'Direct Lift Homomorphisms', 
                        description: 'Ring homomorphisms œÜ: Z/M‚ÇÅZ ‚Üí Z/M‚ÇÇZ where œÜ(r) = r. Preserve residue structure across different moduli. Fundamental to L-function relationships and character compatibility.'
                    });
                }
                
                if (document.getElementById('showModularLifts').checked) {
                    legendItems.push({ 
                        color: document.getElementById('modularLiftColor').value, 
                        text: 'Chinese Remainder Lifts', 
                        description: 'Transformations r ‚Ü¶ r + M√ó2‚Åø using Chinese Remainder Theorem. Maps residues to shifted positions revealing multiplicative structure.',
                        dashed: true
                    });
                }
                
                // Enhanced color mode information with mathematical context
                const colorMode = document.getElementById('residueColorMode').value;
                const colorModeDescriptions = {
                    'hue': 'Rainbow coloring by angular position Œ∏ = 2œÄr/M. Visualizes rotational symmetry in modular rings.',
                    'value': 'Coloring by residue value using hash function. Highlights numerical patterns across different moduli.',
                    'modulo': 'Unique color per modulus/ring. Distinguishes different modular arithmetic systems in the visualization.',
                    'prime': 'Prime vs composite residue analysis. Tests primality patterns within modular arithmetic constraints.',
                    'gcd_unified': 'Unified coloring for Dirichlet character support where œá(r) ‚â† 0. Shows L-function domains clearly.',
                    'gcd_per_mod': 'Character support with unique color per modulus. Reveals œÜ(M) structure across ring system.',
                    'gcd_per_residue': 'Character support with unique color per residue value. Highlights residue class universality.',
                    'gcd_mathematical': 'Mathematical progression based on œÜ(M) density and totient ordering. Shows Euler function relationships.',
                    'gcd_spectrum': 'Spectral distribution using totient density œÅ = œÜ(M)/M. Visualizes character support concentration.',
                    'custom': 'User-defined single color scheme for focused analysis of specific mathematical properties.'
                };
                
                if (colorModeDescriptions[colorMode]) {
                    legendItems.push({
                        color: 'linear-gradient(45deg, #667eea, #764ba2)',
                        text: 'Coloring Scheme Details',
                        description: colorModeDescriptions[colorMode]
                    });
                }
                
                // Enhanced prime sieve information with mathematical significance
                if (primeData.isActive) {
                    const coprimes = getCoprimes(primeData.modulus);
                    const uniformity = calculateEquidistributionScore();
                    legendItems.push({
                        color: '#FFD700',
                        text: 'Prime Sieve Analysis Active',
                        description: `Testing ${primeData.totalPrimes} primes ‚â§ ${primeData.limit} in mod ${primeData.modulus}. Distribution across œÜ(${primeData.modulus})=${coprimes.length} coprime classes. Uniformity: ${(uniformity.uniformityScore * 100).toFixed(1)}% (GRH prediction).`
                    });
                }
                
                // Mathematical foundations with detailed explanations
                if (selectedRings.length > 0) {
                    const ringTypes = {
                        unit: selectedRings.filter(r => r === 'unit').length,
                        defaults: selectedRings.filter(r => r.startsWith('default_')).length,
                        series: selectedRings.filter(r => !r.startsWith('default_') && !r.startsWith('custom_') && r !== 'unit').length,
                        custom: selectedRings.filter(r => r.startsWith('custom_')).length,
                        sieve: selectedRings.filter(r => r.startsWith('sieve_')).length
                    };
                    
                    const totalEulerSum = selectedRings.reduce((sum, ringId) => {
                        const config = configs[ringId];
                        if (config) {
                            return sum + getCoprimes(config.mod).length;
                        }
                        return sum;
                    }, 0);
                    
                    let systemDesc = `${selectedRings.length} modular rings: `;
                    const parts = [];
                    if (ringTypes.unit > 0) parts.push('Unit foundation');
                    if (ringTypes.defaults > 0) parts.push(`M‚ÇÅ-M${ringTypes.defaults+1} sequence`);
                    if (ringTypes.series > 0) parts.push(`${ringTypes.series} exponential series`);
                    if (ringTypes.custom > 0) parts.push(`${ringTypes.custom} custom moduli`);
                    if (ringTypes.sieve > 0) parts.push(`${ringTypes.sieve} sieve-generated`);
                    
                    systemDesc += parts.join(', ') + `. Total character support: Œ£œÜ(M·µ¢) = ${totalEulerSum} residues.`;
                    
                    legendItems.push({
                        color: subtleColor,
                        text: 'Modular Ring System',
                        description: systemDesc
                    });
                }
                
                // Gap analysis with mathematical significance
                if (selectedGaps.length > 0) {
                    let gapDesc = `Prime gap analysis: gaps [${selectedGaps.join(', ')}]. `;
                    const specialGaps = [];
                    if (selectedGaps.includes(2)) specialGaps.push('twin primes');
                    if (selectedGaps.includes(4)) specialGaps.push('cousin primes'); 
                    if (selectedGaps.includes(6)) specialGaps.push('sexy primes');
                    
                    if (specialGaps.length > 0) {
                        gapDesc += `Testing ${specialGaps.join(', ')} conjectures. `;
                    }
                    gapDesc += `Examines prime distribution patterns and Hardy-Littlewood k-tuple predictions within modular constraints.`;
                    
                    legendItems.push({
                        color: '#38b2ac',
                        text: 'Prime Gap Analysis',
                        description: gapDesc
                    });
                }
                
                // Advanced mathematical features
                legendItems.push({
                    color: '#9b59b6',
                    text: 'Riemann Hypothesis Connections',
                    description: 'GRH predicts uniform prime distribution in coprime residue classes. Character support visualization shows L-function domains. Critical line analysis at Re(s)=1/2.'
                });
                
                legendItems.push({
                    color: '#e67e22',
                    text: 'Mathematical Validation',
                    description: 'All computations verified: Euler totient œÜ(M), character orthogonality, ring homomorphisms, angle positioning Œ∏=2œÄ(M-r)/M, and prime distribution statistics.'
                });
                
                // Draw legend items with better spacing
                tempCtx.font = `${12 * scaleFactor}px Segoe UI`;
                const itemHeight = 40 * scaleFactor;
                const colorBoxSize = 14 * scaleFactor;
                const maxItemsVisible = Math.floor((legendContentHeight - 100 * scaleFactor) / itemHeight);
                const itemsToShow = Math.min(legendItems.length, maxItemsVisible);
                
                for (let i = 0; i < itemsToShow; i++) {
                    const item = legendItems[i];
                    const itemY = currentY + i * itemHeight;
                    const colorX = legendX + 15 * scaleFactor;
                    const textX = colorX + colorBoxSize + 12 * scaleFactor;
                    
                    // Color indicator
                    tempCtx.fillStyle = item.color;
                    tempCtx.fillRect(colorX, itemY - colorBoxSize/2, colorBoxSize, colorBoxSize);
                    
                    if (item.dashed) {
                        tempCtx.strokeStyle = item.color;
                        tempCtx.lineWidth = 2 * scaleFactor;
                        tempCtx.setLineDash([4 * scaleFactor, 3 * scaleFactor]);
                        tempCtx.strokeRect(colorX, itemY - colorBoxSize/2, colorBoxSize, colorBoxSize);
                        tempCtx.setLineDash([]);
                    }
                    
                    // Main text
                    tempCtx.fillStyle = textColor;
                    tempCtx.font = `bold ${12 * scaleFactor}px Segoe UI`;
                    tempCtx.fillText(item.text, textX, itemY - 3 * scaleFactor);
                    
                    // Description - wrapped to fit
                    tempCtx.fillStyle = subtleColor;
                    tempCtx.font = `${10 * scaleFactor}px Segoe UI`;
                    
                    const maxWidth = legendContentWidth - (textX - legendX) - 15 * scaleFactor;
                    const words = item.description.split(' ');
                    let line = '';
                    let lineY = itemY + 10 * scaleFactor;
                    const maxLines = 2; // Limit to 2 lines per item
                    let lineCount = 0;
                    
                    for (let j = 0; j < words.length && lineCount < maxLines; j++) {
                        const testLine = line + words[j] + ' ';
                        const metrics = tempCtx.measureText(testLine);
                        
                        if (metrics.width > maxWidth && line !== '') {
                            tempCtx.fillText(line.trim(), textX, lineY);
                            line = words[j] + ' ';
                            lineY += 12 * scaleFactor;
                            lineCount++;
                        } else {
                            line = testLine;
                        }
                    }
                    
                    if (lineCount < maxLines && line.trim()) {
                        if (line.length > 50) line = line.substring(0, 47) + '...';
                        tempCtx.fillText(line.trim(), textX, lineY);
                    }
                }
                
                // Add mathematical notation at bottom if space allows
                const notationY = legendY + legendContentHeight - 60 * scaleFactor;
                if (notationY > currentY + itemsToShow * itemHeight + 20 * scaleFactor) {
                    tempCtx.fillStyle = subtleColor;
                    tempCtx.font = `italic ${10 * scaleFactor}px Times New Roman`;
                    tempCtx.fillText('œÜ(n) = n‚àè(1 - 1/p)', legendX + 15 * scaleFactor, notationY);
                    tempCtx.fillText('gcd(a,b) = 1 ‚ü∫ œá(a) ‚â† 0', legendX + 15 * scaleFactor, notationY + 15 * scaleFactor);
                    tempCtx.fillText('Z/nZ ‚âÖ (Z/nZ)*', legendX + 15 * scaleFactor, notationY + 30 * scaleFactor);
                }
            }
            
            // Add watermark with proper positioning
            tempCtx.fillStyle = backgroundChoice === 'white' ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.15)';
            tempCtx.font = `${10 * scaleFactor}px Segoe UI`;
            tempCtx.textAlign = 'right';
            const watermarkX = includeLegend ? baseWidth + contentPadding - 10 * scaleFactor : tempCanvas.width - 15 * scaleFactor;
            tempCtx.fillText('Riemann Hypothesis Explorer | Built by Wessen Getachew', 
                watermarkX, tempCanvas.height - 10 * scaleFactor);
            
            // Generate enhanced filename
            const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,'-');
            const ringText = selectedRings.length > 0 ? `_${selectedRings.length}rings` : '';
            const gapText = selectedGaps.length > 0 ? `_${selectedGaps.length}gaps` : '';
            const resText = resolutionChoice === '4k' ? '_4K' : '';
            const filename = `modular_rings${ringText}${gapText}${resText}_${timestamp}.jpg`;
            
            // Create download link with JPEG format
            try {
                // Convert to JPEG with high quality
                const dataURL = tempCanvas.toDataURL('image/jpeg', 0.95);
                
                // Create and trigger download
                const link = document.createElement('a');
                link.download = filename;
                link.href = dataURL;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                const statusMsg = resolutionChoice === '4k' 
                    ? '4K Ultra HD screenshot saved as JPEG!' 
                    : 'Enhanced screenshot saved as JPEG!';
                updateAnimationStatus(statusMsg);
                
                console.log('Screenshot saved:', filename);
            } catch (error) {
                console.error('Screenshot error:', error);
                alert('Error saving screenshot: ' + error.message + '\n\nTry using a smaller resolution or fewer rings.');
                updateAnimationStatus('Screenshot failed - try reducing complexity');
            }
        }

        // Mouse and touch interaction handlers
        let mouseCanvasX = 0;
        let mouseCanvasY = 0;
        
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.touches[0].clientX - rect.left,
                y: e.touches[0].clientY - rect.top
            };
        }

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            
            // Check if distance measurement is active first
            if (distanceMeasurementActive) {
                handleDistanceMeasurementClick(pos.x, pos.y);
                return; // Don't start dragging when in distance mode
            }
            
            isDragging = true;
            dragStartX = pos.x;
            dragStartY = pos.y;
            dragStartPanX = panX;
            dragStartPanY = panY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            mouseCanvasX = pos.x;
            mouseCanvasY = pos.y;
            
            // Don't drag when in distance measurement mode
            if (distanceMeasurementActive) {
                checkResidueHover(pos.x, pos.y);
                return;
            }
            
            // Only pan if mouse button is pressed (isDragging is true)
            if (isDragging) {
                panX = dragStartPanX + (pos.x - dragStartX);
                panY = dragStartPanY + (pos.y - dragStartY);
                draw();
            } else {
                // Check for hover over residues only when not dragging
                checkResidueHover(pos.x, pos.y);
            }
        });
        
        canvas.addEventListener('click', (e) => {
            const pos = getMousePos(e);
            
            // Only process click for distance measurement or residue selection
            // Don't treat a drag as a click
            if (distanceMeasurementActive) {
                handleDistanceMeasurementClick(pos.x, pos.y);
            } else {
                handleResidueClick(pos.x, pos.y);
            }
        });
        
        function checkResidueHover(screenX, screenY) {
            const selectedRings = getSelectedRings();
            if (selectedRings.length === 0) return;
            
            // Transform screen coordinates to canvas coordinates
            const centerX = canvas.width / 2 + panX;
            const centerY = canvas.height / 2 + panY;
            const rotation = parseFloat(document.getElementById('rotationSlider').value);
            
            const dx = (screenX - centerX) / currentZoom;
            const dy = (screenY - centerY) / currentZoom;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            let foundResidue = null;
            
            // Get current rings
            const ringConfigs = selectedRings.map((ringId, originalIndex) => ({
                ringId,
                originalIndex,
                modulus: configs[ringId]?.mod || 1
            }));
            
            ringConfigs.sort((a, b) => {
                if (a.ringId === 'unit') return -1;
                if (b.ringId === 'unit') return 1;
                return a.modulus - b.modulus;
            });
            
            // Check each ring
            ringConfigs.forEach((config, index) => {
                const modulus = config.modulus;
                const radius = calculateRadius(modulus, index, ringConfigs.length);
                
                // Check if near this ring (increased tolerance for distance mode)
                const tolerance = distanceMeasurementActive ? 25 : 15;
                if (Math.abs(dist - radius) < tolerance) {
                    const allResidues = getAllResidues(modulus);
                    
                    // Check each residue
                    allResidues.forEach(r => {
                        let baseAngle;
                        if (config.ringId === 'unit') {
                            baseAngle = 0;
                        } else {
                            baseAngle = 2 * Math.PI * (modulus - r) / modulus;
                        }
                        
                        const angle = baseAngle + (rotation + (animating ? animationFrame * 0.3 : 0)) * Math.PI / 180;
                        const rx = radius * Math.cos(angle);
                        const ry = radius * Math.sin(angle);
                        
                        const rdist = Math.sqrt((dx - rx) * (dx - rx) + (dy - ry) * (dy - ry));
                        
                        // Larger hit area for distance measurement
                        const hitRadius = distanceMeasurementActive ? 15 : 10;
                        if (rdist < hitRadius) {
                            foundResidue = {
                                residue: r,
                                modulus: modulus,
                                ringId: config.ringId,
                                isGcdOne: gcd(r, Math.round(modulus)) === 1,
                                isPrime: isPrime(r),
                                screenX: screenX,
                                screenY: screenY
                            };
                        }
                    });
                }
            });
            
            if (foundResidue) {
                if (distanceMeasurementActive) {
                    // Show special tooltip for distance mode
                    showDistanceTooltip(foundResidue);
                } else {
                    showResidueTooltip(foundResidue);
                }
                canvas.style.cursor = distanceMeasurementActive ? 'crosshair' : 'pointer';
            } else {
                hideResidueTooltip();
                canvas.style.cursor = distanceMeasurementActive ? 'crosshair' : (isDragging ? 'grabbing' : 'grab');
            }
        }
        
        function showDistanceTooltip(info) {
            const tooltip = document.getElementById('hoverTooltip');
            const title = document.getElementById('tooltipTitle');
            const content = document.getElementById('tooltipContent');
            
            title.textContent = `Click to select: r=${info.residue} (mod ${Math.round(info.modulus)})`;
            
            let html = '';
            html += `<div class="property"><strong>Ring:</strong> M=${Math.round(info.modulus)}</div>`;
            html += `<div class="property"><strong>GCD:</strong> ${gcd(info.residue, Math.round(info.modulus))}</div>`;
            html += `<div class="property"><strong>Support:</strong> ${info.isGcdOne ? 'œá(r) ‚â† 0 ‚úì' : 'œá(r) = 0'}</div>`;
            
            if (!selectedPoint1) {
                html += `<div class="property" style="color: #FFD700;"><strong>Select as Point 1</strong></div>`;
            } else if (!selectedPoint2) {
                html += `<div class="property" style="color: #4ECDC4;"><strong>Select as Point 2</strong></div>`;
            }
            
            content.innerHTML = html;
            
            tooltip.style.left = (info.screenX + 15) + 'px';
            tooltip.style.top = (info.screenY + 15) + 'px';
            tooltip.classList.add('visible');
        }
        
        function showResidueTooltip(info) {
            const tooltip = document.getElementById('hoverTooltip');
            const title = document.getElementById('tooltipTitle');
            const content = document.getElementById('tooltipContent');
            
            title.textContent = `Residue ${info.residue} (mod ${Math.round(info.modulus)})`;
            
            let html = '';
            html += `<div class="property"><strong>Modulus:</strong> ${Math.round(info.modulus)}</div>`;
            html += `<div class="property"><strong>GCD(r,M):</strong> ${gcd(info.residue, Math.round(info.modulus))}</div>`;
            html += `<div class="property"><strong>Character Support:</strong> ${info.isGcdOne ? 'œá(r) ‚â† 0 ‚úì' : 'œá(r) = 0'}</div>`;
            html += `<div class="property"><strong>Primality:</strong> ${info.isPrime ? 'Prime ‚úì' : 'Composite'}</div>`;
            
            // Add prime sieve info if active
            if (primeData.isActive && Math.round(info.modulus) === primeData.modulus) {
                const residueData = primeData.residueDistribution[info.residue];
                if (residueData) {
                    html += `<div class="property"><strong>Primes in class:</strong> ${residueData.count}</div>`;
                    html += `<div class="property"><strong>Percentage:</strong> ${residueData.percentage}%</div>`;
                }
            }
            
            // Euler totient
            const phi = getCoprimes(Math.round(info.modulus)).length;
            html += `<div class="property"><strong>œÜ(M):</strong> ${phi}</div>`;
            
            content.innerHTML = html;
            
            tooltip.style.left = (info.screenX + 15) + 'px';
            tooltip.style.top = (info.screenY + 15) + 'px';
            tooltip.classList.add('visible');
        }
        
        function hideResidueTooltip() {
            document.getElementById('hoverTooltip').classList.remove('visible');
        }
        
        function handleResidueClick(screenX, screenY) {
            // Re-use hover detection logic
            checkResidueHover(screenX, screenY);
            
            // Future: Add click-specific behavior like isolating a ring or showing detailed analysis
            updateAnimationStatus('Click features coming in next phase!');
        }

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            if (!distanceMeasurementActive) {
                canvas.style.cursor = 'grab';
            }
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            if (!distanceMeasurementActive) {
                canvas.style.cursor = 'grab';
            }
            hideResidueTooltip();
        });

        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            const pos = getTouchPos(e);
            dragStartX = pos.x;
            dragStartY = pos.y;
            dragStartPanX = panX;
            dragStartPanY = panY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDragging) return;
            
            const pos = getTouchPos(e);
            panX = dragStartPanX + (pos.x - dragStartX);
            panY = dragStartPanY + (pos.y - dragStartY);
            draw();
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDragging = false;
        });

        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left - canvas.width / 2;
            const mouseY = e.clientY - rect.top - canvas.height / 2;
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(50, currentZoom * zoomFactor));
            
            // Zoom towards mouse position
            const zoomRatio = newZoom / currentZoom;
            panX = (panX - mouseX) * zoomRatio + mouseX;
            panY = (panY - mouseY) * zoomRatio + mouseY;
            
            currentZoom = newZoom;
            document.getElementById('zoomSlider').value = Math.min(10, newZoom); // Clamp slider to max 10
            document.getElementById('zoomValue').textContent = newZoom.toFixed(1);
            
            draw();
        });

        // Double-click to reset center
        canvas.addEventListener('dblclick', () => {
            panX = 0;
            panY = 0;
            updateAnimationStatus('View centered');
            draw();
        });

        function updateRotation() {
            const value = document.getElementById('rotationSlider').value;
            document.getElementById('rotationValue').textContent = value + '¬∞';
            draw();
        }

        function updateThickness() {
            const value = document.getElementById('lineThickness').value;
            document.getElementById('thicknessValue').textContent = value;
            draw();
        }

        function updateGapThickness() {
            const value = document.getElementById('gapLineThickness').value;
            document.getElementById('gapThicknessValue').textContent = value;
            draw();
        }
        
        function updateRingThickness() {
            const value = document.getElementById('ringThickness').value;
            document.getElementById('ringThicknessValue').textContent = value;
            draw();
        }
        
        function updateUnitThickness() {
            const value = document.getElementById('unitThickness').value;
            document.getElementById('unitThicknessValue').textContent = value;
            draw();
        }
        
        function updatePointSize() {
            const value = document.getElementById('pointSize').value;
            document.getElementById('pointSizeValue').textContent = value;
            draw();
        }
        
        function updatePointBorder() {
            const value = document.getElementById('pointBorder').value;
            document.getElementById('pointBorderValue').textContent = value;
            draw();
        }

        // Advanced prime sieve implementation
        function sieveOfEratosthenes(limit) {
            const sieve = new Array(limit + 1).fill(true);
            sieve[0] = sieve[1] = false;
            
            for (let i = 2; i * i <= limit; i++) {
                if (sieve[i]) {
                    for (let j = i * i; j <= limit; j += i) {
                        sieve[j] = false;
                    }
                }
            }
            
            const primes = [];
            for (let i = 2; i <= limit; i++) {
                if (sieve[i]) primes.push(i);
            }
            return primes;
        }

        function analyzePrimeDistribution(primes, modulus) {
            const distribution = {};
            const coprimes = getCoprimes(modulus);
            
            // Initialize distribution for all coprime residues
            coprimes.forEach(r => {
                distribution[r] = { count: 0, primes: [], percentage: 0 };
            });
            
            // Count primes in each residue class
            primes.forEach(prime => {
                const residue = prime % modulus;
                if (distribution[residue]) {
                    distribution[residue].count++;
                    distribution[residue].primes.push(prime);
                }
            });
            
            // Calculate percentages
            const totalPrimesInCoprimes = Object.values(distribution).reduce((sum, data) => sum + data.count, 0);
            Object.keys(distribution).forEach(residue => {
                distribution[residue].percentage = totalPrimesInCoprimes > 0 
                    ? (distribution[residue].count / totalPrimesInCoprimes * 100).toFixed(2)
                    : 0;
            });
            
            return distribution;
        }

        async function runPrimeSieve() {
            const limit = parseInt(document.getElementById('sieveLimit').value);
            const modulus = parseInt(document.getElementById('sieveModulus').value);
            
            if (limit < 2) {
                alert('Please enter a limit of at least 2');
                return;
            }
            
            if (modulus < 2) {
                alert('Please enter a modulus of at least 2');
                return;
            }
            
            // Warning for very large computations
            if (limit > 10000000) {
                if (!confirm(`Computing primes up to ${limit.toLocaleString()} may take significant time and memory. Continue?`)) {
                    return;
                }
            }
            
            // Show progress bar
            document.getElementById('sieveProgress').style.display = 'block';
            document.getElementById('sieveResults').style.display = 'none';
            
            updateProgress(0, 'Initializing sieve...');
            
            // Use setTimeout to allow UI updates
            setTimeout(() => {
                try {
                    updateProgress(25, 'Generating primes...');
                    
                    setTimeout(() => {
                        const primes = sieveOfEratosthenes(limit);
                        updateProgress(60, 'Analyzing distribution...');
                        
                        setTimeout(() => {
                            const distribution = analyzePrimeDistribution(primes, modulus);
                            
                            // Store results
                            primeData.primes = primes;
                            primeData.modulus = modulus;
                            primeData.limit = limit;
                            primeData.residueDistribution = distribution;
                            primeData.totalPrimes = primes.length;
                            primeData.isActive = true;
                            
                            updateProgress(90, 'Updating visualization...');
                            
                            setTimeout(() => {
                                updatePrimeAnalysisDisplay();
                                updateProgress(100, 'Complete!');
                                
                                setTimeout(() => {
                                    document.getElementById('sieveProgress').style.display = 'none';
                                    document.getElementById('sieveResults').style.display = 'block';
                                    document.getElementById('primePatternAnalysis').style.display = 'block';
                                    
                                    // Auto-add the sieve modulus as a ring if not present
                                    addSieveModulusRing(modulus);
                                    
                                    updateAnimationStatus(`Sieve complete: ${primes.length} primes found up to ${limit} (mod ${modulus})`);
                                    draw();
                                }, 500);
                            }, 100);
                        }, 100);
                    }, 100);
                } catch (error) {
                    alert('Error running sieve: ' + error.message);
                    document.getElementById('sieveProgress').style.display = 'none';
                }
            }, 50);
        }

        function updateProgress(percentage, text) {
            document.getElementById('progressBar').style.width = percentage + '%';
            document.getElementById('progressText').textContent = text;
        }

        function addSieveModulusRing(modulus) {
            // Check if this modulus already exists
            const existing = Object.values(configs).find(config => config.mod === modulus);
            if (!existing) {
                const customId = `sieve_${customRingCounter++}`;
                configs[customId] = { 
                    mod: modulus, 
                    label: modulus.toString(),
                    description: `Sieve modulus ${modulus}`
                };
                addRingControl(customId, `Sieve M${modulus}`, true);
            } else {
                // Find and check the existing ring
                const ringControls = document.querySelectorAll('#ringControls input[type="checkbox"]');
                ringControls.forEach(checkbox => {
                    const config = configs[checkbox.value];
                    if (config && config.mod === modulus) {
                        checkbox.checked = true;
                    }
                });
            }
        }

        function updatePrimeAnalysisDisplay() {
            const stats = document.getElementById('primeStats');
            const distribution = document.getElementById('residueDistribution');
            
            if (!primeData.isActive) return;
            
            const coprimes = getCoprimes(primeData.modulus);
            const eulerPhi = coprimes.length;
            
            stats.innerHTML = `
                <strong>Sieve Results (mod ${primeData.modulus}):</strong><br>
                ‚Ä¢ Total primes up to ${primeData.limit}: ${primeData.totalPrimes}<br>
                ‚Ä¢ œÜ(${primeData.modulus}) = ${eulerPhi} coprime residue classes<br>
                ‚Ä¢ Expected uniform distribution: ${(100/eulerPhi).toFixed(2)}% per class<br>
                ‚Ä¢ Prime density: ${((primeData.totalPrimes / primeData.limit) * 100).toFixed(3)}%
            `;
            
            let distributionHTML = '<strong>Prime Distribution by Residue Class:</strong><br>';
            const sortedResidues = Object.keys(primeData.residueDistribution).sort((a, b) => parseInt(a) - parseInt(b));
            
            sortedResidues.forEach(residue => {
                const data = primeData.residueDistribution[residue];
                const expectedPercent = (100 / eulerPhi).toFixed(2);
                const deviation = (parseFloat(data.percentage) - parseFloat(expectedPercent)).toFixed(2);
                const deviationColor = deviation > 0 ? '#4ECDC4' : '#FF6B6B';
                
                // Format all primes for display - group in rows of 10 for readability
                let primesDisplay = '';
                if (data.count === 0) {
                    primesDisplay = '<em>No primes in this residue class</em>';
                } else if (data.count <= 50) {
                    // Show all primes if 50 or fewer
                    const rows = [];
                    for (let i = 0; i < data.primes.length; i += 10) {
                        rows.push(data.primes.slice(i, i + 10).join(', '));
                    }
                    primesDisplay = `[${rows.join(',<br>&nbsp;&nbsp;')}]`;
                } else {
                    // For large counts, show first 30, then last 10
                    const firstPrimes = data.primes.slice(0, 30);
                    const lastPrimes = data.primes.slice(-10);
                    const firstRows = [];
                    const lastRows = [];
                    
                    for (let i = 0; i < firstPrimes.length; i += 10) {
                        firstRows.push(firstPrimes.slice(i, i + 10).join(', '));
                    }
                    for (let i = 0; i < lastPrimes.length; i += 10) {
                        lastRows.push(lastPrimes.slice(i, i + 10).join(', '));
                    }
                    
                    primesDisplay = `[${firstRows.join(',<br>&nbsp;&nbsp;')},<br>&nbsp;&nbsp;...(${data.count - 40} more)...,<br>&nbsp;&nbsp;${lastRows.join(',<br>&nbsp;&nbsp;')}]`;
                }
                
                distributionHTML += `
                    <div style="margin: 5px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                        <strong>r ‚â° ${residue} (mod ${primeData.modulus}):</strong><br>
                        Count: ${data.count} primes (${data.percentage}%)<br>
                        <span style="color: ${deviationColor};">Deviation: ${deviation > 0 ? '+' : ''}${deviation}%</span><br>
                        <div style="font-family: monospace; font-size: 11px; margin-top: 5px; max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 3px;">
                            ${primesDisplay}
                        </div>
                    </div>
                `;
            });
            
            distribution.innerHTML = distributionHTML;
        }

        function quickSieve(limit, modulus) {
            document.getElementById('sieveLimit').value = limit;
            document.getElementById('sieveModulus').value = modulus;
            runPrimeSieve();
        }

        function togglePrimeSieve() {
            // No longer needed since controls are always visible in RH hub
        }

        function clearPrimeSieve() {
            primeData = {
                primes: [],
                modulus: null,
                limit: null,
                residueDistribution: {},
                totalPrimes: 0,
                isActive: false
            };
            
            document.getElementById('sieveResults').style.display = 'none';
            document.getElementById('primePatternAnalysis').style.display = 'none';
            document.getElementById('showPrimeMarkers').checked = false;
            document.getElementById('showCompositeMarkers').checked = false;
            document.getElementById('showPrimeDensity').checked = false;
            
            updateAnimationStatus('Prime sieve data cleared');
            draw();
        }

        function updateGlobalSpeed() {
            const value = document.getElementById('globalSpeed').value;
            document.getElementById('globalSpeedValue').textContent = value;
        }

        function updateInversionSpeed() {
            const value = document.getElementById('inversionSpeed').value;
            document.getElementById('inversionSpeedValue').textContent = value;
        }

        function updateNonGcdOpacity() {
            const value = document.getElementById('nonGcdOpacity').value;
            document.getElementById('nonGcdOpacityValue').textContent = value;
            draw();
        }

        function updateColorMode() {
            const mode = document.getElementById('residueColorMode').value;
            const customGroup = document.getElementById('customColorGroup');
            const gcdColorGroup = document.getElementById('gcdColorGroup');
            const nonGcdColorGroup = document.getElementById('nonGcdColorGroup');
            
            // Hide all color option groups first
            customGroup.style.display = 'none';
            gcdColorGroup.style.display = 'none';
            nonGcdColorGroup.style.display = 'none';
            
            // Show relevant color options based on mode
            if (mode === 'custom') {
                customGroup.style.display = 'block';
            } else if (mode.startsWith('gcd_')) {
                gcdColorGroup.style.display = 'block';
                nonGcdColorGroup.style.display = 'block';
            }
            
            draw();
        }

        function toggleRotation() {
            const enabled = document.getElementById('enableRotation').checked;
            if (enabled && !animating) {
                animating = true;
                updateAnimationStatus('Ring rotation enabled');
                animate();
            } else if (!enabled && animating && !isInverting) {
                animating = false;
                updateAnimationStatus('Animation paused');
            }
        }

        function toggleInversionAnimation() {
            const enabled = document.getElementById('enableInversion').checked;
            isInverting = enabled;
            inversionProgress = 0;
            
            const controls = document.getElementById('inversionControls');
            controls.style.display = enabled ? 'block' : 'none';
            
            if (isInverting) {
                updateAnimationStatus('Mathematical inversion started');
                if (!animating) {
                    animating = true;
                    animate();
                }
            } else {
                updateAnimationStatus('Inversion stopped');
            }
        }

        function stopInversionAnimation() {
            isInverting = false;
            inversionProgress = 0;
            document.getElementById('inversionControls').style.display = 'none';
            
            if (!document.getElementById('enableRotation').checked) {
                animating = false;
            }
            updateAnimationStatus('Inversion stopped');
        }

        function animate() {
            if (!animating && !isInverting && !nestingAnimationActive) return;
            
            const enableRotation = document.getElementById('enableRotation').checked;
            const globalSpeed = parseFloat(document.getElementById('globalSpeed').value);
            const reverseDirection = document.getElementById('reverseDirection').checked;
            
            if (enableRotation) {
                animationFrame += globalSpeed * (reverseDirection ? -1 : 1);
            }
            
            if (isInverting) {
                const inversionSpeed = parseFloat(document.getElementById('inversionSpeed').value);
                const inversionLoop = document.getElementById('inversionLoop').checked;
                
                inversionProgress += 0.008 * inversionSpeed;
                
                if (inversionProgress >= 1) {
                    if (inversionLoop) {
                        inversionProgress = 0; // Loop the inversion
                    } else {
                        inversionProgress = 1;
                        isInverting = false;
                        document.getElementById('enableInversion').checked = false;
                        document.getElementById('inversionControls').style.display = 'none';
                        updateAnimationStatus('Inversion cycle completed');
                    }
                }
            }
            
            // Nesting animation
            if (nestingAnimationActive) {
                nestingAnimationProgress += 0.01 * nestingAnimationSpeed * nestingAnimationDirection;
                
                if (nestingAnimationProgress >= 1) {
                    if (nestingPingPong) {
                        nestingAnimationProgress = 1;
                        nestingAnimationDirection = -1;
                    } else if (nestingLoop) {
                        nestingAnimationProgress = 0;
                    } else {
                        nestingAnimationProgress = 1;
                        nestingAnimationActive = false;
                        updateAnimationStatus('Nesting animation completed');
                    }
                } else if (nestingAnimationProgress <= 0) {
                    if (nestingPingPong) {
                        nestingAnimationProgress = 0;
                        nestingAnimationDirection = 1;
                    } else if (nestingLoop) {
                        nestingAnimationProgress = 1;
                    } else {
                        nestingAnimationProgress = 0;
                        nestingAnimationActive = false;
                        updateAnimationStatus('Nesting animation completed');
                    }
                }
                
                // Smooth easing for nesting animation
                const eased = nestingAnimationProgress < 0.5 
                    ? 2 * nestingAnimationProgress * nestingAnimationProgress
                    : 1 - Math.pow(-2 * nestingAnimationProgress + 2, 2) / 2;
                
                nestingInversionAmount = eased;
                document.getElementById('nestingInversion').value = nestingInversionAmount;
                document.getElementById('nestingInversionValue').textContent = nestingInversionAmount.toFixed(2);
            }
            
            if (!enableRotation && !isInverting && !nestingAnimationActive && !gcdAnimationActive && !tSweepActive) {
                animating = false;
                return;
            }
            
            draw();
            requestAnimationFrame(animate);
        }

        function resetAll() {
            // Reset gap controls with new system - ALL GAPS OFF by default
            document.getElementById('maxGap').value = 12;
            document.getElementById('gapStart').value = 14;
            document.getElementById('gapEnd').value = 20;
            
            // Clear existing gaps and regenerate with all unchecked
            const gapControls = document.getElementById('gapControls');
            gapControls.innerHTML = '';
            
            // Add standard gaps but all unchecked by default
            for (let gap = 2; gap <= 12; gap += 2) {
                addGapControl(gap, false); // All gaps off by default
            }
            
            // Reset modulus controls
            document.getElementById('customMod').value = 42;
            document.getElementById('modStart').value = 31;
            document.getElementById('modEnd').value = 50;
            
            // Remove custom rings and rebuild with new defaults
            Object.keys(configs).forEach(key => {
                if (key.startsWith('custom_') || key.startsWith('default_')) {
                    delete configs[key];
                }
            });
            
            // Rebuild ring controls with unit circle first, then M1-M30 by default
            const ringControls = document.getElementById('ringControls');
            ringControls.innerHTML = '';
            
            // Add unit circle first (always checked)
            addRingControl('unit', 'Unit Circle (M=1)', true);
            
            // Add M1-M30 by default (all checked)
            for (let mod = 2; mod <= 30; mod++) {
                const customId = `default_${mod}`;
                configs[customId] = { 
                    mod: mod, 
                    label: mod.toString(),
                    description: `Default modulus ${mod}`
                };
                addRingControl(customId, `M${mod}`, true);
            }
            
            // Add standard series (unchecked by default now)
            Object.keys(configs).forEach(n => {
                if (!n.startsWith('custom_') && !n.startsWith('default_') && n !== 'unit') {
                    addRingControl(n, `n=${n} (M=${configs[n].label})`, false);
                }
            });
            
            // Reset controls to new defaults - CLEAN SETUP
            document.getElementById('showLabels').checked = false; // Labels OFF by default
            document.getElementById('labelUnitCircle').checked = true;
            document.getElementById('labelGcdOne').checked = true;
            document.getElementById('labelNonGcdOne').checked = false;
            document.getElementById('labelShowPrimeCounts').checked = true;
            document.getElementById('labelMinRadius').value = 80;
            document.getElementById('labelSpecificMods').value = '';
            document.getElementById('showDirectLifts').checked = true; // ONLY direct lifts (r ‚Üí r)
            document.getElementById('showModularLifts').checked = false; // NO modular lifts
            document.getElementById('showSkipDirectLifts').checked = false; // NO skip lifts
            document.getElementById('showSkipModularLifts').checked = false; // NO skip modular lifts
            document.getElementById('enableRotation').checked = false;
            document.getElementById('enableInversion').checked = false;
            document.getElementById('reverseDirection').checked = false;
            document.getElementById('showUnitCircle').checked = true;
            document.getElementById('showGcdOne').checked = true;
            document.getElementById('showNonGcdOne').checked = false;
            document.getElementById('highlightGcdDifference').checked = false;
            document.getElementById('enableColorInvert').checked = false;
            colorInverted = false;
            canvas.style.filter = 'none';
            
            // Reset RH visualization controls
            document.getElementById('showCriticalLine').checked = true;
            document.getElementById('showCharacterCanvas').checked = true;
            document.getElementById('showPrimeDistCanvas').checked = true;
            document.getElementById('showZetaZeros').checked = true;
            document.getElementById('showPrimeCounting').checked = true;
            document.getElementById('showResidueHeatmap').checked = true;
            document.getElementById('showChiSquared').checked = true;
            document.getElementById('showModulusComparison').checked = true;
            document.getElementById('showLFunction').checked = true;
            
            // Reset Zero-Residue Alignment controls
            document.getElementById('enableZeroAlignment').checked = false;
            document.getElementById('alignmentT').value = 14.134;
            document.getElementById('alignmentTValue').textContent = '14.134';
            document.getElementById('alignmentX').value = 1000;
            document.getElementById('alignmentXValue').textContent = '1000';
            document.getElementById('showPrimePhaseVectors').checked = true;
            document.getElementById('showCoherenceScore').checked = true;
            document.getElementById('enableTSweep').checked = false;
            document.getElementById('showRandomBaseline').checked = false;
            document.getElementById('tSweepSpeed').value = 1.0;
            document.getElementById('tSweepSpeedValue').textContent = '1.0';
            document.getElementById('zeroAlignmentControls').style.display = 'none';
            document.getElementById('tSweepControls').style.display = 'none';
            document.getElementById('alignmentResults').style.display = 'none';
            zeroAlignmentActive = false;
            tSweepActive = false;
            alignmentT = 14.134;
            alignmentX = 1000;
            primePhaseCache = {};
            
            // Reset global scale
            document.getElementById('globalScale').value = 1.0;
            document.getElementById('globalScaleValue').textContent = '1.0';
            globalScale = 1.0;
            
            // Reset nesting animation
            document.getElementById('enableNestingAnimation').checked = false;
            document.getElementById('nestingAnimationControls').style.display = 'none';
            document.getElementById('nestingInversion').value = 0;
            document.getElementById('nestingInversionValue').textContent = '0.00';
            document.getElementById('nestingSpeed').value = 1.0;
            document.getElementById('nestingSpeedValue').textContent = '1.0';
            document.getElementById('nestingLoop').checked = true;
            document.getElementById('nestingPingPong').checked = false;
            nestingInversionAmount = 0;
            nestingAnimationActive = false;
            nestingAnimationProgress = 0;
            nestingAnimationDirection = 1;
            
            // Reset RH analysis controls
            document.getElementById('enableRhAnalysis').checked = false;
            document.getElementById('showCharacterSupport').checked = true;
            document.getElementById('showLFunctionZeros').checked = false;
            document.getElementById('showEquidistributionTest').checked = false;
            document.getElementById('grhModulus').value = 30;
            
            // Reset sliders with new defaults (normalized 0-1 values)
            document.getElementById('zoomSlider').value = 1;
            document.getElementById('rotationSlider').value = 90; // Default 90¬∞ rotation
            document.getElementById('lineThickness').value = 0.5;
            document.getElementById('gapLineThickness').value = 0.3;
            document.getElementById('ringThickness').value = 0.2;
            document.getElementById('unitThickness').value = 0.8;
            document.getElementById('pointSize').value = 0.4;
            document.getElementById('pointBorder').value = 0.3;
            document.getElementById('labelSize').value = 1.0;
            document.getElementById('labelOpacity').value = 0.95;
            document.getElementById('globalSpeed').value = 1;
            document.getElementById('inversionSpeed').value = 1;
            document.getElementById('inversionIntensity').value = 1.0;
            document.getElementById('inversionPattern').value = 'wave';
            document.getElementById('inversionLoop').checked = true;
            document.getElementById('nonGcdOpacity').value = 0.3;
            document.getElementById('residueColorMode').value = 'hue';
            document.getElementById('liftLineColor').value = '#FFD700';
            document.getElementById('modularLiftColor').value = '#FF6384';
            document.getElementById('gcdBaseColor').value = '#FF6B6B';
            document.getElementById('nonGcdColor').value = '#666666';
            
            // Update displays
            updateZoom();
            updateRotation();
            updateThickness();
            updateGapThickness();
            updateRingThickness();
            updateUnitThickness();
            updatePointSize();
            updatePointBorder();
            updateGlobalSpeed();
            updateInversionSpeed();
            updateNonGcdOpacity();
            updateColorMode();
            updateGapThickness();
            updateLabelSize();
            updateLabelOpacity();
            updateGlobalSpeed();
            updateInversionSpeed();
            updateInversionIntensity();
            updateColorMode();
            
            // Reset animation state
            animating = false;
            isInverting = false;
            animationFrame = 0;
            inversionProgress = 0;
            ringRotationSpeeds = {};
            
            // Reset view state
            panX = 0;
            panY = 0;
            currentZoom = 1;
            
            // Reset prime sieve
            document.getElementById('sieveLimit').value = 10000;
            document.getElementById('sieveModulus').value = 30;
            document.getElementById('showPrimeMarkers').checked = false;
            document.getElementById('showCompositeMarkers').checked = false;
            document.getElementById('showPrimeDensity').checked = false;
            clearPrimeSieve();
        }

        // Enhanced main drawing function
        function draw() {
            const selectedRings = getSelectedRings();
            
            // Update 3D rotation ring selector
            init3DRotationPanel();
            
            const selectedGaps = getSelectedGaps();
            const showLabels = document.getElementById('showLabels').checked;
            const showDirectLifts = document.getElementById('showDirectLifts').checked;
            const showModularLifts = document.getElementById('showModularLifts').checked;
            const showSkipDirectLifts = document.getElementById('showSkipDirectLifts').checked;
            const showSkipModularLifts = document.getElementById('showSkipModularLifts').checked;
            const showUnitCircle = document.getElementById('showUnitCircle').checked;
            const showGcdOne = document.getElementById('showGcdOne').checked;
            const showNonGcdOne = document.getElementById('showNonGcdOne').checked;
            const highlightGcdDifference = document.getElementById('highlightGcdDifference').checked;
            const nonGcdOpacity = parseFloat(document.getElementById('nonGcdOpacity').value);
            const zoom = parseFloat(document.getElementById('zoomSlider').value);
            const rotation = parseFloat(document.getElementById('rotationSlider').value);
            const colorMode = document.getElementById('residueColorMode').value;
            const lineThickness = parseFloat(document.getElementById('lineThickness').value);
            const gapLineThickness = parseFloat(document.getElementById('gapLineThickness').value);
            const enableRotation = document.getElementById('enableRotation').checked;
            const liftLineColor = document.getElementById('liftLineColor').value;
            const modularLiftColor = document.getElementById('modularLiftColor').value;
            
            // GCD visualization options
            const highlightGcdBoundary = document.getElementById('highlightGcdBoundary')?.checked || false;
            const showGcdConnections = document.getElementById('showGcdConnections')?.checked || false;
            const animateGcdHighlight = document.getElementById('animateGcdHighlight')?.checked || false;
            const showTotientCount = document.getElementById('showTotientCount')?.checked || false;
            
            // Update GCD animation phase
            if (gcdAnimationActive) {
                gcdAnimationPhase += 0.03;
            }

            // Clear canvas with enhanced background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (selectedRings.length === 0) {
                // Draw a helpful message
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '24px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Select rings to begin exploration', canvas.width / 2, canvas.height / 2);
                ctx.font = '16px Segoe UI';
                ctx.fillText('Try adding consecutive moduli M‚ÇÅ to M‚ÇÇ‚ÇÄ for complete foundation', canvas.width / 2, canvas.height / 2 + 30);
                updateInfo([]);
                return;
            }

            ctx.save();
            ctx.translate(canvas.width / 2 + panX, canvas.height / 2 + panY);
            ctx.scale(currentZoom, currentZoom);
            ctx.rotate((rotation + (animating ? animationFrame * 0.3 : 0)) * Math.PI / 180);
            
            // Draw Smith chart grid if enabled
            if (smithChartEnabled) {
                drawSmithChartGrid();
            }
            
            // Draw coordinate system guides
            if (coordinateSystem === 'log-cylinder') {
                // Draw log-cylinder FLAT grid (like a rectangular coordinate plane)
                // v-axis is scaled by œÄ since Œ∏ = 2œÄr/M
                ctx.strokeStyle = 'rgba(100, 150, 200, 0.2)';
                ctx.lineWidth = 0.5;
                
                // Horizontal lines at multiples of œÄ (constant v = constant Œ∏)
                const piScale = 50; // 50 pixels per œÄ
                for (let piMultiple = -2; piMultiple <= 2; piMultiple++) {
                    const v = piMultiple * piScale;
                    ctx.beginPath();
                    ctx.moveTo(-200, v);
                    ctx.lineTo(300, v);
                    ctx.stroke();
                    
                    // Label at multiples of œÄ
                    if (piMultiple !== 0) {
                        ctx.fillStyle = 'rgba(100, 150, 200, 0.7)';
                        ctx.font = '10px serif';
                        ctx.textAlign = 'right';
                        const label = piMultiple === 1 ? 'œÄ' : piMultiple === -1 ? '-œÄ' : `${piMultiple}œÄ`;
                        ctx.fillText(label, -205, v + 4);
                    }
                }
                
                // Finer horizontal grid lines at œÄ/2
                ctx.strokeStyle = 'rgba(100, 150, 200, 0.1)';
                for (let halfPi = -3.5; halfPi <= 3.5; halfPi += 0.5) {
                    if (halfPi % 1 !== 0) { // Skip full œÄ multiples (already drawn)
                        const v = halfPi * piScale;
                        ctx.beginPath();
                        ctx.moveTo(-200, v);
                        ctx.lineTo(300, v);
                        ctx.stroke();
                    }
                }
                
                // Vertical lines (constant u = constant ln(m))
                ctx.strokeStyle = 'rgba(100, 150, 200, 0.2)';
                for (let u = 0; u <= 5; u += 0.5) {
                    const x = u * coordSystemParams.logCylinder.uScale * 80 - 150;
                    ctx.beginPath();
                    ctx.moveTo(x, -150);
                    ctx.lineTo(x, 150);
                    ctx.stroke();
                    
                    // Label major vertical lines
                    if (u % 1 === 0 && u > 0) {
                        ctx.fillStyle = 'rgba(100, 150, 200, 0.7)';
                        ctx.font = '10px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(u.toFixed(0), x, -155);
                    }
                }
                
                // Axis labels
                ctx.fillStyle = 'rgba(100, 150, 200, 0.8)';
                ctx.font = 'bold 12px serif';
                ctx.textAlign = 'center';
                
                // U-axis label
                ctx.fillText('u = ln m', 50, -165);
                
                // V-axis label with proper œÄ notation
                ctx.save();
                ctx.translate(-210, 0);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('v = Œ∏ = 2œÄr/M', 0, 0);
                ctx.restore();
                
                // Draw axes through origin
                ctx.strokeStyle = 'rgba(100, 150, 200, 0.5)';
                ctx.lineWidth = 1.5;
                // V-axis (vertical, through v=0)
                ctx.beginPath();
                ctx.moveTo(-200, 0);
                ctx.lineTo(300, 0);
                ctx.stroke();
                // U-axis indicator
                ctx.beginPath();
                ctx.moveTo(-150, -150);
                ctx.lineTo(-150, 150);
                ctx.stroke();
                
            } else if (coordinateSystem === 'spiral') {
                // Draw spiral guide
                ctx.strokeStyle = 'rgba(150, 100, 200, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                const a = 10;
                const b = coordSystemParams.spiral.growth;
                
                for (let theta = 0; theta <= 8 * Math.PI; theta += 0.1) {
                    const r = a * Math.exp(b * theta);
                    const x = r * Math.cos(theta);
                    const y = r * Math.sin(theta);
                    
                    if (theta === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    
                    if (r > 350) break;
                }
                ctx.stroke();
            } else if (coordinateSystem === 'hyperbolic') {
                // Draw hyperbolic grid circles
                ctx.strokeStyle = 'rgba(200, 100, 150, 0.15)';
                ctx.lineWidth = 0.5;
                
                for (let r = 50; r <= 250; r += 50) {
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                // Hyperbolic rays
                for (let angle = 0; angle < 2 * Math.PI; angle += Math.PI / 8) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(250 * Math.cos(angle), 250 * Math.sin(angle));
                    ctx.stroke();
                }
            }

            const rings = [];
            
            // Create array of ring configs with their original indices
            const ringConfigs = selectedRings.map((ringId, originalIndex) => ({
                ringId,
                originalIndex,
                modulus: configs[ringId]?.mod || 1
            }));
            
            // Sort by modulus (always unit circle first)
            ringConfigs.sort((a, b) => {
                if (a.ringId === 'unit') return -1;
                if (b.ringId === 'unit') return 1;
                return a.modulus - b.modulus;
            });
            
            // Calculate gradual position exchange based on inversion amount
            // Each ring's position interpolates between its normal and inverted position
            // ALL rings including unit circle are inverted
            const sortedRings = ringConfigs.map((config, sortedIndex) => {
                // Normal position: sortedIndex (0, 1, 2, 3, ..., n)
                // Inverted position: totalRings - 1 - sortedIndex (n, n-1, n-2, ..., 0)
                const normalPos = sortedIndex;
                const invertedPos = ringConfigs.length - 1 - sortedIndex;
                
                // Interpolate between normal and inverted position
                // This includes unit circle - it will swap with the outermost ring
                const finalPos = normalPos * (1 - nestingInversionAmount) + invertedPos * nestingInversionAmount;
                config.finalIndex = finalPos;
                
                return config;
            });
            
            // Sort by final interpolated position
            sortedRings.sort((a, b) => a.finalIndex - b.finalIndex);

            const maxRadius = 280 * globalScale;
            const minRadius = (showUnitCircle && selectedRings.includes('unit') ? 25 : 60) * globalScale;

            // Initialize enhanced ring rotation speeds
            sortedRings.forEach((config) => {
                const n = config.ringId;
                if (!ringRotationSpeeds[n]) {
                    const modulus = config.modulus;
                    if (n === 'unit') {
                        ringRotationSpeeds[n] = 3.0; // Unit circle rotates faster
                    } else {
                        ringRotationSpeeds[n] = Math.max(0.3, 2.5 - Math.log10(modulus + 1));
                    }
                }
            });

            sortedRings.forEach((config, visualIndex) => {
                const n = config.ringId;
                const modulus = config.modulus;
                const radius = calculateRadius(modulus, visualIndex, sortedRings.length);
                const coprimes = getCoprimes(modulus);
                const allResidues = getAllResidues(modulus);
                
                rings.push({ n, radius, modulus, coprimes, allResidues, index: visualIndex });
            });

            // Enhanced ring drawing with special unit circle treatment
            rings.forEach(ring => {
                // Calculate individual ring rotation
                let ringRotation = 0;
                if (enableRotation) {
                    ringRotation = animationFrame * ringRotationSpeeds[ring.n] * Math.PI / 180;
                }
                
                // Enhanced inversion animation with multiple patterns
                if (isInverting) {
                    const waveOffset = ring.index * 0.15;
                    const inversionPhase = Math.max(0, Math.min(1, inversionProgress * 3 - waveOffset));
                    const pattern = document.getElementById('inversionPattern').value;
                    
                    let inversionEffect = 0;
                    
                    switch(pattern) {
                        case 'wave':
                            inversionEffect = Math.sin(inversionPhase * Math.PI) * Math.PI * inversionIntensity;
                            break;
                        case 'spiral':
                            inversionEffect = inversionPhase * Math.PI * 2 * inversionIntensity;
                            break;
                        case 'pulse':
                            const pulseIntensity = Math.sin(inversionPhase * Math.PI * 4);
                            inversionEffect = pulseIntensity * Math.PI * 0.5 * inversionIntensity;
                            break;
                        case 'twist':
                            const twistFactor = ring.radius / maxRadius;
                            inversionEffect = inversionPhase * Math.PI * twistFactor * inversionIntensity;
                            break;
                    }
                    
                    ringRotation += inversionEffect;
                    
                    // Add visual pulsing during inversion
                    ctx.globalAlpha = 0.7 + 0.3 * Math.sin(inversionProgress * Math.PI * 4 + ring.index);
                } else {
                    ctx.globalAlpha = 1.0;
                }

                // Enhanced ring circle drawing with normalized thickness controls
                ctx.beginPath();
                ctx.arc(0, 0, ring.radius, 0, 2 * Math.PI);
                
                const ringThicknessNorm = parseFloat(document.getElementById('ringThickness').value);
                const unitThicknessNorm = parseFloat(document.getElementById('unitThickness').value);
                
                if (ring.n === 'unit' && showUnitCircle) {
                    // Special styling for unit circle with normalized thickness
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                    ctx.lineWidth = (0.5 + unitThicknessNorm * 4.5) * globalScale; // Scale 0-1 to 0.5-5.0, apply global scale
                    ctx.setLineDash([]);
                } else {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
                    ctx.lineWidth = (0.2 + ringThicknessNorm * 1.8) * globalScale; // Scale 0-1 to 0.2-2.0, apply global scale
                    ctx.setLineDash([2, 4]);
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // Enhanced residue points with prime sieve integration
                const residuesToDraw = [];
                
                // Determine which residues to show based on GCD filtering
                if (showGcdOne) {
                    residuesToDraw.push(...ring.coprimes.map(r => ({r, isGcdOne: true})));
                }
                if (showNonGcdOne && ring.n !== 'unit') {
                    const nonCoprimes = ring.allResidues.filter(r => !ring.coprimes.includes(r));
                    residuesToDraw.push(...nonCoprimes.map(r => ({r, isGcdOne: false})));
                }
                
                // Draw GCD boundary if enabled
                if (highlightGcdBoundary && ring.coprimes.length > 0 && ring.n !== 'unit') {
                    ctx.save();
                    ctx.globalAlpha = 0.15;
                    ring.coprimes.forEach(r => {
                        const baseAngle = 2 * Math.PI * (ring.modulus - r) / ring.modulus;
                        const angle = baseAngle + ringRotation;
                        const x = ring.radius * Math.cos(angle);
                        const y = ring.radius * Math.sin(angle);
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 15, 0, 2 * Math.PI);
                        ctx.fillStyle = '#48BB78';
                        ctx.fill();
                    });
                    ctx.restore();
                }
                
                // Draw GCD structure connections if enabled
                if (showGcdConnections && ring.coprimes.length > 1 && ring.n !== 'unit') {
                    ctx.save();
                    ctx.globalAlpha = 0.2;
                    ctx.strokeStyle = '#4ECDC4';
                    ctx.lineWidth = 0.5;
                    
                    for (let i = 0; i < ring.coprimes.length; i++) {
                        for (let j = i + 1; j < ring.coprimes.length; j++) {
                            const r1 = ring.coprimes[i];
                            const r2 = ring.coprimes[j];
                            
                            const baseAngle1 = 2 * Math.PI * (ring.modulus - r1) / ring.modulus;
                            const baseAngle2 = 2 * Math.PI * (ring.modulus - r2) / ring.modulus;
                            const angle1 = baseAngle1 + ringRotation;
                            const angle2 = baseAngle2 + ringRotation;
                            
                            const x1 = ring.radius * Math.cos(angle1);
                            const y1 = ring.radius * Math.sin(angle1);
                            const x2 = ring.radius * Math.cos(angle2);
                            const y2 = ring.radius * Math.sin(angle2);
                            
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    }
                    ctx.restore();
                }
                
                residuesToDraw.forEach(({r, isGcdOne}) => {
                    // Transform coordinates based on selected system
                    const coords = transformCoordinates(ring.modulus, r, ring.index, rings.length);
                    
                    // Apply 3D rotation for this ring
                    const ringId = ring.n;
                    const rotation3D = get3DRotationForRing(ringId);
                    const rotated = apply3DRotationToPoint(coords.x, coords.y, coords.z, rotation3D);
                    
                    // Apply perspective if enabled
                    let x = rotated.x;
                    let y = rotated.y;
                    
                    if (enable3DPerspective) {
                        const perspective = 1000; // Distance to viewer
                        const scale = perspective / (perspective + rotated.z);
                        x = rotated.x * scale;
                        y = rotated.y * scale;
                    }
                    
                    const angle = coords.displayAngle;

                    // Enhanced point drawing with normalized thickness controls
                    ctx.beginPath();
                    const pointSizeNorm = parseFloat(document.getElementById('pointSize').value);
                    const basePointSize = ring.n === 'unit' ? 8 : (ring.radius > 150 * globalScale ? 6 : 4);
                    let pointSize = basePointSize * (0.2 + pointSizeNorm * 1.8) * globalScale; // Apply global scale
                    
                    // Prime sieve visualization enhancements
                    if (primeData.isActive && ring.modulus === primeData.modulus) {
                        const showPrimeMarkers = document.getElementById('showPrimeMarkers').checked;
                        const showCompositeMarkers = document.getElementById('showCompositeMarkers').checked;
                        const showPrimeDensity = document.getElementById('showPrimeDensity').checked;
                        
                        if (primeData.residueDistribution[r]) {
                            const residueData = primeData.residueDistribution[r];
                            
                            if (showPrimeDensity) {
                                // Enhance point size based on prime density in this residue class
                                const density = residueData.count / primeData.totalPrimes;
                                pointSize = Math.max(pointSize, pointSize + density * 8);
                            }
                            
                            if (showPrimeMarkers && residueData.count > 0) {
                                // Add golden ring around residue classes containing primes
                                ctx.arc(x, y, pointSize + 3, 0, 2 * Math.PI);
                                ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                                ctx.lineWidth = 2;
                                ctx.stroke();
                                ctx.beginPath();
                            }
                        }
                    }
                    
                    ctx.arc(x, y, pointSize, 0, 2 * Math.PI);
                    
                    let color = getResidueColor(r, ring.modulus, ring.index, colorMode);
                    
                    // Apply GCD animation highlighting
                    if (animateGcdHighlight && isGcdOne) {
                        const pulseIntensity = 0.5 + 0.5 * Math.sin(gcdAnimationPhase + ring.index * 0.2);
                        pointSize *= (1 + pulseIntensity * 0.3);
                        
                        // Add animated glow
                        ctx.save();
                        ctx.globalAlpha = pulseIntensity * 0.4;
                        ctx.beginPath();
                        ctx.arc(x, y, pointSize * 2, 0, 2 * Math.PI);
                        ctx.fillStyle = '#FFD700';
                        ctx.fill();
                        ctx.restore();
                    }
                    
                    // Apply GCD-based styling
                    if (!isGcdOne) {
                        if (highlightGcdDifference) {
                            color = document.getElementById('nonGcdColor').value;
                        }
                        // Apply opacity to non-GCD=1 points
                        const opacity = nonGcdOpacity;
                        if (color.startsWith('#')) {
                            const hex = color.slice(1);
                            const r = parseInt(hex.slice(0, 2), 16);
                            const g = parseInt(hex.slice(2, 4), 16);
                            const b = parseInt(hex.slice(4, 6), 16);
                            color = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        } else if (color.startsWith('hsl')) {
                            color = color.replace('hsl(', 'hsla(').replace(')', `, ${opacity})`);
                        } else if (color.startsWith('rgb')) {
                            color = color.replace('rgb(', 'rgba(').replace(')', `, ${opacity})`);
                        }
                    }
                    
                    // Override color for prime analysis if active
                    if (primeData.isActive && ring.modulus === primeData.modulus) {
                        const showPrimeMarkers = document.getElementById('showPrimeMarkers').checked;
                        const showCompositeMarkers = document.getElementById('showCompositeMarkers').checked;
                        
                        if (showPrimeMarkers || showCompositeMarkers) {
                            if (primeData.residueDistribution[r] && primeData.residueDistribution[r].count > 0) {
                                if (showPrimeMarkers) {
                                    const primeCount = primeData.residueDistribution[r].count;
                                    const maxCount = Math.max(...Object.values(primeData.residueDistribution).map(d => d.count));
                                    const intensity = primeCount / maxCount;
                                    color = `hsla(60, 100%, ${50 + intensity * 30}%, 0.9)`; // Gold gradient
                                }
                            } else if (showCompositeMarkers) {
                                color = 'rgba(128, 128, 128, 0.6)'; // Gray for residue classes with no primes
                            }
                        }
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fill();
                    
                    // Enhanced border for better visibility with normalized thickness
                    const pointBorderNorm = parseFloat(document.getElementById('pointBorder').value);
                    const borderThickness = 0.5 + pointBorderNorm * 2.5; // Scale 0-1 to 0.5-3.0
                    ctx.strokeStyle = ring.n === 'unit' ? 'rgba(255, 255, 255, 0.9)' : 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = borderThickness;
                    ctx.stroke();

                    // Enhanced labels with selective control and sizing
                    if (showLabels) {
                        const labelUnitCircle = document.getElementById('labelUnitCircle').checked;
                        const labelGcdOne = document.getElementById('labelGcdOne').checked;
                        const labelNonGcdOne = document.getElementById('labelNonGcdOne').checked;
                        const labelShowPrimeCounts = document.getElementById('labelShowPrimeCounts').checked;
                        const labelMinRadius = parseInt(document.getElementById('labelMinRadius').value);
                        const labelSize = parseFloat(document.getElementById('labelSize').value);
                        const labelOpacity = parseFloat(document.getElementById('labelOpacity').value);
                        
                        // Check if this ring should have labels
                        let shouldLabel = false;
                        
                        if (ring.n === 'unit' && labelUnitCircle) {
                            shouldLabel = true;
                        } else if (ring.n !== 'unit') {
                            // Check specific moduli list first
                            if (specificLabelMods.size > 0) {
                                shouldLabel = specificLabelMods.has(Math.round(ring.modulus));
                            } else {
                                // Use GCD-based filtering and radius check
                                if (ring.radius >= labelMinRadius) {
                                    if (isGcdOne && labelGcdOne) shouldLabel = true;
                                    if (!isGcdOne && labelNonGcdOne) shouldLabel = true;
                                }
                            }
                        }
                        
                        if (shouldLabel) {
                            ctx.fillStyle = `rgba(255, 255, 255, ${labelOpacity})`;
                            
                            // Use formatLabel function to get properly formatted text
                            let labelText = formatLabel(r, ring.modulus, ring);
                            
                            // Add prime count to label if sieve is active and not already in format
                            if (primeData.isActive && ring.modulus === primeData.modulus && 
                                primeData.residueDistribution[r] && labelShowPrimeCounts && 
                                currentLabelFormat !== 'combined') {
                                const count = primeData.residueDistribution[r].count;
                                if (count > 0 && document.getElementById('showPrimeMarkers')?.checked) {
                                    labelText = `${labelText} (${count})`;
                                }
                            }
                            
                            const baseFontSize = ring.n === 'unit' ? 14 : 11;
                            const fontSize = baseFontSize * labelSize;
                            ctx.font = ring.n === 'unit' ? `bold ${fontSize}px Segoe UI` : `${fontSize}px Segoe UI`;
                            ctx.textAlign = 'center';
                            ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.lineWidth = Math.max(1, fontSize * 0.2);
                            
                            // Handle multi-line labels (for combined format)
                            const lines = labelText.split('\n');
                            const lineHeight = fontSize * 1.2;
                            const startY = y - (ring.n === 'unit' ? fontSize * 0.8 : fontSize * 0.6) - (lines.length - 1) * lineHeight / 2;
                            
                            lines.forEach((line, lineIndex) => {
                                const lineY = startY + lineIndex * lineHeight;
                                ctx.strokeText(line, x, lineY);
                                ctx.fillText(line, x, lineY);
                            });
                        }
                    }
                });
                
                // Show totient count if enabled
                if (showTotientCount && ring.n !== 'unit') {
                    ctx.save();
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                    ctx.font = 'bold 12px Segoe UI';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.lineWidth = 3;
                    const countText = `œÜ=${ring.coprimes.length}`;
                    ctx.strokeText(countText, 0, -ring.radius - 10);
                    ctx.fillText(countText, 0, -ring.radius - 10);
                    ctx.restore();
                }

                // Enhanced gap connections (skip for unit circle as it has no gaps)
                if (ring.n !== 'unit' && showGcdOne) {
                    const gapThicknessNorm = parseFloat(document.getElementById('gapLineThickness').value);
                    const gapLineWidth = 0.2 + gapThicknessNorm * 2.8; // Scale 0-1 to 0.2-3.0
                    
                    selectedGaps.forEach((gap, index) => {
                        const hue = (index * 360 / selectedGaps.length) % 360;
                        
                        ring.coprimes.forEach(r => {
                            const r2 = r + gap;
                            const mod = Math.round(ring.modulus);
                            if (ring.coprimes.includes(r2 % mod)) {
                                // Use coordinate transformation for gap connections
                                const coords1 = transformCoordinates(ring.modulus, r, ring.index, rings.length);
                                const coords2 = transformCoordinates(ring.modulus, r2 % mod, ring.index, rings.length);
                                
                                const x1 = coords1.x;
                                const y1 = coords1.y;
                                const x2 = coords2.x;
                                const y2 = coords2.y;

                                ctx.beginPath();
                                ctx.moveTo(x1, y1);
                                ctx.lineTo(x2, y2);
                                ctx.strokeStyle = `hsla(${hue}, 75%, 65%, 0.6)`;
                                ctx.lineWidth = gapLineWidth;
                                ctx.stroke();
                            }
                        });
                    });
                }
            });

            // Enhanced lift line drawing with 4 distinct modes and solid lines
            if ((showDirectLifts || showModularLifts || showSkipDirectLifts || showSkipModularLifts) && rings.length > 1) {
                const liftThicknessNorm = parseFloat(document.getElementById('lineThickness').value);
                const baseLiftThickness = 0.5 + liftThicknessNorm * 3.5; // Scale 0-1 to 0.5-4.0
                
                for (let i = 0; i < rings.length; i++) {
                    for (let j = i + 1; j < rings.length; j++) {
                        const ring1 = rings[i];
                        const ring2 = rings[j];
                        const isConsecutive = (j === i + 1);
                        
                        // Calculate rotations for both rings
                        let ringRotation1 = 0;
                        let ringRotation2 = 0;
                        if (enableRotation) {
                            ringRotation1 = animationFrame * ringRotationSpeeds[ring1.n] * Math.PI / 180;
                            ringRotation2 = animationFrame * ringRotationSpeeds[ring2.n] * Math.PI / 180;
                        }
                        
                        if (isInverting) {
                            const waveOffset1 = ring1.index * 0.15;
                            const waveOffset2 = ring2.index * 0.15;
                            const inversionPhase1 = Math.max(0, Math.min(1, inversionProgress * 3 - waveOffset1));
                            const inversionPhase2 = Math.max(0, Math.min(1, inversionProgress * 3 - waveOffset2));
                            const pattern = document.getElementById('inversionPattern').value;
                            
                            switch(pattern) {
                                case 'wave':
                                    ringRotation1 += Math.sin(inversionPhase1 * Math.PI) * Math.PI * inversionIntensity;
                                    ringRotation2 += Math.sin(inversionPhase2 * Math.PI) * Math.PI * inversionIntensity;
                                    break;
                                case 'spiral':
                                    ringRotation1 += inversionPhase1 * Math.PI * 2 * inversionIntensity;
                                    ringRotation2 += inversionPhase2 * Math.PI * 2 * inversionIntensity;
                                    break;
                                case 'pulse':
                                    const pulse1 = Math.sin(inversionPhase1 * Math.PI * 4);
                                    const pulse2 = Math.sin(inversionPhase2 * Math.PI * 4);
                                    ringRotation1 += pulse1 * Math.PI * 0.5 * inversionIntensity;
                                    ringRotation2 += pulse2 * Math.PI * 0.5 * inversionIntensity;
                                    break;
                                case 'twist':
                                    const twist1 = ring1.radius / maxRadius;
                                    const twist2 = ring2.radius / maxRadius;
                                    ringRotation1 += inversionPhase1 * Math.PI * twist1 * inversionIntensity;
                                    ringRotation2 += inversionPhase2 * Math.PI * twist2 * inversionIntensity;
                                    break;
                            }
                        }
                        
                        ring1.coprimes.forEach(r => {
                            // 1. Direct lifts (consecutive only, r ‚Üí r)
                            if (showDirectLifts && isConsecutive && ring2.coprimes.includes(r)) {
                                drawLiftLine(ring1, ring2, r, r, ringRotation1, ringRotation2, liftLineColor, baseLiftThickness, false, rings.length);
                            }
                            
                            // 2. Skip-level direct lifts (all combinations, r ‚Üí r)
                            if (showSkipDirectLifts && !isConsecutive && ring2.coprimes.includes(r)) {
                                drawLiftLine(ring1, ring2, r, r, ringRotation1, ringRotation2, liftLineColor, baseLiftThickness * 0.6, false, rings.length);
                            }
                            
                            // 3. Modular lifts (consecutive only, r ‚Üí r + M√ó2‚Åø)
                            if (showModularLifts && isConsecutive && ring1.n !== 'unit' && ring2.n !== 'unit') {
                                const shift = Math.round(ring1.modulus);
                                const liftedR = (r + shift) % Math.round(ring2.modulus);
                                
                                if (ring2.coprimes.includes(liftedR)) {
                                    drawLiftLine(ring1, ring2, r, liftedR, ringRotation1, ringRotation2, modularLiftColor, baseLiftThickness * 0.9, false, rings.length);
                                }
                            }
                            
                            // 4. Skip-level modular lifts (all combinations, r ‚Üí r + M√ó2‚Åø)
                            if (showSkipModularLifts && !isConsecutive && ring1.n !== 'unit' && ring2.n !== 'unit') {
                                const n1 = parseInt(ring1.n) || 0;
                                const n2 = parseInt(ring2.n) || 0;
                                
                                if (!isNaN(n1) && !isNaN(n2) && n2 > n1) {
                                    const nDiff = n2 - n1;
                                    const baseModulus = Math.round(ring1.modulus);
                                    const shift = baseModulus * Math.pow(2, nDiff - 1);
                                    const liftedR = (r + shift) % Math.round(ring2.modulus);
                                    
                                    if (ring2.coprimes.includes(liftedR)) {
                                        drawLiftLine(ring1, ring2, r, liftedR, ringRotation1, ringRotation2, modularLiftColor, baseLiftThickness * 0.5, false, rings.length);
                                    }
                                }
                            }
                        });
                    }
                }
            }

            ctx.restore();
            
            // Draw Zero-Residue Alignment visualizations if active
            if (zeroAlignmentActive) {
                drawPrimePhaseVectors(rings);
            }
            
            // Draw coordinate system indicator
            if (coordinateSystem !== 'polar') {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 10, 200, 40);
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.strokeRect(10, 10, 200, 40);
                
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 14px Segoe UI';
                ctx.textAlign = 'left';
                
                const systemNames = {
                    'log-cylinder': 'Log-Cylinder (u,v)',
                    'spiral': 'Logarithmic Spiral',
                    'hyperbolic': 'Hyperbolic Space',
                    'rectangular': 'Rectangular Grid',
                    'treemap': 'Treemap',
                    'voronoi': 'Voronoi',
                    'fractal': 'Fractal'
                };
                
                ctx.fillText(systemNames[coordinateSystem] || coordinateSystem, 20, 35);
                ctx.restore();
            }
            
            // Draw distance measurement highlights if active
            if (distanceMeasurementActive) {
                drawMeasurementPoints();
            }
            
            updateInfo(rings);
        }

        // Helper function to draw lift lines (needs rings context)
        function drawLiftLine(ring1, ring2, r1, r2, rotation1, rotation2, color, thickness, isDashed, totalRings) {
            // Get coordinates for both points using current coordinate system
            const coords1 = transformCoordinates(ring1.modulus, r1, ring1.index, totalRings);
            const coords2 = transformCoordinates(ring2.modulus, r2, ring2.index, totalRings);
            
            const x1 = coords1.x;
            const y1 = coords1.y;
            const x2 = coords2.x;
            const y2 = coords2.y;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            
            const hasUnitCircle = ring1.n === 'unit' || ring2.n === 'unit';
            
            if (hasUnitCircle) {
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)'; // Golden for unit circle connections
                ctx.lineWidth = thickness * 1.2;
            } else {
                ctx.strokeStyle = color;
                ctx.lineWidth = thickness;
            }
            
            // All lines are solid now
            ctx.setLineDash([]);
            ctx.stroke();
        }

        // Toggle function for analysis section
        function toggleAnalysisSection() {
            const content = document.getElementById('ringInfo');
            const icon = document.getElementById('analysisCollapseIcon');
            
            content.classList.toggle('collapsed');
            icon.classList.toggle('collapsed');
        }

        // Toggle function for legend section
        function toggleLegendSection() {
            const content = document.getElementById('legendContent');
            const icon = document.getElementById('legendCollapseIcon');
            
            content.classList.toggle('collapsed');
            icon.classList.toggle('collapsed');
        }

        // Toggle function for control sections
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const icon = document.getElementById(sectionId + 'Icon');
            
            if (section) {
                section.classList.toggle('collapsed');
                if (icon) {
                    icon.classList.toggle('collapsed');
                }
            }
        }

                    // Enhanced info panel update with prime sieve integration
        function updateInfo(rings) {
            const info = document.getElementById('ringInfo');
            
            if (rings.length === 0) {
                info.innerHTML = '<em>No rings selected</em><br><br><strong>Tip:</strong> Try adding consecutive moduli M‚ÇÅ to M‚ÇÇ‚ÇÄ for systematic exploration starting from the mathematical foundation.';
                return;
            }

            let html = '';
            let totalResidues = 0;
            
            rings.forEach((ring, visualIndex) => {
                const config = configs[ring.n];
                const modLabel = config ? config.label : ring.modulus.toString();
                totalResidues += ring.coprimes.length;
                
                let ringTitle;
                let specialNote = '';
                
                if (ring.n === 'unit') {
                    ringTitle = 'Unit Circle';
                    specialNote = '<br><em>Fundamental mathematical foundation</em><br><em>Contains residue 0 where gcd(0,1) = 1</em>';
                } else if (ring.n.startsWith('custom_') || ring.n.startsWith('sieve_')) {
                    ringTitle = ring.n.startsWith('sieve_') ? 'Sieve Ring' : 'Custom Ring';
                } else {
                    ringTitle = `Ring M<sub>${ring.n}</sub>`;
                }
                
                // Add prime sieve information if applicable
                if (primeData.isActive && ring.modulus === primeData.modulus) {
                    specialNote += '<br><strong style="color: #FFD700;">üéØ Prime Sieve Active</strong>';
                    const totalPrimesInRing = Object.values(primeData.residueDistribution).reduce((sum, data) => sum + data.count, 0);
                    specialNote += `<br><em>Contains ${totalPrimesInRing} of ${primeData.totalPrimes} primes up to ${primeData.limit}</em>`;
                }
                
                const infoClass = ring.n === 'unit' ? 'unit-circle-info' : 'ring-info';
                
                // Show only first 5 residues, hide the rest with "..."
                const displayResidues = ring.coprimes.length > 5 
                    ? `${ring.coprimes.slice(0, 5).join(', ')}...` 
                    : ring.coprimes.join(', ');
                
                html += `<div class="${infoClass}">
                    <strong>${ringTitle}</strong><br>
                    <em class="math-notation">M = ${modLabel}</em><br>
                    <em class="math-notation">œÜ(M) = ${ring.coprimes.length}</em><br>
                    Residues: [${displayResidues}]
                    ${specialNote}
                </div>`;
            });

            const gaps = getSelectedGaps();
            if (gaps.length > 0) {
                html += `<div class="ring-info">
                    <strong>Active Gap Analysis:</strong><br>
                    Gaps: [${gaps.join(', ')}]<br>
                    <em>Exploring prime gap patterns across ${rings.length} ring${rings.length > 1 ? 's' : ''}</em>
                </div>`;
            }

            // Add prime sieve summary if active
            if (primeData.isActive) {
                const eulerPhi = getCoprimes(primeData.modulus).length;
                const avgPrimesPerResidue = (primeData.totalPrimes / eulerPhi).toFixed(1);
                
                html += `<div class="ring-info" style="border-left: 3px solid #FFD700;">
                    <strong>Prime Sieve Analysis:</strong><br>
                    Modulus: ${primeData.modulus}, Limit: ${primeData.limit}<br>
                    Total Primes: ${primeData.totalPrimes}<br>
                    Avg per residue: ${avgPrimesPerResidue}<br>
                    <em>Distribution across œÜ(${primeData.modulus}) = ${eulerPhi} classes</em>
                </div>`;
            }

            html += `<div class="ring-info">
                <strong>System Summary:</strong><br>
                Total Rings: ${rings.length}<br>
                Total Residues: ${totalResidues}<br>
                <em class="math-notation">‚àëœÜ(M<sub>i</sub>) = ${totalResidues}</em>
            </div>`;

            info.innerHTML = html;
        }

        // Add missing prime search and export functions
        function exportDetailedPrimeList() {
            if (!primeData.isActive) {
                alert('No prime data to export. Run a sieve first.');
                return;
            }
            
            let exportText = `Complete Prime Distribution Analysis\n`;
            exportText += `Modulus: ${primeData.modulus}, Limit: ${primeData.limit}\n`;
            exportText += `Total Primes: ${primeData.totalPrimes}\n`;
            exportText += `Generated: ${new Date().toISOString()}\n\n`;
            
            const sortedResidues = Object.keys(primeData.residueDistribution).sort((a, b) => parseInt(a) - parseInt(b));
            
            sortedResidues.forEach(residue => {
                const data = primeData.residueDistribution[residue];
                exportText += `\n=== Residue Class r ‚â° ${residue} (mod ${primeData.modulus}) ===\n`;
                exportText += `Count: ${data.count} primes (${data.percentage}%)\n`;
                
                if (data.count === 0) {
                    exportText += `No primes in this residue class\n`;
                } else {
                    exportText += `All ${data.count} primes: `;
                    // Format in rows of 15 for readability
                    for (let i = 0; i < data.primes.length; i += 15) {
                        if (i > 0) exportText += '\n                     ';
                        exportText += data.primes.slice(i, i + 15).join(', ');
                        if (i + 15 < data.primes.length) exportText += ',';
                    }
                    exportText += '\n';
                }
            });
            
            const dataBlob = new Blob([exportText], {type: 'text/plain'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `complete_prime_distribution_mod${primeData.modulus}_to_${primeData.limit}.txt`;
            link.click();
            
            URL.revokeObjectURL(url);
            updateAnimationStatus('Complete prime distribution exported');
        }
        
        function togglePrimeSearchMode() {
            const controls = document.getElementById('primeSearchControls');
            const isVisible = controls.style.display !== 'none';
            controls.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                document.getElementById('searchPrime').focus();
            }
        }
        
        function findPrimeInResidue() {
            const searchPrime = parseInt(document.getElementById('searchPrime').value);
            const result = document.getElementById('searchResult');
            
            if (!primeData.isActive) {
                result.innerHTML = '<span style="color: #FF6B6B;">No sieve data available. Run a prime sieve first.</span>';
                return;
            }
            
            if (!searchPrime || searchPrime < 2) {
                result.innerHTML = '<span style="color: #FF6B6B;">Please enter a valid prime number ‚â• 2.</span>';
                return;
            }
            
            if (!isPrime(searchPrime)) {
                result.innerHTML = `<span style="color: #FF6B6B;">${searchPrime} is not a prime number.</span>`;
                return;
            }
            
            if (searchPrime > primeData.limit) {
                result.innerHTML = `<span style="color: #FFA500;">Prime ${searchPrime} is beyond sieve limit ${primeData.limit}. Cannot verify presence in residue classes.</span>`;
                return;
            }
            
            const residue = searchPrime % primeData.modulus;
            const residueData = primeData.residueDistribution[residue];
            
            if (residueData && residueData.primes.includes(searchPrime)) {
                const position = residueData.primes.indexOf(searchPrime) + 1;
                result.innerHTML = `
                    <span style="color: #4ECDC4;"><strong>‚úì Found!</strong></span><br>
                    Prime ${searchPrime} ‚â° ${residue} (mod ${primeData.modulus})<br>
                    Position ${position} of ${residueData.count} primes in this residue class<br>
                    <em>This residue class contains ${residueData.percentage}% of all primes up to ${primeData.limit}</em>
                `;
            } else if (gcd(residue, primeData.modulus) !== 1) {
                result.innerHTML = `
                    <span style="color: #FF6B6B;"><strong>Impossible!</strong></span><br>
                    Prime ${searchPrime} ‚â° ${residue} (mod ${primeData.modulus})<br>
                    But gcd(${residue}, ${primeData.modulus}) = ${gcd(residue, primeData.modulus)} ‚â† 1<br>
                    <em>This residue class cannot contain primes (except possibly small exceptions)</em>
                `;
            } else {
                result.innerHTML = `
                    <span style="color: #FFA500;"><strong>Not found in sieve data</strong></span><br>
                    Prime ${searchPrime} should be ‚â° ${residue} (mod ${primeData.modulus})<br>
                    <em>This may indicate the prime is beyond the sieve limit or there's a calculation error</em>
                `;
            }
        }

        // Enhanced initialization
        function initControls() {
            // Add unit circle first (highlighted and checked by default)
            addRingControl('unit', 'Unit Circle (M=1)', true);
            
            // Add consecutive moduli 1-60 by default
            for (let mod = 2; mod <= 60; mod++) {
                const customId = `default_${mod}`;
                configs[customId] = { 
                    mod: mod, 
                    label: mod.toString(),
                    description: `Default modulus ${mod}`
                };
                addRingControl(customId, `M${mod}`, true);
            }
            
            // Add standard M_n series (unchecked by default)
            Object.keys(configs).forEach(n => {
                if (!n.startsWith('custom_') && !n.startsWith('default_') && n !== 'unit') {
                    addRingControl(n, `n=${n} (M=${configs[n].label})`, false);
                }
            });

            // Initialize gap controls as empty - will be populated by generateGaps()
            const gapControls = document.getElementById('gapControls');
            gapControls.innerHTML = '';
            
            // Add standard gaps but all unchecked by default
            for (let gap = 2; gap <= 12; gap += 2) {
                addGapControl(gap, false); // All gaps off by default
            }

            // Enhanced event listeners
            document.addEventListener('change', draw);
            document.getElementById('zoomSlider').addEventListener('input', updateZoom);
            document.getElementById('rotationSlider').addEventListener('input', updateRotation);
            document.getElementById('animResolution').addEventListener('change', function() {
                const customControls = document.getElementById('customResolutionControls');
                customControls.style.display = this.value === 'custom' ? 'block' : 'none';
            });
            
            updateAnimationStatus('System initialized: M1-M60, Angular coloring, no gaps, no labels, direct lifts only');
        }

        // Initialize the enhanced system
        initControls();
        draw();
        
        // Add window resize handler for responsive layout
        window.addEventListener('resize', () => {
            // Debounce resize events
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(() => {
                draw();
            }, 250);
        });
        
        // Initialize RH visualizations after a short delay
        setTimeout(() => {
            updateRhVisualizations();
        }, 500);
    </script>
</body>
</html>
