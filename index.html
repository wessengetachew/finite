
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Rings - PIXI.js Enhanced</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            background: #000;
            color: #fff;
            line-height: 1.6;
        }

        .header {
            background: #000;
            padding: 30px 20px;
            text-align: center;
            border-bottom: 2px solid #fff;
        }

        .header h1 {
            font-size: 32px;
            font-weight: 400;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .header .subtitle {
            font-size: 16px;
            font-style: italic;
            opacity: 0.8;
        }

        .tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 2px solid #fff;
            padding: 0 20px;
        }

        .tab {
            padding: 15px 30px;
            background: transparent;
            border: none;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 1px;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }

        .tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .tab.active {
            border-bottom-color: #fff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            height: calc(100vh - 160px);
        }

        .control-panel {
            background: #1a1a1a;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #333;
        }

        .control-section {
            background: #252525;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 16px;
        }

        .control-section h3 {
            font-size: 14px;
            margin-bottom: 12px;
            color: #aaa;
            font-weight: 500;
        }

        label {
            display: block;
            margin: 12px 0 6px 0;
            color: #ccc;
            font-size: 13px;
        }

        input[type="number"],
        select {
            width: 100%;
            padding: 8px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: #fff;
            font-size: 13px;
        }

        input[type="range"] {
            width: 100%;
        }

        button {
            width: 100%;
            padding: 10px;
            background: #fff;
            border: none;
            border-radius: 4px;
            color: #000;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 12px;
        }

        button:hover {
            background: #ddd;
        }

        .canvas-container {
            position: relative;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        
        .canvas-container canvas {
            display: block;
        }

        .range-value {
            float: right;
            color: #fff;
            font-weight: 600;
        }

        .stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            color: #0f0;
        }

        .grid-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>MODULAR RINGS VISUALIZATION</h1>
        <div class="subtitle">GCD Channels & Farey Sequences • PIXI.js Enhanced</div>
    </div>

    <div class="tabs">
        <button class="tab active" onclick="switchTab('visualization')">Main Visualization</button>
        <button class="tab" onclick="switchTab('composite')">Composite Projection</button>
        <button class="tab" onclick="switchTab('primitive')">Primitive Roots</button>
    </div>

    <!-- VISUALIZATION TAB -->
    <div id="visualizationTab" class="tab-content active">
        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Modulus Range</h3>
                    <div class="grid-inputs">
                        <div>
                            <label>Min M:</label>
                            <input type="number" id="modMin" value="1" min="1" max="10000">
                        </div>
                        <div>
                            <label>Max M:</label>
                            <input type="number" id="modMax" value="60" min="1" max="10000">
                        </div>
                    </div>
                    <label>Step:</label>
                    <input type="number" id="modStep" value="1" min="1">
                    <button onclick="updateVisualization()">Generate</button>
                </div>

                <div class="control-section">
                    <h3>Display</h3>
                    <label>Point Size: <span class="range-value" id="pointSizeValue">2.0</span></label>
                    <input type="range" id="pointSize" min="0.5" max="10" step="0.5" value="2" oninput="updatePointSize()">
                    
                    <label>Zoom: <span class="range-value" id="zoomValue">1.0</span></label>
                    <input type="range" id="zoom" min="0.1" max="5" step="0.1" value="1" oninput="updateZoom()">
                    
                    <label>Rotation: <span class="range-value" id="rotationValue">0°</span></label>
                    <input type="range" id="rotation" min="0" max="360" step="1" value="0" oninput="updateRotation()">
                </div>

                <div class="control-section">
                    <h3>Angular Mode</h3>
                    <select id="angularMode" onchange="render()">
                        <option value="2pir/m">2πr/M (Standard)</option>
                        <option value="-2pir/m">-2πr/M (Negative)</option>
                        <option value="2pi(m-r)/m">2π(M-r)/M (Complement)</option>
                        <option value="index">By Index Order</option>
                    </select>
                </div>
            </div>

            <div class="canvas-container" id="mainContainer">
                <div class="stats" id="mainStats">Initializing PIXI...</div>
            </div>
        </div>
    </div>

    <!-- COMPOSITE TAB -->
    <div id="compositeTab" class="tab-content">
        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Composite Projection</h3>
                    <label>Modulus:</label>
                    <input type="number" id="compMod" value="30" min="2" max="1000">
                    <button onclick="updateComposite()">Generate</button>
                </div>

                <div class="control-section">
                    <h3>Display</h3>
                    <label>Point Size: <span class="range-value" id="compPointSizeValue">3.0</span></label>
                    <input type="range" id="compPointSize" min="1" max="10" step="0.5" value="3" oninput="updateCompPointSize()">
                </div>
            </div>

            <div class="canvas-container" id="compContainer">
                <div class="stats" id="compStats">Loading...</div>
            </div>
        </div>
    </div>

    <!-- PRIMITIVE ROOTS TAB -->
    <div id="primitiveTab" class="tab-content">
        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Primitive Roots</h3>
                    <label>Modulus (prime):</label>
                    <input type="number" id="primMod" value="17" min="2" max="1000">
                    <button onclick="updatePrimitive()">Generate</button>
                </div>

                <div class="control-section">
                    <h3>Display</h3>
                    <label>Point Size: <span class="range-value" id="primPointSizeValue">3.0</span></label>
                    <input type="range" id="primPointSize" min="1" max="10" step="0.5" value="3" oninput="updatePrimPointSize()">
                </div>
            </div>

            <div class="canvas-container" id="primContainer">
                <div class="stats" id="primStats">Loading...</div>
            </div>
        </div>
    </div>

    <script>
        // PIXI Applications - one for each tab
        let mainApp, compApp, primApp;
        let mainContainer, compContainer, primContainer;
        let mainGraphics, compGraphics, primGraphics;

        // State
        let pointsData = [];
        let transform = { x: 0, y: 0, scale: 1 };
        let globalRotation = 0;
        let currentTab = 'visualization';

        // Check if PIXI is loaded
        function checkPIXI() {
            if (typeof PIXI === 'undefined') {
                console.error('PIXI not loaded!');
                document.getElementById('mainStats').innerHTML = 'ERROR: PIXI.js not loaded<br>Check internet connection';
                return false;
            }
            console.log('PIXI version:', PIXI.VERSION);
            return true;
        }

        // Initialize all PIXI apps
        function initPIXI() {
            console.log('Initializing PIXI apps...');
            
            if (!checkPIXI()) {
                return;
            }
            
            try {
                // Main visualization
                mainApp = new PIXI.Application({
                width: 1000,
                height: 800,
                backgroundColor: 0x000000,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true
            });
            document.getElementById('mainContainer').appendChild(mainApp.view);
            mainContainer = new PIXI.Container();
            mainApp.stage.addChild(mainContainer);
            mainContainer.x = mainApp.screen.width / 2;
            mainContainer.y = mainApp.screen.height / 2;
            mainGraphics = new PIXI.Graphics();
            mainContainer.addChild(mainGraphics);

            // Composite
            compApp = new PIXI.Application({
                width: 1000,
                height: 800,
                backgroundColor: 0x000000,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true
            });
            document.getElementById('compContainer').appendChild(compApp.view);
            compContainer = new PIXI.Container();
            compApp.stage.addChild(compContainer);
            compContainer.x = compApp.screen.width / 2;
            compContainer.y = compApp.screen.height / 2;
            compGraphics = new PIXI.Graphics();
            compContainer.addChild(compGraphics);

            // Primitive
            primApp = new PIXI.Application({
                width: 1000,
                height: 800,
                backgroundColor: 0x000000,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true
            });
            document.getElementById('primContainer').appendChild(primApp.view);
            primContainer = new PIXI.Container();
            primApp.stage.addChild(primContainer);
            primContainer.x = primApp.screen.width / 2;
            primContainer.y = primApp.screen.height / 2;
            primGraphics = new PIXI.Graphics();
            primContainer.addChild(primGraphics);

            console.log('All PIXI apps initialized successfully');
            console.log('Main app:', mainApp.view.width, 'x', mainApp.view.height);
            
            // Draw test pattern to confirm PIXI is working
            mainGraphics.beginFill(0xFF0000);
            mainGraphics.drawCircle(0, 0, 50);
            mainGraphics.endFill();
            
            compGraphics.beginFill(0x00FF00);
            compGraphics.drawCircle(0, 0, 50);
            compGraphics.endFill();
            
            primGraphics.beginFill(0x0000FF);
            primGraphics.drawCircle(0, 0, 50);
            primGraphics.endFill();
            
            console.log('Test circles drawn');
            
            // Immediately update stats to remove "Loading..."
            document.getElementById('mainStats').innerHTML = 'Ready - Click Generate<br>(Test circle visible)';
            document.getElementById('compStats').innerHTML = 'Ready';
            document.getElementById('primStats').innerHTML = 'Ready';
            
            } catch (error) {
                console.error('PIXI initialization error:', error);
                document.getElementById('mainStats').innerHTML = 'ERROR: ' + error.message;
            }
        }

        // GCD function
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b !== 0) {
                const t = b;
                b = a % b;
                a = t;
            }
            return a;
        }

        // Get coprimes
        function getCoprimes(mod) {
            const coprimes = [];
            for (let r = 0; r < mod; r++) {
                if (gcd(r, mod) === 1) {
                    coprimes.push(r);
                }
            }
            return coprimes;
        }

        // Calculate angle based on mode
        function calculateAngle(residue, residueIndex, mod, coprimes) {
            const mode = document.getElementById('angularMode').value;
            let angle;

            switch(mode) {
                case '2pir/m':
                    angle = (2 * Math.PI * residue) / mod;
                    break;
                case '-2pir/m':
                    angle = -(2 * Math.PI * residue) / mod;
                    break;
                case '2pi(m-r)/m':
                    angle = (2 * Math.PI * (mod - residue)) / mod;
                    break;
                case 'index':
                    angle = (2 * Math.PI * residueIndex) / coprimes.length;
                    break;
                default:
                    angle = (2 * Math.PI * residue) / mod;
            }

            return angle;
        }

        // Main visualization render
        function renderMain() {
            if (!mainApp || !mainGraphics) return;

            mainGraphics.clear();

            const pointSize = parseFloat(document.getElementById('pointSize').value);
            const maxRadius = Math.min(mainApp.screen.width, mainApp.screen.height) * 0.4;

            // Apply transforms
            mainContainer.position.set(
                mainApp.screen.width / 2 + transform.x,
                mainApp.screen.height / 2 + transform.y
            );
            mainContainer.scale.set(transform.scale, transform.scale);
            mainContainer.rotation = globalRotation * Math.PI / 180;

            pointsData.forEach(point => {
                const angle = calculateAngle(point.r, point.rIndex, point.m, point.coprimes);
                const radius = (point.ringIndex + 1) * (maxRadius / pointsData.length);
                
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);

                const color = point.isOpen ? 0xFFFFFF : 0x888888;

                mainGraphics.beginFill(color, 0.8);
                mainGraphics.drawCircle(x, y, pointSize);
                mainGraphics.endFill();
            });

            updateMainStats();
        }

        // Composite render
        function renderComposite() {
            if (!compApp || !compGraphics) return;

            compGraphics.clear();

            const mod = parseInt(document.getElementById('compMod').value);
            const pointSize = parseFloat(document.getElementById('compPointSize').value);
            const maxRadius = Math.min(compApp.screen.width, compApp.screen.height) * 0.4;

            for (let r = 0; r < mod; r++) {
                const isOpen = gcd(r, mod) === 1;
                const angle = (2 * Math.PI * r) / mod;
                const x = maxRadius * Math.cos(angle);
                const y = maxRadius * Math.sin(angle);

                const color = isOpen ? 0x00FF00 : 0xFF0000;

                compGraphics.beginFill(color, 0.9);
                compGraphics.drawCircle(x, y, pointSize);
                compGraphics.endFill();
            }

            document.getElementById('compStats').innerHTML = `Modulus: ${mod}<br>Points: ${mod}`;
        }

        // Primitive roots render
        function renderPrimitive() {
            if (!primApp || !primGraphics) return;

            primGraphics.clear();

            const mod = parseInt(document.getElementById('primMod').value);
            const pointSize = parseFloat(document.getElementById('primPointSize').value);
            const maxRadius = Math.min(primApp.screen.width, primApp.screen.height) * 0.4;

            // Check if mod is prime (simple check)
            const isPrime = (n) => {
                if (n < 2) return false;
                for (let i = 2; i <= Math.sqrt(n); i++) {
                    if (n % i === 0) return false;
                }
                return true;
            };

            if (!isPrime(mod)) {
                document.getElementById('primStats').innerHTML = `${mod} is not prime!`;
                return;
            }

            // Find primitive roots (simplified)
            const primitiveRoots = [];
            for (let g = 1; g < mod; g++) {
                let isPrimitive = true;
                const seen = new Set();
                for (let k = 1; k < mod; k++) {
                    const val = Math.pow(g, k) % mod;
                    if (seen.has(val)) {
                        isPrimitive = false;
                        break;
                    }
                    seen.add(val);
                }
                if (isPrimitive && seen.size === mod - 1) {
                    primitiveRoots.push(g);
                }
            }

            // Draw all residues
            for (let r = 1; r < mod; r++) {
                const angle = (2 * Math.PI * r) / mod;
                const x = maxRadius * Math.cos(angle);
                const y = maxRadius * Math.sin(angle);

                const isPrimRoot = primitiveRoots.includes(r);
                const color = isPrimRoot ? 0xFFFF00 : 0x666666;

                primGraphics.beginFill(color, isPrimRoot ? 1.0 : 0.5);
                primGraphics.drawCircle(x, y, isPrimRoot ? pointSize * 1.5 : pointSize);
                primGraphics.endFill();
            }

            document.getElementById('primStats').innerHTML = 
                `Modulus: ${mod} (prime)<br>Primitive Roots: ${primitiveRoots.length}<br>Roots: ${primitiveRoots.join(', ')}`;
        }

        // Update functions
        function updateVisualization() {
            const modMin = parseInt(document.getElementById('modMin').value);
            const modMax = parseInt(document.getElementById('modMax').value);
            const modStep = parseInt(document.getElementById('modStep').value);

            pointsData = [];
            let ringIndex = 0;

            for (let m = modMin; m <= modMax; m += modStep) {
                const coprimes = getCoprimes(m);
                coprimes.forEach((r, rIndex) => {
                    pointsData.push({
                        m: m,
                        r: r,
                        rIndex: rIndex,
                        coprimes: coprimes,
                        ringIndex: ringIndex,
                        isOpen: gcd(r, m) === 1
                    });
                });
                ringIndex++;
            }

            renderMain();
        }

        function updateComposite() {
            renderComposite();
        }

        function updatePrimitive() {
            renderPrimitive();
        }

        function updateMainStats() {
            const totalPoints = pointsData.length;
            const openPoints = pointsData.filter(p => p.isOpen).length;
            document.getElementById('mainStats').innerHTML = 
                `Points: ${totalPoints.toLocaleString()}<br>Open: ${openPoints}<br>FPS: ${Math.round(mainApp.ticker.FPS)}`;
        }

        // Control functions
        function updatePointSize() {
            const val = document.getElementById('pointSize').value;
            document.getElementById('pointSizeValue').textContent = parseFloat(val).toFixed(1);
            renderMain();
        }

        function updateZoom() {
            transform.scale = parseFloat(document.getElementById('zoom').value);
            document.getElementById('zoomValue').textContent = transform.scale.toFixed(1);
            renderMain();
        }

        function updateRotation() {
            globalRotation = parseFloat(document.getElementById('rotation').value);
            document.getElementById('rotationValue').textContent = globalRotation.toFixed(0) + '°';
            renderMain();
        }

        function updateCompPointSize() {
            const val = document.getElementById('compPointSize').value;
            document.getElementById('compPointSizeValue').textContent = parseFloat(val).toFixed(1);
            renderComposite();
        }

        function updatePrimPointSize() {
            const val = document.getElementById('primPointSize').value;
            document.getElementById('primPointSizeValue').textContent = parseFloat(val).toFixed(1);
            renderPrimitive();
        }

        // Tab switching
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));

            // Show selected tab
            if (tabName === 'visualization') {
                document.getElementById('visualizationTab').classList.add('active');
            } else if (tabName === 'composite') {
                document.getElementById('compositeTab').classList.add('active');
            } else if (tabName === 'primitive') {
                document.getElementById('primitiveTab').classList.add('active');
            }

            // Activate button
            event.target.classList.add('active');
            currentTab = tabName;
        }

        // Mouse interaction for main canvas
        let isDragging = false;
        let lastX = 0, lastY = 0;

        mainApp.view.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        window.addEventListener('mousemove', (e) => {
            if (isDragging && currentTab === 'visualization') {
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                transform.x += dx;
                transform.y += dy;
                lastX = e.clientX;
                lastY = e.clientY;
                renderMain();
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Wheel zoom
        mainApp.view.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            transform.scale *= delta;
            transform.scale = Math.max(0.1, Math.min(5, transform.scale));
            document.getElementById('zoom').value = transform.scale;
            document.getElementById('zoomValue').textContent = transform.scale.toFixed(1);
            renderMain();
        });

        // Initialize
        window.addEventListener('load', () => {
            console.log('Page loaded, initializing...');
            
            // Wait a moment for DOM to be fully ready
            setTimeout(() => {
                try {
                    initPIXI();
                    console.log('PIXI initialized, generating initial data...');
                    
                    // Generate initial visualizations
                    updateVisualization();
                    updateComposite();
                    updatePrimitive();
                    
                    console.log('All visualizations generated');
                } catch (error) {
                    console.error('Initialization error:', error);
                    alert('Error initializing PIXI: ' + error.message);
                }
            }, 100);
        });
    </script>
</body>
</html>
